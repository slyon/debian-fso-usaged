/* commands.c generated by valac 0.16.0, the Vala compiler
 * generated from commands.vala, do not modify */

/*
 * FSO Resource Commands
 *
 * (C) 2009-2012 Michael 'Mickey' Lauer <mlauer@vanille-media.de>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <gio/gio.h>
#include <freesmartphone.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <fsobasics.h>
#include <gobject/gvaluecollector.h>


#define USAGE_TYPE_RESOURCE_COMMAND (usage_resource_command_get_type ())
#define USAGE_RESOURCE_COMMAND(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), USAGE_TYPE_RESOURCE_COMMAND, UsageResourceCommand))
#define USAGE_RESOURCE_COMMAND_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), USAGE_TYPE_RESOURCE_COMMAND, UsageResourceCommandClass))
#define USAGE_IS_RESOURCE_COMMAND(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), USAGE_TYPE_RESOURCE_COMMAND))
#define USAGE_IS_RESOURCE_COMMAND_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), USAGE_TYPE_RESOURCE_COMMAND))
#define USAGE_RESOURCE_COMMAND_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), USAGE_TYPE_RESOURCE_COMMAND, UsageResourceCommandClass))

typedef struct _UsageResourceCommand UsageResourceCommand;
typedef struct _UsageResourceCommandClass UsageResourceCommandClass;
typedef struct _UsageResourceCommandPrivate UsageResourceCommandPrivate;

#define USAGE_TYPE_RESOURCE (usage_resource_get_type ())
#define USAGE_RESOURCE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), USAGE_TYPE_RESOURCE, UsageResource))
#define USAGE_RESOURCE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), USAGE_TYPE_RESOURCE, UsageResourceClass))
#define USAGE_IS_RESOURCE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), USAGE_TYPE_RESOURCE))
#define USAGE_IS_RESOURCE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), USAGE_TYPE_RESOURCE))
#define USAGE_RESOURCE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), USAGE_TYPE_RESOURCE, UsageResourceClass))

typedef struct _UsageResource UsageResource;
typedef struct _UsageResourceClass UsageResourceClass;

#define USAGE_TYPE_IRESOURCE (usage_iresource_get_type ())
#define USAGE_IRESOURCE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), USAGE_TYPE_IRESOURCE, UsageIResource))
#define USAGE_IS_IRESOURCE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), USAGE_TYPE_IRESOURCE))
#define USAGE_IRESOURCE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), USAGE_TYPE_IRESOURCE, UsageIResourceIface))

typedef struct _UsageIResource UsageIResource;
typedef struct _UsageIResourceIface UsageIResourceIface;
typedef struct _UsageResourcePrivate UsageResourcePrivate;
#define _usage_resource_command_unref0(var) ((var == NULL) ? NULL : (var = (usage_resource_command_unref (var), NULL)))
typedef struct _UsageResourceCommandEnqueueData UsageResourceCommandEnqueueData;
typedef struct _UsageParamSpecResourceCommand UsageParamSpecResourceCommand;

#define USAGE_TYPE_SYSTEM_COMMAND (usage_system_command_get_type ())
#define USAGE_SYSTEM_COMMAND(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), USAGE_TYPE_SYSTEM_COMMAND, UsageSystemCommand))
#define USAGE_SYSTEM_COMMAND_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), USAGE_TYPE_SYSTEM_COMMAND, UsageSystemCommandClass))
#define USAGE_IS_SYSTEM_COMMAND(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), USAGE_TYPE_SYSTEM_COMMAND))
#define USAGE_IS_SYSTEM_COMMAND_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), USAGE_TYPE_SYSTEM_COMMAND))
#define USAGE_SYSTEM_COMMAND_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), USAGE_TYPE_SYSTEM_COMMAND, UsageSystemCommandClass))

typedef struct _UsageSystemCommand UsageSystemCommand;
typedef struct _UsageSystemCommandClass UsageSystemCommandClass;
typedef struct _UsageSystemCommandPrivate UsageSystemCommandPrivate;
#define _usage_system_command_unref0(var) ((var == NULL) ? NULL : (var = (usage_system_command_unref (var), NULL)))
typedef struct _UsageSystemCommandEnqueueData UsageSystemCommandEnqueueData;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _UsageParamSpecSystemCommand UsageParamSpecSystemCommand;

#define USAGE_TYPE_REQUEST_RESOURCE (usage_request_resource_get_type ())
#define USAGE_REQUEST_RESOURCE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), USAGE_TYPE_REQUEST_RESOURCE, UsageRequestResource))
#define USAGE_REQUEST_RESOURCE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), USAGE_TYPE_REQUEST_RESOURCE, UsageRequestResourceClass))
#define USAGE_IS_REQUEST_RESOURCE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), USAGE_TYPE_REQUEST_RESOURCE))
#define USAGE_IS_REQUEST_RESOURCE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), USAGE_TYPE_REQUEST_RESOURCE))
#define USAGE_REQUEST_RESOURCE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), USAGE_TYPE_REQUEST_RESOURCE, UsageRequestResourceClass))

typedef struct _UsageRequestResource UsageRequestResource;
typedef struct _UsageRequestResourceClass UsageRequestResourceClass;
typedef struct _UsageRequestResourcePrivate UsageRequestResourcePrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _UsageRequestResourceRunData UsageRequestResourceRunData;

#define USAGE_TYPE_RELEASE_RESOURCE (usage_release_resource_get_type ())
#define USAGE_RELEASE_RESOURCE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), USAGE_TYPE_RELEASE_RESOURCE, UsageReleaseResource))
#define USAGE_RELEASE_RESOURCE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), USAGE_TYPE_RELEASE_RESOURCE, UsageReleaseResourceClass))
#define USAGE_IS_RELEASE_RESOURCE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), USAGE_TYPE_RELEASE_RESOURCE))
#define USAGE_IS_RELEASE_RESOURCE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), USAGE_TYPE_RELEASE_RESOURCE))
#define USAGE_RELEASE_RESOURCE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), USAGE_TYPE_RELEASE_RESOURCE, UsageReleaseResourceClass))

typedef struct _UsageReleaseResource UsageReleaseResource;
typedef struct _UsageReleaseResourceClass UsageReleaseResourceClass;
typedef struct _UsageReleaseResourcePrivate UsageReleaseResourcePrivate;
typedef struct _UsageReleaseResourceRunData UsageReleaseResourceRunData;

#define USAGE_TYPE_SET_RESOURCE_POLICY (usage_set_resource_policy_get_type ())
#define USAGE_SET_RESOURCE_POLICY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), USAGE_TYPE_SET_RESOURCE_POLICY, UsageSetResourcePolicy))
#define USAGE_SET_RESOURCE_POLICY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), USAGE_TYPE_SET_RESOURCE_POLICY, UsageSetResourcePolicyClass))
#define USAGE_IS_SET_RESOURCE_POLICY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), USAGE_TYPE_SET_RESOURCE_POLICY))
#define USAGE_IS_SET_RESOURCE_POLICY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), USAGE_TYPE_SET_RESOURCE_POLICY))
#define USAGE_SET_RESOURCE_POLICY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), USAGE_TYPE_SET_RESOURCE_POLICY, UsageSetResourcePolicyClass))

typedef struct _UsageSetResourcePolicy UsageSetResourcePolicy;
typedef struct _UsageSetResourcePolicyClass UsageSetResourcePolicyClass;
typedef struct _UsageSetResourcePolicyPrivate UsageSetResourcePolicyPrivate;
typedef struct _UsageSetResourcePolicyRunData UsageSetResourcePolicyRunData;

#define USAGE_TYPE_GET_RESOURCE_POLICY (usage_get_resource_policy_get_type ())
#define USAGE_GET_RESOURCE_POLICY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), USAGE_TYPE_GET_RESOURCE_POLICY, UsageGetResourcePolicy))
#define USAGE_GET_RESOURCE_POLICY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), USAGE_TYPE_GET_RESOURCE_POLICY, UsageGetResourcePolicyClass))
#define USAGE_IS_GET_RESOURCE_POLICY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), USAGE_TYPE_GET_RESOURCE_POLICY))
#define USAGE_IS_GET_RESOURCE_POLICY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), USAGE_TYPE_GET_RESOURCE_POLICY))
#define USAGE_GET_RESOURCE_POLICY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), USAGE_TYPE_GET_RESOURCE_POLICY, UsageGetResourcePolicyClass))

typedef struct _UsageGetResourcePolicy UsageGetResourcePolicy;
typedef struct _UsageGetResourcePolicyClass UsageGetResourcePolicyClass;
typedef struct _UsageGetResourcePolicyPrivate UsageGetResourcePolicyPrivate;
typedef struct _UsageGetResourcePolicyRunData UsageGetResourcePolicyRunData;

#define USAGE_TYPE_SUSPEND (usage_suspend_get_type ())
#define USAGE_SUSPEND(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), USAGE_TYPE_SUSPEND, UsageSuspend))
#define USAGE_SUSPEND_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), USAGE_TYPE_SUSPEND, UsageSuspendClass))
#define USAGE_IS_SUSPEND(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), USAGE_TYPE_SUSPEND))
#define USAGE_IS_SUSPEND_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), USAGE_TYPE_SUSPEND))
#define USAGE_SUSPEND_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), USAGE_TYPE_SUSPEND, UsageSuspendClass))

typedef struct _UsageSuspend UsageSuspend;
typedef struct _UsageSuspendClass UsageSuspendClass;
typedef struct _UsageSuspendPrivate UsageSuspendPrivate;

#define USAGE_TYPE_CONTROLLER (usage_controller_get_type ())
#define USAGE_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), USAGE_TYPE_CONTROLLER, UsageController))
#define USAGE_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), USAGE_TYPE_CONTROLLER, UsageControllerClass))
#define USAGE_IS_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), USAGE_TYPE_CONTROLLER))
#define USAGE_IS_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), USAGE_TYPE_CONTROLLER))
#define USAGE_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), USAGE_TYPE_CONTROLLER, UsageControllerClass))

typedef struct _UsageController UsageController;
typedef struct _UsageControllerClass UsageControllerClass;
typedef struct _UsageSuspendRunData UsageSuspendRunData;

#define USAGE_TYPE_SHUTDOWN (usage_shutdown_get_type ())
#define USAGE_SHUTDOWN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), USAGE_TYPE_SHUTDOWN, UsageShutdown))
#define USAGE_SHUTDOWN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), USAGE_TYPE_SHUTDOWN, UsageShutdownClass))
#define USAGE_IS_SHUTDOWN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), USAGE_TYPE_SHUTDOWN))
#define USAGE_IS_SHUTDOWN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), USAGE_TYPE_SHUTDOWN))
#define USAGE_SHUTDOWN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), USAGE_TYPE_SHUTDOWN, UsageShutdownClass))

typedef struct _UsageShutdown UsageShutdown;
typedef struct _UsageShutdownClass UsageShutdownClass;
typedef struct _UsageShutdownPrivate UsageShutdownPrivate;
typedef struct _UsageShutdownRunData UsageShutdownRunData;

#define USAGE_TYPE_REBOOT (usage_reboot_get_type ())
#define USAGE_REBOOT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), USAGE_TYPE_REBOOT, UsageReboot))
#define USAGE_REBOOT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), USAGE_TYPE_REBOOT, UsageRebootClass))
#define USAGE_IS_REBOOT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), USAGE_TYPE_REBOOT))
#define USAGE_IS_REBOOT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), USAGE_TYPE_REBOOT))
#define USAGE_REBOOT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), USAGE_TYPE_REBOOT, UsageRebootClass))

typedef struct _UsageReboot UsageReboot;
typedef struct _UsageRebootClass UsageRebootClass;
typedef struct _UsageRebootPrivate UsageRebootPrivate;
typedef struct _UsageRebootRunData UsageRebootRunData;

#define USAGE_TYPE_RESUME (usage_resume_get_type ())
#define USAGE_RESUME(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), USAGE_TYPE_RESUME, UsageResume))
#define USAGE_RESUME_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), USAGE_TYPE_RESUME, UsageResumeClass))
#define USAGE_IS_RESUME(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), USAGE_TYPE_RESUME))
#define USAGE_IS_RESUME_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), USAGE_TYPE_RESUME))
#define USAGE_RESUME_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), USAGE_TYPE_RESUME, UsageResumeClass))

typedef struct _UsageResume UsageResume;
typedef struct _UsageResumeClass UsageResumeClass;
typedef struct _UsageResumePrivate UsageResumePrivate;
typedef struct _UsageResumeRunData UsageResumeRunData;

struct _UsageResourceCommand {
	GTypeInstance parent_instance;
	volatile int ref_count;
	UsageResourceCommandPrivate * priv;
	UsageResource* r;
};

struct _UsageResourceCommandClass {
	GTypeClass parent_class;
	void (*finalize) (UsageResourceCommand *self);
};

struct _UsageResourceCommandPrivate {
	GSourceFunc callback;
	gpointer callback_target;
	GDestroyNotify callback_target_destroy_notify;
};

struct _UsageIResourceIface {
	GTypeInterface parent_iface;
	void (*setPolicy) (UsageIResource* self, FreeSmartphoneUsageResourcePolicy policy, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*setPolicy_finish) (UsageIResource* self, GAsyncResult* _res_, GError** error);
	void (*enable) (UsageIResource* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*enable_finish) (UsageIResource* self, GAsyncResult* _res_, GError** error);
	void (*disable) (UsageIResource* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*disable_finish) (UsageIResource* self, GAsyncResult* _res_, GError** error);
	void (*suspend) (UsageIResource* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*suspend_finish) (UsageIResource* self, GAsyncResult* _res_, GError** error);
	void (*resume) (UsageIResource* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*resume_finish) (UsageIResource* self, GAsyncResult* _res_, GError** error);
};

struct _UsageResource {
	GObject parent_instance;
	UsageResourcePrivate * priv;
	FreeSmartphoneResource* proxy;
	GeeLinkedList* q;
};

struct _UsageResourceClass {
	GObjectClass parent_class;
	void (*setPolicy) (UsageResource* self, FreeSmartphoneUsageResourcePolicy policy, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*setPolicy_finish) (UsageResource* self, GAsyncResult* _res_, GError** error);
	void (*enableShadowResource) (UsageResource* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*enableShadowResource_finish) (UsageResource* self, GAsyncResult* _res_, GError** error);
	void (*enable) (UsageResource* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*enable_finish) (UsageResource* self, GAsyncResult* _res_, GError** error);
	void (*disable) (UsageResource* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*disable_finish) (UsageResource* self, GAsyncResult* _res_, GError** error);
	void (*suspend) (UsageResource* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*suspend_finish) (UsageResource* self, GAsyncResult* _res_, GError** error);
	void (*resume) (UsageResource* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*resume_finish) (UsageResource* self, GAsyncResult* _res_, GError** error);
};

struct _UsageResourceCommandEnqueueData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	UsageResourceCommand* self;
	UsageResource* _tmp0_;
	UsageResource* _tmp1_;
	GeeLinkedList* _tmp2_;
	gboolean _tmp3_;
	gboolean _tmp4_;
	gboolean wasempty;
	UsageResource* _tmp5_;
	GeeLinkedList* _tmp6_;
	gboolean _tmp7_;
};

struct _UsageParamSpecResourceCommand {
	GParamSpec parent_instance;
};

struct _UsageSystemCommand {
	GTypeInstance parent_instance;
	volatile int ref_count;
	UsageSystemCommandPrivate * priv;
};

struct _UsageSystemCommandClass {
	GTypeClass parent_class;
	void (*finalize) (UsageSystemCommand *self);
};

struct _UsageSystemCommandPrivate {
	GSourceFunc callback;
	gpointer callback_target;
	GDestroyNotify callback_target_destroy_notify;
};

struct _UsageSystemCommandEnqueueData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	UsageSystemCommand* self;
	GeeLinkedList* _tmp0_;
	gboolean _tmp1_;
	gboolean _tmp2_;
	gboolean wasempty;
	GeeLinkedList* _tmp3_;
	gboolean _tmp4_;
};

struct _UsageParamSpecSystemCommand {
	GParamSpec parent_instance;
};

struct _UsageRequestResource {
	UsageResourceCommand parent_instance;
	UsageRequestResourcePrivate * priv;
};

struct _UsageRequestResourceClass {
	UsageResourceCommandClass parent_class;
};

struct _UsageRequestResourceRunData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	UsageRequestResource* self;
	char* user;
	UsageResource* _tmp0_;
	const char* _tmp1_;
	GError * _inner_error_;
};

struct _UsageReleaseResource {
	UsageResourceCommand parent_instance;
	UsageReleaseResourcePrivate * priv;
};

struct _UsageReleaseResourceClass {
	UsageResourceCommandClass parent_class;
};

struct _UsageReleaseResourceRunData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	UsageReleaseResource* self;
	char* user;
	UsageResource* _tmp0_;
	const char* _tmp1_;
	GError * _inner_error_;
};

struct _UsageSetResourcePolicy {
	UsageResourceCommand parent_instance;
	UsageSetResourcePolicyPrivate * priv;
};

struct _UsageSetResourcePolicyClass {
	UsageResourceCommandClass parent_class;
};

struct _UsageSetResourcePolicyRunData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	UsageSetResourcePolicy* self;
	gchar* policy;
};

struct _UsageGetResourcePolicy {
	UsageResourceCommand parent_instance;
	UsageGetResourcePolicyPrivate * priv;
};

struct _UsageGetResourcePolicyClass {
	UsageResourceCommandClass parent_class;
};

struct _UsageGetResourcePolicyRunData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	UsageGetResourcePolicy* self;
};

struct _UsageSuspend {
	UsageSystemCommand parent_instance;
	UsageSuspendPrivate * priv;
};

struct _UsageSuspendClass {
	UsageSystemCommandClass parent_class;
};

struct _UsageSuspendRunData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	UsageSuspend* self;
	UsageController* _tmp0_;
	UsageController* _tmp1_;
	UsageController* _tmp2_;
};

struct _UsageShutdown {
	UsageSystemCommand parent_instance;
	UsageShutdownPrivate * priv;
};

struct _UsageShutdownClass {
	UsageSystemCommandClass parent_class;
};

struct _UsageShutdownRunData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	UsageShutdown* self;
	UsageController* _tmp0_;
	UsageController* _tmp1_;
};

struct _UsageReboot {
	UsageSystemCommand parent_instance;
	UsageRebootPrivate * priv;
};

struct _UsageRebootClass {
	UsageSystemCommandClass parent_class;
};

struct _UsageRebootRunData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	UsageReboot* self;
	UsageController* _tmp0_;
	UsageController* _tmp1_;
};

struct _UsageResume {
	UsageSystemCommand parent_instance;
	UsageResumePrivate * priv;
};

struct _UsageResumeClass {
	UsageSystemCommandClass parent_class;
};

struct _UsageResumeRunData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	UsageResume* self;
	UsageController* _tmp0_;
	UsageController* _tmp1_;
};


static gpointer usage_resource_command_parent_class = NULL;
static GType usage_resource_command_type_id = 0;
static gpointer usage_system_command_parent_class = NULL;
static GeeLinkedList* usage_system_command_q;
static GeeLinkedList* usage_system_command_q = NULL;
static GType usage_system_command_type_id = 0;
static gpointer usage_request_resource_parent_class = NULL;
static GType usage_request_resource_type_id = 0;
static gpointer usage_release_resource_parent_class = NULL;
static GType usage_release_resource_type_id = 0;
static gpointer usage_set_resource_policy_parent_class = NULL;
static GType usage_set_resource_policy_type_id = 0;
static gpointer usage_get_resource_policy_parent_class = NULL;
static GType usage_get_resource_policy_type_id = 0;
static gpointer usage_suspend_parent_class = NULL;
extern UsageController* usage_instance;
static GType usage_suspend_type_id = 0;
static gpointer usage_shutdown_parent_class = NULL;
static GType usage_shutdown_type_id = 0;
static gpointer usage_reboot_parent_class = NULL;
static GType usage_reboot_type_id = 0;
static gpointer usage_resume_parent_class = NULL;
static GType usage_resume_type_id = 0;

gpointer usage_resource_command_ref (gpointer instance);
void usage_resource_command_unref (gpointer instance);
GParamSpec* usage_param_spec_resource_command (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void usage_value_set_resource_command (GValue* value, gpointer v_object);
void usage_value_take_resource_command (GValue* value, gpointer v_object);
gpointer usage_value_get_resource_command (const GValue* value);
GType usage_resource_command_get_type (void) G_GNUC_CONST;
GType usage_resource_command_register_type (GTypeModule * module);
GType usage_resource_get_type (void) G_GNUC_CONST;
GType usage_resource_register_type (GTypeModule * module);
#define USAGE_RESOURCE_COMMAND_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), USAGE_TYPE_RESOURCE_COMMAND, UsageResourceCommandPrivate))
enum  {
	USAGE_RESOURCE_COMMAND_DUMMY_PROPERTY
};
void usage_resource_command_dequeue (UsageResourceCommand* self);
UsageResourceCommand* usage_resource_command_new (UsageResource* r);
UsageResourceCommand* usage_resource_command_construct (GType object_type, UsageResource* r);
GType usage_iresource_get_type (void) G_GNUC_CONST;
GType usage_iresource_register_type (GTypeModule * module);
static void usage_resource_command_enqueue_data_free (gpointer _data);
void usage_resource_command_enqueue (UsageResourceCommand* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void usage_resource_command_enqueue_finish (UsageResourceCommand* self, GAsyncResult* _res_);
static gboolean usage_resource_command_enqueue_co (UsageResourceCommandEnqueueData* _data_);
static gboolean _usage_resource_command_enqueue_co_gsource_func (gpointer self);
static void usage_resource_command_finalize (UsageResourceCommand* obj);
gpointer usage_system_command_ref (gpointer instance);
void usage_system_command_unref (gpointer instance);
GParamSpec* usage_param_spec_system_command (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void usage_value_set_system_command (GValue* value, gpointer v_object);
void usage_value_take_system_command (GValue* value, gpointer v_object);
gpointer usage_value_get_system_command (const GValue* value);
GType usage_system_command_get_type (void) G_GNUC_CONST;
GType usage_system_command_register_type (GTypeModule * module);
#define USAGE_SYSTEM_COMMAND_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), USAGE_TYPE_SYSTEM_COMMAND, UsageSystemCommandPrivate))
enum  {
	USAGE_SYSTEM_COMMAND_DUMMY_PROPERTY
};
void usage_system_command_dequeue (UsageSystemCommand* self);
UsageSystemCommand* usage_system_command_new (void);
UsageSystemCommand* usage_system_command_construct (GType object_type);
static void usage_system_command_enqueue_data_free (gpointer _data);
void usage_system_command_enqueue (UsageSystemCommand* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void usage_system_command_enqueue_finish (UsageSystemCommand* self, GAsyncResult* _res_);
static gboolean usage_system_command_enqueue_co (UsageSystemCommandEnqueueData* _data_);
static gboolean _usage_system_command_enqueue_co_gsource_func (gpointer self);
static void usage_system_command_finalize (UsageSystemCommand* obj);
GType usage_request_resource_get_type (void) G_GNUC_CONST;
GType usage_request_resource_register_type (GTypeModule * module);
enum  {
	USAGE_REQUEST_RESOURCE_DUMMY_PROPERTY
};
UsageRequestResource* usage_request_resource_new (UsageResource* r);
UsageRequestResource* usage_request_resource_construct (GType object_type, UsageResource* r);
static void usage_request_resource_run_data_free (gpointer _data);
void usage_request_resource_run (UsageRequestResource* self, const char* user, GAsyncReadyCallback _callback_, gpointer _user_data_);
void usage_request_resource_run_finish (UsageRequestResource* self, GAsyncResult* _res_, GError** error);
static gboolean usage_request_resource_run_co (UsageRequestResourceRunData* _data_);
static void usage_request_resource_run_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
void usage_resource_addUser (UsageResource* self, const gchar* user, GAsyncReadyCallback _callback_, gpointer _user_data_);
void usage_resource_addUser_finish (UsageResource* self, GAsyncResult* _res_, GError** error);
GType usage_release_resource_get_type (void) G_GNUC_CONST;
GType usage_release_resource_register_type (GTypeModule * module);
enum  {
	USAGE_RELEASE_RESOURCE_DUMMY_PROPERTY
};
UsageReleaseResource* usage_release_resource_new (UsageResource* r);
UsageReleaseResource* usage_release_resource_construct (GType object_type, UsageResource* r);
static void usage_release_resource_run_data_free (gpointer _data);
void usage_release_resource_run (UsageReleaseResource* self, const char* user, GAsyncReadyCallback _callback_, gpointer _user_data_);
void usage_release_resource_run_finish (UsageReleaseResource* self, GAsyncResult* _res_, GError** error);
static gboolean usage_release_resource_run_co (UsageReleaseResourceRunData* _data_);
static void usage_release_resource_run_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
void usage_resource_delUser (UsageResource* self, const gchar* user, GAsyncReadyCallback _callback_, gpointer _user_data_);
void usage_resource_delUser_finish (UsageResource* self, GAsyncResult* _res_, GError** error);
GType usage_set_resource_policy_get_type (void) G_GNUC_CONST;
GType usage_set_resource_policy_register_type (GTypeModule * module);
enum  {
	USAGE_SET_RESOURCE_POLICY_DUMMY_PROPERTY
};
UsageSetResourcePolicy* usage_set_resource_policy_new (UsageResource* r);
UsageSetResourcePolicy* usage_set_resource_policy_construct (GType object_type, UsageResource* r);
static void usage_set_resource_policy_run_data_free (gpointer _data);
void usage_set_resource_policy_run (UsageSetResourcePolicy* self, const gchar* policy, GAsyncReadyCallback _callback_, gpointer _user_data_);
void usage_set_resource_policy_run_finish (UsageSetResourcePolicy* self, GAsyncResult* _res_, GError** error);
static gboolean usage_set_resource_policy_run_co (UsageSetResourcePolicyRunData* _data_);
GType usage_get_resource_policy_get_type (void) G_GNUC_CONST;
GType usage_get_resource_policy_register_type (GTypeModule * module);
enum  {
	USAGE_GET_RESOURCE_POLICY_DUMMY_PROPERTY
};
UsageGetResourcePolicy* usage_get_resource_policy_new (UsageResource* r);
UsageGetResourcePolicy* usage_get_resource_policy_construct (GType object_type, UsageResource* r);
static void usage_get_resource_policy_run_data_free (gpointer _data);
void usage_get_resource_policy_run (UsageGetResourcePolicy* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void usage_get_resource_policy_run_finish (UsageGetResourcePolicy* self, GAsyncResult* _res_, GError** error);
static gboolean usage_get_resource_policy_run_co (UsageGetResourcePolicyRunData* _data_);
GType usage_suspend_get_type (void) G_GNUC_CONST;
GType usage_suspend_register_type (GTypeModule * module);
enum  {
	USAGE_SUSPEND_DUMMY_PROPERTY
};
static void usage_suspend_run_data_free (gpointer _data);
void usage_suspend_run (UsageSuspend* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void usage_suspend_run_finish (UsageSuspend* self, GAsyncResult* _res_, GError** error);
static gboolean usage_suspend_run_co (UsageSuspendRunData* _data_);
static void usage_suspend_run_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
GType usage_controller_get_type (void) G_GNUC_CONST;
GType usage_controller_register_type (GTypeModule * module);
guint usage_controller_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
void usage_controller_updateSystemStatus (UsageController* self, FreeSmartphoneUsageSystemAction action);
void usage_controller_suspendAllResources (UsageController* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void usage_controller_suspendAllResources_finish (UsageController* self, GAsyncResult* _res_);
gboolean usage_controller_onIdleForSuspend (UsageController* self);
static gboolean _usage_controller_onIdleForSuspend_gsource_func (gpointer self);
UsageSuspend* usage_suspend_new (void);
UsageSuspend* usage_suspend_construct (GType object_type);
GType usage_shutdown_get_type (void) G_GNUC_CONST;
GType usage_shutdown_register_type (GTypeModule * module);
enum  {
	USAGE_SHUTDOWN_DUMMY_PROPERTY
};
static void usage_shutdown_run_data_free (gpointer _data);
void usage_shutdown_run (UsageShutdown* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void usage_shutdown_run_finish (UsageShutdown* self, GAsyncResult* _res_, GError** error);
static gboolean usage_shutdown_run_co (UsageShutdownRunData* _data_);
static void usage_shutdown_run_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
void usage_controller_disableAllResources (UsageController* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void usage_controller_disableAllResources_finish (UsageController* self, GAsyncResult* _res_);
static gboolean __lambda5_ (UsageShutdown* self);
static gboolean ___lambda5__gsource_func (gpointer self);
UsageShutdown* usage_shutdown_new (void);
UsageShutdown* usage_shutdown_construct (GType object_type);
GType usage_reboot_get_type (void) G_GNUC_CONST;
GType usage_reboot_register_type (GTypeModule * module);
enum  {
	USAGE_REBOOT_DUMMY_PROPERTY
};
static void usage_reboot_run_data_free (gpointer _data);
void usage_reboot_run (UsageReboot* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void usage_reboot_run_finish (UsageReboot* self, GAsyncResult* _res_, GError** error);
static gboolean usage_reboot_run_co (UsageRebootRunData* _data_);
static void usage_reboot_run_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static gboolean __lambda6_ (UsageReboot* self);
static gboolean ___lambda6__gsource_func (gpointer self);
UsageReboot* usage_reboot_new (void);
UsageReboot* usage_reboot_construct (GType object_type);
GType usage_resume_get_type (void) G_GNUC_CONST;
GType usage_resume_register_type (GTypeModule * module);
enum  {
	USAGE_RESUME_DUMMY_PROPERTY
};
static void usage_resume_run_data_free (gpointer _data);
void usage_resume_run (UsageResume* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void usage_resume_run_finish (UsageResume* self, GAsyncResult* _res_, GError** error);
static gboolean usage_resume_run_co (UsageResumeRunData* _data_);
static void usage_resume_run_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
gboolean usage_controller_onIdleForResume (UsageController* self);
static gboolean _usage_controller_onIdleForResume_gsource_func (gpointer self);
UsageResume* usage_resume_new (void);
UsageResume* usage_resume_construct (GType object_type);


UsageResourceCommand* usage_resource_command_construct (GType object_type, UsageResource* r) {
	UsageResourceCommand* self = NULL;
	UsageResource* _tmp0_;
	UsageResource* _tmp1_;
	g_return_val_if_fail (r != NULL, NULL);
	self = (UsageResourceCommand*) g_type_create_instance (object_type);
	_tmp0_ = r;
	g_assert (_tmp0_ != NULL);
	_tmp1_ = r;
	self->r = _tmp1_;
	return self;
}


UsageResourceCommand* usage_resource_command_new (UsageResource* r) {
	return usage_resource_command_construct (USAGE_TYPE_RESOURCE_COMMAND, r);
}


void usage_resource_command_dequeue (UsageResourceCommand* self) {
	UsageResource* _tmp0_;
	UsageResource* _tmp1_;
	GeeLinkedList* _tmp2_;
	gpointer _tmp3_ = NULL;
	UsageResource* _tmp4_;
	GeeLinkedList* _tmp5_;
	gboolean _tmp6_;
	gboolean _tmp7_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->r;
	g_assert (_tmp0_ != NULL);
	_tmp1_ = self->r;
	_tmp2_ = _tmp1_->q;
	_tmp3_ = gee_deque_poll_head ((GeeDeque*) _tmp2_);
	g_assert (((UsageResourceCommand*) _tmp3_) == self);
	_tmp4_ = self->r;
	_tmp5_ = _tmp4_->q;
	_tmp6_ = gee_abstract_collection_get_is_empty ((GeeAbstractCollection*) _tmp5_);
	_tmp7_ = _tmp6_;
	if (!_tmp7_) {
		UsageResource* _tmp8_;
		GeeLinkedList* _tmp9_;
		gpointer _tmp10_ = NULL;
		GSourceFunc _tmp11_;
		void* _tmp11__target;
		_tmp8_ = self->r;
		_tmp9_ = _tmp8_->q;
		_tmp10_ = gee_deque_peek_head ((GeeDeque*) _tmp9_);
		_tmp11_ = ((UsageResourceCommand*) _tmp10_)->priv->callback;
		_tmp11__target = ((UsageResourceCommand*) _tmp10_)->priv->callback_target;
		_tmp11_ (_tmp11__target);
	}
}


static void usage_resource_command_enqueue_data_free (gpointer _data) {
	UsageResourceCommandEnqueueData* _data_;
	_data_ = _data;
	_usage_resource_command_unref0 (_data_->self);
	g_slice_free (UsageResourceCommandEnqueueData, _data_);
}


static gpointer _usage_resource_command_ref0 (gpointer self) {
	return self ? usage_resource_command_ref (self) : NULL;
}


void usage_resource_command_enqueue (UsageResourceCommand* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	UsageResourceCommandEnqueueData* _data_;
	UsageResourceCommand* _tmp0_;
	_data_ = g_slice_new0 (UsageResourceCommandEnqueueData);
	_data_->_async_result = g_simple_async_result_new (g_object_newv (G_TYPE_OBJECT, 0, NULL), _callback_, _user_data_, usage_resource_command_enqueue);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, usage_resource_command_enqueue_data_free);
	_tmp0_ = _usage_resource_command_ref0 (self);
	_data_->self = _tmp0_;
	usage_resource_command_enqueue_co (_data_);
}


void usage_resource_command_enqueue_finish (UsageResourceCommand* self, GAsyncResult* _res_) {
	UsageResourceCommandEnqueueData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static gboolean _usage_resource_command_enqueue_co_gsource_func (gpointer self) {
	gboolean result;
	result = usage_resource_command_enqueue_co (self);
	return result;
}


static gboolean usage_resource_command_enqueue_co (UsageResourceCommandEnqueueData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = _data_->self->r;
	g_assert (_data_->_tmp0_ != NULL);
	_data_->_tmp1_ = _data_->self->r;
	_data_->_tmp2_ = _data_->_tmp1_->q;
	_data_->_tmp3_ = gee_abstract_collection_get_is_empty ((GeeAbstractCollection*) _data_->_tmp2_);
	_data_->_tmp4_ = _data_->_tmp3_;
	_data_->wasempty = _data_->_tmp4_;
	(_data_->self->priv->callback_target_destroy_notify == NULL) ? NULL : (_data_->self->priv->callback_target_destroy_notify (_data_->self->priv->callback_target), NULL);
	_data_->self->priv->callback = NULL;
	_data_->self->priv->callback_target = NULL;
	_data_->self->priv->callback_target_destroy_notify = NULL;
	_data_->self->priv->callback = _usage_resource_command_enqueue_co_gsource_func;
	_data_->self->priv->callback_target = _data_;
	_data_->self->priv->callback_target_destroy_notify = NULL;
	_data_->_tmp5_ = _data_->self->r;
	_data_->_tmp6_ = _data_->_tmp5_->q;
	gee_deque_offer_tail ((GeeDeque*) _data_->_tmp6_, _data_->self);
	_data_->_tmp7_ = _data_->wasempty;
	if (_data_->_tmp7_) {
		if (_data_->_state_ == 0) {
			g_simple_async_result_complete_in_idle (_data_->_async_result);
		} else {
			g_simple_async_result_complete (_data_->_async_result);
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	} else {
		_data_->_state_ = 1;
		return FALSE;
		_state_1:
		;
	}
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void usage_value_resource_command_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void usage_value_resource_command_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		usage_resource_command_unref (value->data[0].v_pointer);
	}
}


static void usage_value_resource_command_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = usage_resource_command_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer usage_value_resource_command_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* usage_value_resource_command_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		UsageResourceCommand* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = usage_resource_command_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* usage_value_resource_command_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	UsageResourceCommand** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = usage_resource_command_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* usage_param_spec_resource_command (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	UsageParamSpecResourceCommand* spec;
	g_return_val_if_fail (g_type_is_a (object_type, USAGE_TYPE_RESOURCE_COMMAND), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer usage_value_get_resource_command (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, USAGE_TYPE_RESOURCE_COMMAND), NULL);
	return value->data[0].v_pointer;
}


void usage_value_set_resource_command (GValue* value, gpointer v_object) {
	UsageResourceCommand* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, USAGE_TYPE_RESOURCE_COMMAND));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, USAGE_TYPE_RESOURCE_COMMAND));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		usage_resource_command_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		usage_resource_command_unref (old);
	}
}


void usage_value_take_resource_command (GValue* value, gpointer v_object) {
	UsageResourceCommand* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, USAGE_TYPE_RESOURCE_COMMAND));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, USAGE_TYPE_RESOURCE_COMMAND));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		usage_resource_command_unref (old);
	}
}


static void usage_resource_command_class_init (UsageResourceCommandClass * klass) {
	usage_resource_command_parent_class = g_type_class_peek_parent (klass);
	USAGE_RESOURCE_COMMAND_CLASS (klass)->finalize = usage_resource_command_finalize;
	g_type_class_add_private (klass, sizeof (UsageResourceCommandPrivate));
}


static void usage_resource_command_instance_init (UsageResourceCommand * self) {
	self->priv = USAGE_RESOURCE_COMMAND_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void usage_resource_command_finalize (UsageResourceCommand* obj) {
	UsageResourceCommand * self;
	self = USAGE_RESOURCE_COMMAND (obj);
	usage_resource_command_dequeue (self);
	(self->priv->callback_target_destroy_notify == NULL) ? NULL : (self->priv->callback_target_destroy_notify (self->priv->callback_target), NULL);
	self->priv->callback = NULL;
	self->priv->callback_target = NULL;
	self->priv->callback_target_destroy_notify = NULL;
}


/**
 * @class ResourceCommand
 *
 * Performs the serialization of resource commands
 **/
GType usage_resource_command_get_type (void) {
	return usage_resource_command_type_id;
}


GType usage_resource_command_register_type (GTypeModule * module) {
	static const GTypeValueTable g_define_type_value_table = { usage_value_resource_command_init, usage_value_resource_command_free_value, usage_value_resource_command_copy_value, usage_value_resource_command_peek_pointer, "p", usage_value_resource_command_collect_value, "p", usage_value_resource_command_lcopy_value };
	static const GTypeInfo g_define_type_info = { sizeof (UsageResourceCommandClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) usage_resource_command_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UsageResourceCommand), 0, (GInstanceInitFunc) usage_resource_command_instance_init, &g_define_type_value_table };
	static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
	usage_resource_command_type_id = g_type_register_fundamental (g_type_fundamental_next (), "UsageResourceCommand", &g_define_type_info, &g_define_type_fundamental_info, 0);
	return usage_resource_command_type_id;
}


gpointer usage_resource_command_ref (gpointer instance) {
	UsageResourceCommand* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void usage_resource_command_unref (gpointer instance) {
	UsageResourceCommand* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		USAGE_RESOURCE_COMMAND_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


UsageSystemCommand* usage_system_command_construct (GType object_type) {
	UsageSystemCommand* self = NULL;
	self = (UsageSystemCommand*) g_type_create_instance (object_type);
	return self;
}


UsageSystemCommand* usage_system_command_new (void) {
	return usage_system_command_construct (USAGE_TYPE_SYSTEM_COMMAND);
}


void usage_system_command_dequeue (UsageSystemCommand* self) {
	GeeLinkedList* _tmp0_;
	gpointer _tmp1_ = NULL;
	GeeLinkedList* _tmp2_;
	gboolean _tmp3_;
	gboolean _tmp4_;
	g_return_if_fail (self != NULL);
	_tmp0_ = usage_system_command_q;
	_tmp1_ = gee_deque_poll_head ((GeeDeque*) _tmp0_);
	g_assert (((UsageSystemCommand*) _tmp1_) == self);
	_tmp2_ = usage_system_command_q;
	_tmp3_ = gee_abstract_collection_get_is_empty ((GeeAbstractCollection*) _tmp2_);
	_tmp4_ = _tmp3_;
	if (!_tmp4_) {
		GeeLinkedList* _tmp5_;
		gpointer _tmp6_ = NULL;
		GSourceFunc _tmp7_;
		void* _tmp7__target;
		_tmp5_ = usage_system_command_q;
		_tmp6_ = gee_deque_peek_head ((GeeDeque*) _tmp5_);
		_tmp7_ = ((UsageSystemCommand*) _tmp6_)->priv->callback;
		_tmp7__target = ((UsageSystemCommand*) _tmp6_)->priv->callback_target;
		_tmp7_ (_tmp7__target);
	}
}


static void usage_system_command_enqueue_data_free (gpointer _data) {
	UsageSystemCommandEnqueueData* _data_;
	_data_ = _data;
	_usage_system_command_unref0 (_data_->self);
	g_slice_free (UsageSystemCommandEnqueueData, _data_);
}


static gpointer _usage_system_command_ref0 (gpointer self) {
	return self ? usage_system_command_ref (self) : NULL;
}


void usage_system_command_enqueue (UsageSystemCommand* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	UsageSystemCommandEnqueueData* _data_;
	UsageSystemCommand* _tmp0_;
	_data_ = g_slice_new0 (UsageSystemCommandEnqueueData);
	_data_->_async_result = g_simple_async_result_new (g_object_newv (G_TYPE_OBJECT, 0, NULL), _callback_, _user_data_, usage_system_command_enqueue);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, usage_system_command_enqueue_data_free);
	_tmp0_ = _usage_system_command_ref0 (self);
	_data_->self = _tmp0_;
	usage_system_command_enqueue_co (_data_);
}


void usage_system_command_enqueue_finish (UsageSystemCommand* self, GAsyncResult* _res_) {
	UsageSystemCommandEnqueueData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static gboolean _usage_system_command_enqueue_co_gsource_func (gpointer self) {
	gboolean result;
	result = usage_system_command_enqueue_co (self);
	return result;
}


static gboolean usage_system_command_enqueue_co (UsageSystemCommandEnqueueData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = usage_system_command_q;
	_data_->_tmp1_ = gee_abstract_collection_get_is_empty ((GeeAbstractCollection*) _data_->_tmp0_);
	_data_->_tmp2_ = _data_->_tmp1_;
	_data_->wasempty = _data_->_tmp2_;
	(_data_->self->priv->callback_target_destroy_notify == NULL) ? NULL : (_data_->self->priv->callback_target_destroy_notify (_data_->self->priv->callback_target), NULL);
	_data_->self->priv->callback = NULL;
	_data_->self->priv->callback_target = NULL;
	_data_->self->priv->callback_target_destroy_notify = NULL;
	_data_->self->priv->callback = _usage_system_command_enqueue_co_gsource_func;
	_data_->self->priv->callback_target = _data_;
	_data_->self->priv->callback_target_destroy_notify = NULL;
	_data_->_tmp3_ = usage_system_command_q;
	gee_deque_offer_tail ((GeeDeque*) _data_->_tmp3_, _data_->self);
	_data_->_tmp4_ = _data_->wasempty;
	if (_data_->_tmp4_) {
		if (_data_->_state_ == 0) {
			g_simple_async_result_complete_in_idle (_data_->_async_result);
		} else {
			g_simple_async_result_complete (_data_->_async_result);
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	} else {
		_data_->_state_ = 1;
		return FALSE;
		_state_1:
		;
	}
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void usage_value_system_command_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void usage_value_system_command_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		usage_system_command_unref (value->data[0].v_pointer);
	}
}


static void usage_value_system_command_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = usage_system_command_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer usage_value_system_command_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* usage_value_system_command_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		UsageSystemCommand* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = usage_system_command_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* usage_value_system_command_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	UsageSystemCommand** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = usage_system_command_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* usage_param_spec_system_command (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	UsageParamSpecSystemCommand* spec;
	g_return_val_if_fail (g_type_is_a (object_type, USAGE_TYPE_SYSTEM_COMMAND), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer usage_value_get_system_command (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, USAGE_TYPE_SYSTEM_COMMAND), NULL);
	return value->data[0].v_pointer;
}


void usage_value_set_system_command (GValue* value, gpointer v_object) {
	UsageSystemCommand* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, USAGE_TYPE_SYSTEM_COMMAND));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, USAGE_TYPE_SYSTEM_COMMAND));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		usage_system_command_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		usage_system_command_unref (old);
	}
}


void usage_value_take_system_command (GValue* value, gpointer v_object) {
	UsageSystemCommand* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, USAGE_TYPE_SYSTEM_COMMAND));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, USAGE_TYPE_SYSTEM_COMMAND));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		usage_system_command_unref (old);
	}
}


static void usage_system_command_class_init (UsageSystemCommandClass * klass) {
	GeeLinkedList* _tmp0_;
	usage_system_command_parent_class = g_type_class_peek_parent (klass);
	USAGE_SYSTEM_COMMAND_CLASS (klass)->finalize = usage_system_command_finalize;
	g_type_class_add_private (klass, sizeof (UsageSystemCommandPrivate));
	_tmp0_ = gee_linked_list_new (USAGE_TYPE_SYSTEM_COMMAND, NULL, NULL, NULL);
	_g_object_unref0 (usage_system_command_q);
	usage_system_command_q = _tmp0_;
}


static void usage_system_command_instance_init (UsageSystemCommand * self) {
	self->priv = USAGE_SYSTEM_COMMAND_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void usage_system_command_finalize (UsageSystemCommand* obj) {
	UsageSystemCommand * self;
	self = USAGE_SYSTEM_COMMAND (obj);
	usage_system_command_dequeue (self);
	(self->priv->callback_target_destroy_notify == NULL) ? NULL : (self->priv->callback_target_destroy_notify (self->priv->callback_target), NULL);
	self->priv->callback = NULL;
	self->priv->callback_target = NULL;
	self->priv->callback_target_destroy_notify = NULL;
}


/**
 * @class SystemCommand
 *
 * Performs the serialization of system commands
 **/
GType usage_system_command_get_type (void) {
	return usage_system_command_type_id;
}


GType usage_system_command_register_type (GTypeModule * module) {
	static const GTypeValueTable g_define_type_value_table = { usage_value_system_command_init, usage_value_system_command_free_value, usage_value_system_command_copy_value, usage_value_system_command_peek_pointer, "p", usage_value_system_command_collect_value, "p", usage_value_system_command_lcopy_value };
	static const GTypeInfo g_define_type_info = { sizeof (UsageSystemCommandClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) usage_system_command_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UsageSystemCommand), 0, (GInstanceInitFunc) usage_system_command_instance_init, &g_define_type_value_table };
	static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
	usage_system_command_type_id = g_type_register_fundamental (g_type_fundamental_next (), "UsageSystemCommand", &g_define_type_info, &g_define_type_fundamental_info, 0);
	return usage_system_command_type_id;
}


gpointer usage_system_command_ref (gpointer instance) {
	UsageSystemCommand* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void usage_system_command_unref (gpointer instance) {
	UsageSystemCommand* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		USAGE_SYSTEM_COMMAND_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


UsageRequestResource* usage_request_resource_construct (GType object_type, UsageResource* r) {
	UsageRequestResource* self = NULL;
	UsageResource* _tmp0_;
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = r;
	self = (UsageRequestResource*) usage_resource_command_construct (object_type, _tmp0_);
	return self;
}


UsageRequestResource* usage_request_resource_new (UsageResource* r) {
	return usage_request_resource_construct (USAGE_TYPE_REQUEST_RESOURCE, r);
}


static void usage_request_resource_run_data_free (gpointer _data) {
	UsageRequestResourceRunData* _data_;
	_data_ = _data;
	_g_free0 (_data_->user);
	_usage_resource_command_unref0 (_data_->self);
	g_slice_free (UsageRequestResourceRunData, _data_);
}


void usage_request_resource_run (UsageRequestResource* self, const char* user, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	UsageRequestResourceRunData* _data_;
	UsageRequestResource* _tmp0_;
	const char* _tmp1_;
	char* _tmp2_;
	_data_ = g_slice_new0 (UsageRequestResourceRunData);
	_data_->_async_result = g_simple_async_result_new (g_object_newv (G_TYPE_OBJECT, 0, NULL), _callback_, _user_data_, usage_request_resource_run);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, usage_request_resource_run_data_free);
	_tmp0_ = _usage_resource_command_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = user;
	_tmp2_ = g_strdup (_tmp1_);
	_data_->user = _tmp2_;
	usage_request_resource_run_co (_data_);
}


void usage_request_resource_run_finish (UsageRequestResource* self, GAsyncResult* _res_, GError** error) {
	UsageRequestResourceRunData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void usage_request_resource_run_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	UsageRequestResourceRunData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	usage_request_resource_run_co (_data_);
}


static gboolean usage_request_resource_run_co (UsageRequestResourceRunData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		case 2:
		goto _state_2;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_state_ = 1;
	usage_resource_command_enqueue ((UsageResourceCommand*) _data_->self, usage_request_resource_run_ready, _data_);
	return FALSE;
	_state_1:
	usage_resource_command_enqueue_finish ((UsageResourceCommand*) _data_->self, _data_->_res_);
	_data_->_tmp0_ = ((UsageResourceCommand*) _data_->self)->r;
	_data_->_tmp1_ = _data_->user;
	_data_->_state_ = 2;
	usage_resource_addUser (_data_->_tmp0_, (const gchar*) _data_->_tmp1_, usage_request_resource_run_ready, _data_);
	return FALSE;
	_state_2:
	usage_resource_addUser_finish (_data_->_tmp0_, _data_->_res_, &_data_->_inner_error_);
	if (_data_->_inner_error_ != NULL) {
		if (((((_data_->_inner_error_->domain == FREE_SMARTPHONE_RESOURCE_ERROR) || (_data_->_inner_error_->domain == FREE_SMARTPHONE_USAGE_ERROR)) || (_data_->_inner_error_->domain == FREE_SMARTPHONE_ERROR)) || (_data_->_inner_error_->domain == G_DBUS_ERROR)) || (_data_->_inner_error_->domain == G_IO_ERROR)) {
			g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
			g_error_free (_data_->_inner_error_);
			if (_data_->_state_ == 0) {
				g_simple_async_result_complete_in_idle (_data_->_async_result);
			} else {
				g_simple_async_result_complete (_data_->_async_result);
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
	}
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void usage_request_resource_class_init (UsageRequestResourceClass * klass) {
	usage_request_resource_parent_class = g_type_class_peek_parent (klass);
}


static void usage_request_resource_instance_init (UsageRequestResource * self) {
}


/**
 * @class RequestResource
 **/
GType usage_request_resource_get_type (void) {
	return usage_request_resource_type_id;
}


GType usage_request_resource_register_type (GTypeModule * module) {
	static const GTypeInfo g_define_type_info = { sizeof (UsageRequestResourceClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) usage_request_resource_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UsageRequestResource), 0, (GInstanceInitFunc) usage_request_resource_instance_init, NULL };
	usage_request_resource_type_id = g_type_module_register_type (module, USAGE_TYPE_RESOURCE_COMMAND, "UsageRequestResource", &g_define_type_info, 0);
	return usage_request_resource_type_id;
}


UsageReleaseResource* usage_release_resource_construct (GType object_type, UsageResource* r) {
	UsageReleaseResource* self = NULL;
	UsageResource* _tmp0_;
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = r;
	self = (UsageReleaseResource*) usage_resource_command_construct (object_type, _tmp0_);
	return self;
}


UsageReleaseResource* usage_release_resource_new (UsageResource* r) {
	return usage_release_resource_construct (USAGE_TYPE_RELEASE_RESOURCE, r);
}


static void usage_release_resource_run_data_free (gpointer _data) {
	UsageReleaseResourceRunData* _data_;
	_data_ = _data;
	_g_free0 (_data_->user);
	_usage_resource_command_unref0 (_data_->self);
	g_slice_free (UsageReleaseResourceRunData, _data_);
}


void usage_release_resource_run (UsageReleaseResource* self, const char* user, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	UsageReleaseResourceRunData* _data_;
	UsageReleaseResource* _tmp0_;
	const char* _tmp1_;
	char* _tmp2_;
	_data_ = g_slice_new0 (UsageReleaseResourceRunData);
	_data_->_async_result = g_simple_async_result_new (g_object_newv (G_TYPE_OBJECT, 0, NULL), _callback_, _user_data_, usage_release_resource_run);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, usage_release_resource_run_data_free);
	_tmp0_ = _usage_resource_command_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = user;
	_tmp2_ = g_strdup (_tmp1_);
	_data_->user = _tmp2_;
	usage_release_resource_run_co (_data_);
}


void usage_release_resource_run_finish (UsageReleaseResource* self, GAsyncResult* _res_, GError** error) {
	UsageReleaseResourceRunData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void usage_release_resource_run_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	UsageReleaseResourceRunData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	usage_release_resource_run_co (_data_);
}


static gboolean usage_release_resource_run_co (UsageReleaseResourceRunData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		case 2:
		goto _state_2;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_state_ = 1;
	usage_resource_command_enqueue ((UsageResourceCommand*) _data_->self, usage_release_resource_run_ready, _data_);
	return FALSE;
	_state_1:
	usage_resource_command_enqueue_finish ((UsageResourceCommand*) _data_->self, _data_->_res_);
	_data_->_tmp0_ = ((UsageResourceCommand*) _data_->self)->r;
	_data_->_tmp1_ = _data_->user;
	_data_->_state_ = 2;
	usage_resource_delUser (_data_->_tmp0_, (const gchar*) _data_->_tmp1_, usage_release_resource_run_ready, _data_);
	return FALSE;
	_state_2:
	usage_resource_delUser_finish (_data_->_tmp0_, _data_->_res_, &_data_->_inner_error_);
	if (_data_->_inner_error_ != NULL) {
		if ((((_data_->_inner_error_->domain == FREE_SMARTPHONE_USAGE_ERROR) || (_data_->_inner_error_->domain == FREE_SMARTPHONE_ERROR)) || (_data_->_inner_error_->domain == G_DBUS_ERROR)) || (_data_->_inner_error_->domain == G_IO_ERROR)) {
			g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
			g_error_free (_data_->_inner_error_);
			if (_data_->_state_ == 0) {
				g_simple_async_result_complete_in_idle (_data_->_async_result);
			} else {
				g_simple_async_result_complete (_data_->_async_result);
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
	}
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void usage_release_resource_class_init (UsageReleaseResourceClass * klass) {
	usage_release_resource_parent_class = g_type_class_peek_parent (klass);
}


static void usage_release_resource_instance_init (UsageReleaseResource * self) {
}


/**
 * @class ReleaseResource
 **/
GType usage_release_resource_get_type (void) {
	return usage_release_resource_type_id;
}


GType usage_release_resource_register_type (GTypeModule * module) {
	static const GTypeInfo g_define_type_info = { sizeof (UsageReleaseResourceClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) usage_release_resource_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UsageReleaseResource), 0, (GInstanceInitFunc) usage_release_resource_instance_init, NULL };
	usage_release_resource_type_id = g_type_module_register_type (module, USAGE_TYPE_RESOURCE_COMMAND, "UsageReleaseResource", &g_define_type_info, 0);
	return usage_release_resource_type_id;
}


UsageSetResourcePolicy* usage_set_resource_policy_construct (GType object_type, UsageResource* r) {
	UsageSetResourcePolicy* self = NULL;
	UsageResource* _tmp0_;
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = r;
	self = (UsageSetResourcePolicy*) usage_resource_command_construct (object_type, _tmp0_);
	return self;
}


UsageSetResourcePolicy* usage_set_resource_policy_new (UsageResource* r) {
	return usage_set_resource_policy_construct (USAGE_TYPE_SET_RESOURCE_POLICY, r);
}


static void usage_set_resource_policy_run_data_free (gpointer _data) {
	UsageSetResourcePolicyRunData* _data_;
	_data_ = _data;
	_g_free0 (_data_->policy);
	_usage_resource_command_unref0 (_data_->self);
	g_slice_free (UsageSetResourcePolicyRunData, _data_);
}


void usage_set_resource_policy_run (UsageSetResourcePolicy* self, const gchar* policy, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	UsageSetResourcePolicyRunData* _data_;
	UsageSetResourcePolicy* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	_data_ = g_slice_new0 (UsageSetResourcePolicyRunData);
	_data_->_async_result = g_simple_async_result_new (g_object_newv (G_TYPE_OBJECT, 0, NULL), _callback_, _user_data_, usage_set_resource_policy_run);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, usage_set_resource_policy_run_data_free);
	_tmp0_ = _usage_resource_command_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = policy;
	_tmp2_ = g_strdup (_tmp1_);
	_data_->policy = _tmp2_;
	usage_set_resource_policy_run_co (_data_);
}


void usage_set_resource_policy_run_finish (UsageSetResourcePolicy* self, GAsyncResult* _res_, GError** error) {
	UsageSetResourcePolicyRunData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static gboolean usage_set_resource_policy_run_co (UsageSetResourcePolicyRunData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void usage_set_resource_policy_class_init (UsageSetResourcePolicyClass * klass) {
	usage_set_resource_policy_parent_class = g_type_class_peek_parent (klass);
}


static void usage_set_resource_policy_instance_init (UsageSetResourcePolicy * self) {
}


/**
 * @class SetResourcePolicy
 **/
GType usage_set_resource_policy_get_type (void) {
	return usage_set_resource_policy_type_id;
}


GType usage_set_resource_policy_register_type (GTypeModule * module) {
	static const GTypeInfo g_define_type_info = { sizeof (UsageSetResourcePolicyClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) usage_set_resource_policy_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UsageSetResourcePolicy), 0, (GInstanceInitFunc) usage_set_resource_policy_instance_init, NULL };
	usage_set_resource_policy_type_id = g_type_module_register_type (module, USAGE_TYPE_RESOURCE_COMMAND, "UsageSetResourcePolicy", &g_define_type_info, 0);
	return usage_set_resource_policy_type_id;
}


UsageGetResourcePolicy* usage_get_resource_policy_construct (GType object_type, UsageResource* r) {
	UsageGetResourcePolicy* self = NULL;
	UsageResource* _tmp0_;
	g_return_val_if_fail (r != NULL, NULL);
	_tmp0_ = r;
	self = (UsageGetResourcePolicy*) usage_resource_command_construct (object_type, _tmp0_);
	return self;
}


UsageGetResourcePolicy* usage_get_resource_policy_new (UsageResource* r) {
	return usage_get_resource_policy_construct (USAGE_TYPE_GET_RESOURCE_POLICY, r);
}


static void usage_get_resource_policy_run_data_free (gpointer _data) {
	UsageGetResourcePolicyRunData* _data_;
	_data_ = _data;
	_usage_resource_command_unref0 (_data_->self);
	g_slice_free (UsageGetResourcePolicyRunData, _data_);
}


void usage_get_resource_policy_run (UsageGetResourcePolicy* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	UsageGetResourcePolicyRunData* _data_;
	UsageGetResourcePolicy* _tmp0_;
	_data_ = g_slice_new0 (UsageGetResourcePolicyRunData);
	_data_->_async_result = g_simple_async_result_new (g_object_newv (G_TYPE_OBJECT, 0, NULL), _callback_, _user_data_, usage_get_resource_policy_run);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, usage_get_resource_policy_run_data_free);
	_tmp0_ = _usage_resource_command_ref0 (self);
	_data_->self = _tmp0_;
	usage_get_resource_policy_run_co (_data_);
}


void usage_get_resource_policy_run_finish (UsageGetResourcePolicy* self, GAsyncResult* _res_, GError** error) {
	UsageGetResourcePolicyRunData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static gboolean usage_get_resource_policy_run_co (UsageGetResourcePolicyRunData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void usage_get_resource_policy_class_init (UsageGetResourcePolicyClass * klass) {
	usage_get_resource_policy_parent_class = g_type_class_peek_parent (klass);
}


static void usage_get_resource_policy_instance_init (UsageGetResourcePolicy * self) {
}


/**
 * @class GetRequestPolicy
 **/
GType usage_get_resource_policy_get_type (void) {
	return usage_get_resource_policy_type_id;
}


GType usage_get_resource_policy_register_type (GTypeModule * module) {
	static const GTypeInfo g_define_type_info = { sizeof (UsageGetResourcePolicyClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) usage_get_resource_policy_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UsageGetResourcePolicy), 0, (GInstanceInitFunc) usage_get_resource_policy_instance_init, NULL };
	usage_get_resource_policy_type_id = g_type_module_register_type (module, USAGE_TYPE_RESOURCE_COMMAND, "UsageGetResourcePolicy", &g_define_type_info, 0);
	return usage_get_resource_policy_type_id;
}


static void usage_suspend_run_data_free (gpointer _data) {
	UsageSuspendRunData* _data_;
	_data_ = _data;
	_usage_system_command_unref0 (_data_->self);
	g_slice_free (UsageSuspendRunData, _data_);
}


void usage_suspend_run (UsageSuspend* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	UsageSuspendRunData* _data_;
	UsageSuspend* _tmp0_;
	_data_ = g_slice_new0 (UsageSuspendRunData);
	_data_->_async_result = g_simple_async_result_new (g_object_newv (G_TYPE_OBJECT, 0, NULL), _callback_, _user_data_, usage_suspend_run);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, usage_suspend_run_data_free);
	_tmp0_ = _usage_system_command_ref0 (self);
	_data_->self = _tmp0_;
	usage_suspend_run_co (_data_);
}


void usage_suspend_run_finish (UsageSuspend* self, GAsyncResult* _res_, GError** error) {
	UsageSuspendRunData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void usage_suspend_run_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	UsageSuspendRunData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	usage_suspend_run_co (_data_);
}


static gboolean _usage_controller_onIdleForSuspend_gsource_func (gpointer self) {
	gboolean result;
	result = usage_controller_onIdleForSuspend (self);
	return result;
}


static gboolean usage_suspend_run_co (UsageSuspendRunData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		case 2:
		goto _state_2;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_state_ = 1;
	usage_system_command_enqueue ((UsageSystemCommand*) _data_->self, usage_suspend_run_ready, _data_);
	return FALSE;
	_state_1:
	usage_system_command_enqueue_finish ((UsageSystemCommand*) _data_->self, _data_->_res_);
	_data_->_tmp0_ = usage_instance;
	usage_controller_updateSystemStatus (_data_->_tmp0_, FREE_SMARTPHONE_USAGE_SYSTEM_ACTION_SUSPEND);
	_data_->_tmp1_ = usage_instance;
	_data_->_state_ = 2;
	usage_controller_suspendAllResources (_data_->_tmp1_, usage_suspend_run_ready, _data_);
	return FALSE;
	_state_2:
	usage_controller_suspendAllResources_finish (_data_->_tmp1_, _data_->_res_);
	_data_->_tmp2_ = usage_instance;
	g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, _usage_controller_onIdleForSuspend_gsource_func, g_object_ref (_data_->_tmp2_), g_object_unref);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


UsageSuspend* usage_suspend_construct (GType object_type) {
	UsageSuspend* self = NULL;
	self = (UsageSuspend*) usage_system_command_construct (object_type);
	return self;
}


UsageSuspend* usage_suspend_new (void) {
	return usage_suspend_construct (USAGE_TYPE_SUSPEND);
}


static void usage_suspend_class_init (UsageSuspendClass * klass) {
	usage_suspend_parent_class = g_type_class_peek_parent (klass);
}


static void usage_suspend_instance_init (UsageSuspend * self) {
}


/**
 * @class Suspend
 **/
GType usage_suspend_get_type (void) {
	return usage_suspend_type_id;
}


GType usage_suspend_register_type (GTypeModule * module) {
	static const GTypeInfo g_define_type_info = { sizeof (UsageSuspendClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) usage_suspend_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UsageSuspend), 0, (GInstanceInitFunc) usage_suspend_instance_init, NULL };
	usage_suspend_type_id = g_type_module_register_type (module, USAGE_TYPE_SYSTEM_COMMAND, "UsageSuspend", &g_define_type_info, 0);
	return usage_suspend_type_id;
}


static void usage_shutdown_run_data_free (gpointer _data) {
	UsageShutdownRunData* _data_;
	_data_ = _data;
	_usage_system_command_unref0 (_data_->self);
	g_slice_free (UsageShutdownRunData, _data_);
}


void usage_shutdown_run (UsageShutdown* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	UsageShutdownRunData* _data_;
	UsageShutdown* _tmp0_;
	_data_ = g_slice_new0 (UsageShutdownRunData);
	_data_->_async_result = g_simple_async_result_new (g_object_newv (G_TYPE_OBJECT, 0, NULL), _callback_, _user_data_, usage_shutdown_run);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, usage_shutdown_run_data_free);
	_tmp0_ = _usage_system_command_ref0 (self);
	_data_->self = _tmp0_;
	usage_shutdown_run_co (_data_);
}


void usage_shutdown_run_finish (UsageShutdown* self, GAsyncResult* _res_, GError** error) {
	UsageShutdownRunData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void usage_shutdown_run_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	UsageShutdownRunData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	usage_shutdown_run_co (_data_);
}


static gboolean __lambda5_ (UsageShutdown* self) {
	gboolean result = FALSE;
	FsoFrameworkSmartKeyFile* _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* cmd;
	_tmp0_ = fso_framework_theConfig;
	_tmp1_ = fso_framework_smart_key_file_stringValue (_tmp0_, "fsousage", "shutdown_command", "/sbin/shutdown -h now");
	cmd = _tmp1_;
	system (cmd);
	result = FALSE;
	_g_free0 (cmd);
	return result;
}


static gboolean ___lambda5__gsource_func (gpointer self) {
	gboolean result;
	result = __lambda5_ (self);
	return result;
}


static gboolean usage_shutdown_run_co (UsageShutdownRunData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		case 2:
		goto _state_2;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_state_ = 1;
	usage_system_command_enqueue ((UsageSystemCommand*) _data_->self, usage_shutdown_run_ready, _data_);
	return FALSE;
	_state_1:
	usage_system_command_enqueue_finish ((UsageSystemCommand*) _data_->self, _data_->_res_);
	_data_->_tmp0_ = usage_instance;
	usage_controller_updateSystemStatus (_data_->_tmp0_, FREE_SMARTPHONE_USAGE_SYSTEM_ACTION_SHUTDOWN);
	_data_->_tmp1_ = usage_instance;
	_data_->_state_ = 2;
	usage_controller_disableAllResources (_data_->_tmp1_, usage_shutdown_run_ready, _data_);
	return FALSE;
	_state_2:
	usage_controller_disableAllResources_finish (_data_->_tmp1_, _data_->_res_);
	g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, ___lambda5__gsource_func, usage_system_command_ref (_data_->self), usage_system_command_unref);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


UsageShutdown* usage_shutdown_construct (GType object_type) {
	UsageShutdown* self = NULL;
	self = (UsageShutdown*) usage_system_command_construct (object_type);
	return self;
}


UsageShutdown* usage_shutdown_new (void) {
	return usage_shutdown_construct (USAGE_TYPE_SHUTDOWN);
}


static void usage_shutdown_class_init (UsageShutdownClass * klass) {
	usage_shutdown_parent_class = g_type_class_peek_parent (klass);
}


static void usage_shutdown_instance_init (UsageShutdown * self) {
}


/**
 * @class Shutdown
 **/
GType usage_shutdown_get_type (void) {
	return usage_shutdown_type_id;
}


GType usage_shutdown_register_type (GTypeModule * module) {
	static const GTypeInfo g_define_type_info = { sizeof (UsageShutdownClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) usage_shutdown_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UsageShutdown), 0, (GInstanceInitFunc) usage_shutdown_instance_init, NULL };
	usage_shutdown_type_id = g_type_module_register_type (module, USAGE_TYPE_SYSTEM_COMMAND, "UsageShutdown", &g_define_type_info, 0);
	return usage_shutdown_type_id;
}


static void usage_reboot_run_data_free (gpointer _data) {
	UsageRebootRunData* _data_;
	_data_ = _data;
	_usage_system_command_unref0 (_data_->self);
	g_slice_free (UsageRebootRunData, _data_);
}


void usage_reboot_run (UsageReboot* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	UsageRebootRunData* _data_;
	UsageReboot* _tmp0_;
	_data_ = g_slice_new0 (UsageRebootRunData);
	_data_->_async_result = g_simple_async_result_new (g_object_newv (G_TYPE_OBJECT, 0, NULL), _callback_, _user_data_, usage_reboot_run);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, usage_reboot_run_data_free);
	_tmp0_ = _usage_system_command_ref0 (self);
	_data_->self = _tmp0_;
	usage_reboot_run_co (_data_);
}


void usage_reboot_run_finish (UsageReboot* self, GAsyncResult* _res_, GError** error) {
	UsageRebootRunData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void usage_reboot_run_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	UsageRebootRunData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	usage_reboot_run_co (_data_);
}


static gboolean __lambda6_ (UsageReboot* self) {
	gboolean result = FALSE;
	FsoFrameworkSmartKeyFile* _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* cmd;
	_tmp0_ = fso_framework_theConfig;
	_tmp1_ = fso_framework_smart_key_file_stringValue (_tmp0_, "fsousage", "reboot_command", "/sbin/shutdown -r now");
	cmd = _tmp1_;
	system (cmd);
	result = FALSE;
	_g_free0 (cmd);
	return result;
}


static gboolean ___lambda6__gsource_func (gpointer self) {
	gboolean result;
	result = __lambda6_ (self);
	return result;
}


static gboolean usage_reboot_run_co (UsageRebootRunData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		case 2:
		goto _state_2;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_state_ = 1;
	usage_system_command_enqueue ((UsageSystemCommand*) _data_->self, usage_reboot_run_ready, _data_);
	return FALSE;
	_state_1:
	usage_system_command_enqueue_finish ((UsageSystemCommand*) _data_->self, _data_->_res_);
	_data_->_tmp0_ = usage_instance;
	usage_controller_updateSystemStatus (_data_->_tmp0_, FREE_SMARTPHONE_USAGE_SYSTEM_ACTION_REBOOT);
	_data_->_tmp1_ = usage_instance;
	_data_->_state_ = 2;
	usage_controller_disableAllResources (_data_->_tmp1_, usage_reboot_run_ready, _data_);
	return FALSE;
	_state_2:
	usage_controller_disableAllResources_finish (_data_->_tmp1_, _data_->_res_);
	g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, ___lambda6__gsource_func, usage_system_command_ref (_data_->self), usage_system_command_unref);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


UsageReboot* usage_reboot_construct (GType object_type) {
	UsageReboot* self = NULL;
	self = (UsageReboot*) usage_system_command_construct (object_type);
	return self;
}


UsageReboot* usage_reboot_new (void) {
	return usage_reboot_construct (USAGE_TYPE_REBOOT);
}


static void usage_reboot_class_init (UsageRebootClass * klass) {
	usage_reboot_parent_class = g_type_class_peek_parent (klass);
}


static void usage_reboot_instance_init (UsageReboot * self) {
}


/**
 * @class Reboot
 **/
GType usage_reboot_get_type (void) {
	return usage_reboot_type_id;
}


GType usage_reboot_register_type (GTypeModule * module) {
	static const GTypeInfo g_define_type_info = { sizeof (UsageRebootClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) usage_reboot_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UsageReboot), 0, (GInstanceInitFunc) usage_reboot_instance_init, NULL };
	usage_reboot_type_id = g_type_module_register_type (module, USAGE_TYPE_SYSTEM_COMMAND, "UsageReboot", &g_define_type_info, 0);
	return usage_reboot_type_id;
}


static void usage_resume_run_data_free (gpointer _data) {
	UsageResumeRunData* _data_;
	_data_ = _data;
	_usage_system_command_unref0 (_data_->self);
	g_slice_free (UsageResumeRunData, _data_);
}


void usage_resume_run (UsageResume* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	UsageResumeRunData* _data_;
	UsageResume* _tmp0_;
	_data_ = g_slice_new0 (UsageResumeRunData);
	_data_->_async_result = g_simple_async_result_new (g_object_newv (G_TYPE_OBJECT, 0, NULL), _callback_, _user_data_, usage_resume_run);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, usage_resume_run_data_free);
	_tmp0_ = _usage_system_command_ref0 (self);
	_data_->self = _tmp0_;
	usage_resume_run_co (_data_);
}


void usage_resume_run_finish (UsageResume* self, GAsyncResult* _res_, GError** error) {
	UsageResumeRunData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void usage_resume_run_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	UsageResumeRunData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	usage_resume_run_co (_data_);
}


static gboolean _usage_controller_onIdleForResume_gsource_func (gpointer self) {
	gboolean result;
	result = usage_controller_onIdleForResume (self);
	return result;
}


static gboolean usage_resume_run_co (UsageResumeRunData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_state_ = 1;
	usage_system_command_enqueue ((UsageSystemCommand*) _data_->self, usage_resume_run_ready, _data_);
	return FALSE;
	_state_1:
	usage_system_command_enqueue_finish ((UsageSystemCommand*) _data_->self, _data_->_res_);
	_data_->_tmp0_ = usage_instance;
	usage_controller_updateSystemStatus (_data_->_tmp0_, FREE_SMARTPHONE_USAGE_SYSTEM_ACTION_RESUME);
	_data_->_tmp1_ = usage_instance;
	g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, _usage_controller_onIdleForResume_gsource_func, g_object_ref (_data_->_tmp1_), g_object_unref);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


UsageResume* usage_resume_construct (GType object_type) {
	UsageResume* self = NULL;
	self = (UsageResume*) usage_system_command_construct (object_type);
	return self;
}


UsageResume* usage_resume_new (void) {
	return usage_resume_construct (USAGE_TYPE_RESUME);
}


static void usage_resume_class_init (UsageResumeClass * klass) {
	usage_resume_parent_class = g_type_class_peek_parent (klass);
}


static void usage_resume_instance_init (UsageResume * self) {
}


/**
 * @class Resume
 **/
GType usage_resume_get_type (void) {
	return usage_resume_type_id;
}


GType usage_resume_register_type (GTypeModule * module) {
	static const GTypeInfo g_define_type_info = { sizeof (UsageResumeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) usage_resume_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UsageResume), 0, (GInstanceInitFunc) usage_resume_instance_init, NULL };
	usage_resume_type_id = g_type_module_register_type (module, USAGE_TYPE_SYSTEM_COMMAND, "UsageResume", &g_define_type_info, 0);
	return usage_resume_type_id;
}



