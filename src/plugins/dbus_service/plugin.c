/* plugin.c generated by valac 0.16.0, the Vala compiler
 * generated from plugin.vala, do not modify */

/*
 * FSO Resource Controller DBus Service
 *
 * (C) 2009-2012 Michael 'Mickey' Lauer <mlauer@vanille-media.de>
 *               Simon Busch <morphis@gravedo.de>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <fsobasics.h>
#include <gio/gio.h>
#include <fsoframework.h>
#include <fsousage.h>
#include <gee.h>
#include <freesmartphone.h>
#include <config.h>


#define USAGE_TYPE_CONTROLLER (usage_controller_get_type ())
#define USAGE_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), USAGE_TYPE_CONTROLLER, UsageController))
#define USAGE_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), USAGE_TYPE_CONTROLLER, UsageControllerClass))
#define USAGE_IS_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), USAGE_TYPE_CONTROLLER))
#define USAGE_IS_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), USAGE_TYPE_CONTROLLER))
#define USAGE_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), USAGE_TYPE_CONTROLLER, UsageControllerClass))

typedef struct _UsageController UsageController;
typedef struct _UsageControllerClass UsageControllerClass;
typedef struct _UsageControllerPrivate UsageControllerPrivate;

#define USAGE_TYPE_RESOURCE (usage_resource_get_type ())
#define USAGE_RESOURCE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), USAGE_TYPE_RESOURCE, UsageResource))
#define USAGE_RESOURCE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), USAGE_TYPE_RESOURCE, UsageResourceClass))
#define USAGE_IS_RESOURCE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), USAGE_TYPE_RESOURCE))
#define USAGE_IS_RESOURCE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), USAGE_TYPE_RESOURCE))
#define USAGE_RESOURCE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), USAGE_TYPE_RESOURCE, UsageResourceClass))

typedef struct _UsageResource UsageResource;
typedef struct _UsageResourceClass UsageResourceClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
#define _g_dir_close0(var) ((var == NULL) ? NULL : (var = (g_dir_close (var), NULL)))
typedef struct _usage_controller_onResourceAppearingData usage_controller_onResourceAppearingData;
typedef struct _usage_controller_updateIdleStateData usage_controller_updateIdleStateData;
#define __g_list_free__g_object_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_object_unref0_ (var), NULL)))
typedef struct _Block3Data Block3Data;
typedef struct _usage_controller_disableAllResourcesData usage_controller_disableAllResourcesData;
typedef struct _usage_controller_suspendAllResourcesData usage_controller_suspendAllResourcesData;
typedef struct _usage_controller_resumeAllResourcesData usage_controller_resumeAllResourcesData;

#define USAGE_TYPE_IRESOURCE (usage_iresource_get_type ())
#define USAGE_IRESOURCE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), USAGE_TYPE_IRESOURCE, UsageIResource))
#define USAGE_IS_IRESOURCE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), USAGE_TYPE_IRESOURCE))
#define USAGE_IRESOURCE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), USAGE_TYPE_IRESOURCE, UsageIResourceIface))

typedef struct _UsageIResource UsageIResource;
typedef struct _UsageIResourceIface UsageIResourceIface;
typedef struct _UsageResourcePrivate UsageResourcePrivate;

#define USAGE_TYPE_RESOURCE_COMMAND (usage_resource_command_get_type ())
#define USAGE_RESOURCE_COMMAND(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), USAGE_TYPE_RESOURCE_COMMAND, UsageResourceCommand))
#define USAGE_RESOURCE_COMMAND_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), USAGE_TYPE_RESOURCE_COMMAND, UsageResourceCommandClass))
#define USAGE_IS_RESOURCE_COMMAND(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), USAGE_TYPE_RESOURCE_COMMAND))
#define USAGE_IS_RESOURCE_COMMAND_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), USAGE_TYPE_RESOURCE_COMMAND))
#define USAGE_RESOURCE_COMMAND_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), USAGE_TYPE_RESOURCE_COMMAND, UsageResourceCommandClass))

typedef struct _UsageResourceCommand UsageResourceCommand;
typedef struct _UsageResourceCommandClass UsageResourceCommandClass;
typedef struct _UsageControllerGetResourcePolicyData UsageControllerGetResourcePolicyData;
typedef struct _UsageControllerSetResourcePolicyData UsageControllerSetResourcePolicyData;
typedef struct _UsageControllerGetResourceStateData UsageControllerGetResourceStateData;
typedef struct _UsageControllerGetResourceUsersData UsageControllerGetResourceUsersData;
typedef struct _UsageControllerListResourcesData UsageControllerListResourcesData;

#define USAGE_TYPE_REQUEST_RESOURCE (usage_request_resource_get_type ())
#define USAGE_REQUEST_RESOURCE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), USAGE_TYPE_REQUEST_RESOURCE, UsageRequestResource))
#define USAGE_REQUEST_RESOURCE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), USAGE_TYPE_REQUEST_RESOURCE, UsageRequestResourceClass))
#define USAGE_IS_REQUEST_RESOURCE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), USAGE_TYPE_REQUEST_RESOURCE))
#define USAGE_IS_REQUEST_RESOURCE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), USAGE_TYPE_REQUEST_RESOURCE))
#define USAGE_REQUEST_RESOURCE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), USAGE_TYPE_REQUEST_RESOURCE, UsageRequestResourceClass))

typedef struct _UsageRequestResource UsageRequestResource;
typedef struct _UsageRequestResourceClass UsageRequestResourceClass;
#define _usage_resource_command_unref0(var) ((var == NULL) ? NULL : (var = (usage_resource_command_unref (var), NULL)))
typedef struct _UsageControllerRequestResourceData UsageControllerRequestResourceData;

#define USAGE_TYPE_RELEASE_RESOURCE (usage_release_resource_get_type ())
#define USAGE_RELEASE_RESOURCE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), USAGE_TYPE_RELEASE_RESOURCE, UsageReleaseResource))
#define USAGE_RELEASE_RESOURCE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), USAGE_TYPE_RELEASE_RESOURCE, UsageReleaseResourceClass))
#define USAGE_IS_RELEASE_RESOURCE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), USAGE_TYPE_RELEASE_RESOURCE))
#define USAGE_IS_RELEASE_RESOURCE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), USAGE_TYPE_RELEASE_RESOURCE))
#define USAGE_RELEASE_RESOURCE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), USAGE_TYPE_RELEASE_RESOURCE, UsageReleaseResourceClass))

typedef struct _UsageReleaseResource UsageReleaseResource;
typedef struct _UsageReleaseResourceClass UsageReleaseResourceClass;
typedef struct _UsageControllerReleaseResourceData UsageControllerReleaseResourceData;

#define USAGE_TYPE_SYSTEM_COMMAND (usage_system_command_get_type ())
#define USAGE_SYSTEM_COMMAND(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), USAGE_TYPE_SYSTEM_COMMAND, UsageSystemCommand))
#define USAGE_SYSTEM_COMMAND_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), USAGE_TYPE_SYSTEM_COMMAND, UsageSystemCommandClass))
#define USAGE_IS_SYSTEM_COMMAND(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), USAGE_TYPE_SYSTEM_COMMAND))
#define USAGE_IS_SYSTEM_COMMAND_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), USAGE_TYPE_SYSTEM_COMMAND))
#define USAGE_SYSTEM_COMMAND_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), USAGE_TYPE_SYSTEM_COMMAND, UsageSystemCommandClass))

typedef struct _UsageSystemCommand UsageSystemCommand;
typedef struct _UsageSystemCommandClass UsageSystemCommandClass;

#define USAGE_TYPE_SHUTDOWN (usage_shutdown_get_type ())
#define USAGE_SHUTDOWN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), USAGE_TYPE_SHUTDOWN, UsageShutdown))
#define USAGE_SHUTDOWN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), USAGE_TYPE_SHUTDOWN, UsageShutdownClass))
#define USAGE_IS_SHUTDOWN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), USAGE_TYPE_SHUTDOWN))
#define USAGE_IS_SHUTDOWN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), USAGE_TYPE_SHUTDOWN))
#define USAGE_SHUTDOWN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), USAGE_TYPE_SHUTDOWN, UsageShutdownClass))

typedef struct _UsageShutdown UsageShutdown;
typedef struct _UsageShutdownClass UsageShutdownClass;
#define _usage_system_command_unref0(var) ((var == NULL) ? NULL : (var = (usage_system_command_unref (var), NULL)))
typedef struct _UsageControllerShutdownData UsageControllerShutdownData;

#define USAGE_TYPE_REBOOT (usage_reboot_get_type ())
#define USAGE_REBOOT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), USAGE_TYPE_REBOOT, UsageReboot))
#define USAGE_REBOOT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), USAGE_TYPE_REBOOT, UsageRebootClass))
#define USAGE_IS_REBOOT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), USAGE_TYPE_REBOOT))
#define USAGE_IS_REBOOT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), USAGE_TYPE_REBOOT))
#define USAGE_REBOOT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), USAGE_TYPE_REBOOT, UsageRebootClass))

typedef struct _UsageReboot UsageReboot;
typedef struct _UsageRebootClass UsageRebootClass;
typedef struct _UsageControllerRebootData UsageControllerRebootData;

#define USAGE_TYPE_SUSPEND (usage_suspend_get_type ())
#define USAGE_SUSPEND(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), USAGE_TYPE_SUSPEND, UsageSuspend))
#define USAGE_SUSPEND_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), USAGE_TYPE_SUSPEND, UsageSuspendClass))
#define USAGE_IS_SUSPEND(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), USAGE_TYPE_SUSPEND))
#define USAGE_IS_SUSPEND_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), USAGE_TYPE_SUSPEND))
#define USAGE_SUSPEND_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), USAGE_TYPE_SUSPEND, UsageSuspendClass))

typedef struct _UsageSuspend UsageSuspend;
typedef struct _UsageSuspendClass UsageSuspendClass;
typedef struct _UsageControllerSuspendData UsageControllerSuspendData;

#define USAGE_TYPE_RESUME (usage_resume_get_type ())
#define USAGE_RESUME(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), USAGE_TYPE_RESUME, UsageResume))
#define USAGE_RESUME_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), USAGE_TYPE_RESUME, UsageResumeClass))
#define USAGE_IS_RESUME(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), USAGE_TYPE_RESUME))
#define USAGE_IS_RESUME_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), USAGE_TYPE_RESUME))
#define USAGE_RESUME_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), USAGE_TYPE_RESUME, UsageResumeClass))

typedef struct _UsageResume UsageResume;
typedef struct _UsageResumeClass UsageResumeClass;
typedef struct _UsageControllerResumeData UsageControllerResumeData;

struct _UsageController {
	FsoFrameworkAbstractObject parent_instance;
	UsageControllerPrivate * priv;
};

struct _UsageControllerClass {
	FsoFrameworkAbstractObjectClass parent_class;
};

struct _UsageControllerPrivate {
	FsoFrameworkSubsystem* subsystem;
	FsoUsageLowLevel* lowlevel;
	gboolean debug_enable_on_startup;
	gboolean debug_do_not_suspend;
	gboolean debug_suspend_user_initiated;
	gboolean disable_on_startup;
	gboolean disable_on_shutdown;
	gboolean wakelock_support;
	GeeHashMap* resources;
	DBusServiceIDBus* dbus;
	FreeSmartphoneDeviceIdleNotifier* idlenotifier;
	FreeSmartphoneUsageSystemAction system_status;
};

struct _usage_controller_onResourceAppearingData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	UsageController* self;
	UsageResource* r;
	FsoFrameworkLogger* _tmp0_;
	UsageResource* _tmp1_;
	const gchar* _tmp2_;
	const gchar* _tmp3_;
	const gchar* _tmp4_;
	UsageResource* _tmp5_;
	const char* _tmp6_;
	const char* _tmp7_;
	const gchar* _tmp8_;
	UsageResource* _tmp9_;
	const char* _tmp10_;
	const char* _tmp11_;
	const gchar* _tmp12_;
	gchar* _tmp13_;
	gchar* _tmp14_;
	gboolean _tmp15_;
	UsageResource* _tmp16_;
	const gchar* _tmp17_;
	const gchar* _tmp18_;
	gboolean _tmp19_;
	UsageResource* _tmp20_;
	GError* e0;
	FsoFrameworkLogger* _tmp21_;
	UsageResource* _tmp22_;
	const gchar* _tmp23_;
	const gchar* _tmp24_;
	const gchar* _tmp25_;
	GError* _tmp26_;
	const gchar* _tmp27_;
	const gchar* _tmp28_;
	gchar* _tmp29_;
	gchar* _tmp30_;
	gboolean _tmp31_;
	UsageResource* _tmp32_;
	GError* e1;
	FsoFrameworkLogger* _tmp33_;
	UsageResource* _tmp34_;
	const gchar* _tmp35_;
	const gchar* _tmp36_;
	const gchar* _tmp37_;
	GError* _tmp38_;
	const gchar* _tmp39_;
	const gchar* _tmp40_;
	gchar* _tmp41_;
	gchar* _tmp42_;
	GError * _inner_error_;
};

struct _usage_controller_updateIdleStateData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	UsageController* self;
	FreeSmartphoneDeviceIdleState state;
	FreeSmartphoneDeviceIdleNotifier* _tmp0_;
	FreeSmartphoneDeviceIdleState _tmp1_;
	GError* e;
	FsoFrameworkLogger* _tmp2_;
	GError* _tmp3_;
	const gchar* _tmp4_;
	const gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	GError * _inner_error_;
};

struct _Block3Data {
	int _ref_count_;
	UsageController * self;
	GeeHashMap* resourcesWithPriority;
};

struct _usage_controller_disableAllResourcesData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	UsageController* self;
	FsoFrameworkLogger* _tmp0_;
	gboolean _tmp1_;
	gint _tmp2_;
	UsageResource** _tmp3_;
	UsageResource** r_collection;
	gint r_collection_length1;
	gint _r_collection_size_;
	gint r_it;
	UsageResource* _tmp4_;
	UsageResource* r;
	UsageResource* _tmp5_;
	GError* e;
	FsoFrameworkLogger* _tmp6_;
	UsageResource* _tmp7_;
	const gchar* _tmp8_;
	const gchar* _tmp9_;
	const gchar* _tmp10_;
	GError* _tmp11_;
	const gchar* _tmp12_;
	const gchar* _tmp13_;
	gchar* _tmp14_;
	gchar* _tmp15_;
	FsoFrameworkLogger* _tmp16_;
	gboolean _tmp17_;
	GError * _inner_error_;
};

struct _usage_controller_suspendAllResourcesData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	UsageController* self;
	FsoFrameworkLogger* _tmp0_;
	gboolean _tmp1_;
	gint _tmp2_;
	UsageResource** _tmp3_;
	UsageResource** r_collection;
	gint r_collection_length1;
	gint _r_collection_size_;
	gint r_it;
	UsageResource* _tmp4_;
	UsageResource* r;
	UsageResource* _tmp5_;
	GError* e;
	FsoFrameworkLogger* _tmp6_;
	UsageResource* _tmp7_;
	const gchar* _tmp8_;
	const gchar* _tmp9_;
	const gchar* _tmp10_;
	GError* _tmp11_;
	const gchar* _tmp12_;
	const gchar* _tmp13_;
	gchar* _tmp14_;
	gchar* _tmp15_;
	FsoFrameworkLogger* _tmp16_;
	gboolean _tmp17_;
	GError * _inner_error_;
};

struct _usage_controller_resumeAllResourcesData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	UsageController* self;
	FsoFrameworkLogger* _tmp0_;
	gboolean _tmp1_;
	gint _tmp2_;
	UsageResource** _tmp3_;
	UsageResource** r_collection;
	gint r_collection_length1;
	gint _r_collection_size_;
	gint r_it;
	UsageResource* _tmp4_;
	UsageResource* r;
	FsoFrameworkLogger* _tmp5_;
	UsageResource* _tmp6_;
	const gchar* _tmp7_;
	const gchar* _tmp8_;
	const gchar* _tmp9_;
	gchar* _tmp10_;
	gchar* _tmp11_;
	gboolean _tmp12_;
	UsageResource* _tmp13_;
	GError* e;
	FsoFrameworkLogger* _tmp14_;
	UsageResource* _tmp15_;
	const gchar* _tmp16_;
	const gchar* _tmp17_;
	const gchar* _tmp18_;
	GError* _tmp19_;
	const gchar* _tmp20_;
	const gchar* _tmp21_;
	gchar* _tmp22_;
	gchar* _tmp23_;
	FsoFrameworkLogger* _tmp24_;
	gboolean _tmp25_;
	GError * _inner_error_;
};

struct _UsageIResourceIface {
	GTypeInterface parent_iface;
	void (*setPolicy) (UsageIResource* self, FreeSmartphoneUsageResourcePolicy policy, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*setPolicy_finish) (UsageIResource* self, GAsyncResult* _res_, GError** error);
	void (*enable) (UsageIResource* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*enable_finish) (UsageIResource* self, GAsyncResult* _res_, GError** error);
	void (*disable) (UsageIResource* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*disable_finish) (UsageIResource* self, GAsyncResult* _res_, GError** error);
	void (*suspend) (UsageIResource* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*suspend_finish) (UsageIResource* self, GAsyncResult* _res_, GError** error);
	void (*resume) (UsageIResource* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*resume_finish) (UsageIResource* self, GAsyncResult* _res_, GError** error);
};

struct _UsageResource {
	GObject parent_instance;
	UsageResourcePrivate * priv;
	FreeSmartphoneResource* proxy;
	GeeLinkedList* q;
};

struct _UsageResourceClass {
	GObjectClass parent_class;
	void (*setPolicy) (UsageResource* self, FreeSmartphoneUsageResourcePolicy policy, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*setPolicy_finish) (UsageResource* self, GAsyncResult* _res_, GError** error);
	void (*enableShadowResource) (UsageResource* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*enableShadowResource_finish) (UsageResource* self, GAsyncResult* _res_, GError** error);
	void (*enable) (UsageResource* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*enable_finish) (UsageResource* self, GAsyncResult* _res_, GError** error);
	void (*disable) (UsageResource* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*disable_finish) (UsageResource* self, GAsyncResult* _res_, GError** error);
	void (*suspend) (UsageResource* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*suspend_finish) (UsageResource* self, GAsyncResult* _res_, GError** error);
	void (*resume) (UsageResource* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
	void (*resume_finish) (UsageResource* self, GAsyncResult* _res_, GError** error);
};

struct _UsageControllerGetResourcePolicyData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	UsageController* self;
	gchar* name;
	gchar* result;
	const gchar* _tmp0_;
	UsageResource* _tmp1_;
	UsageResource* _tmp2_;
	UsageResource* _tmp3_;
	FreeSmartphoneUsageResourcePolicy _tmp4_;
	FreeSmartphoneUsageResourcePolicy _tmp5_;
	FreeSmartphoneUsageResourcePolicy _tmp6_;
	gchar* _tmp7_;
	gchar* _tmp8_;
	gchar* _tmp9_;
	const gchar* _tmp10_;
	UsageResource* _tmp11_;
	UsageResource* _tmp12_;
	UsageResource* _tmp13_;
	FreeSmartphoneUsageResourcePolicy _tmp14_;
	FreeSmartphoneUsageResourcePolicy _tmp15_;
	const gchar* _tmp16_;
	gchar* _tmp17_;
	gchar* _tmp18_;
	gchar* _error_;
	FsoFrameworkLogger* _tmp19_;
	const gchar* _tmp20_;
	const gchar* _tmp21_;
	GError* _tmp22_;
	GError * _inner_error_;
};

struct _UsageControllerSetResourcePolicyData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	UsageController* self;
	gchar* name;
	gchar* policy;
	FsoFrameworkLogger* _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	const gchar* _tmp3_;
	const gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	const gchar* _tmp7_;
	UsageResource* _tmp8_;
	UsageResource* resource;
	FreeSmartphoneUsageResourcePolicy policyToSet;
	const gchar* _tmp9_;
	const gchar* _tmp10_;
	GQuark _tmp12_;
	GError* _tmp13_;
	UsageResource* _tmp14_;
	FreeSmartphoneUsageResourcePolicy _tmp15_;
	GError * _inner_error_;
};

struct _UsageControllerGetResourceStateData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	UsageController* self;
	gchar* name;
	gboolean result;
	const gchar* _tmp0_;
	UsageResource* _tmp1_;
	UsageResource* _tmp2_;
	UsageResource* _tmp3_;
	gboolean _tmp4_;
	gboolean _tmp5_;
	GError * _inner_error_;
};

struct _UsageControllerGetResourceUsersData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	UsageController* self;
	gchar* name;
	gchar** result;
	gint result_length1;
	const gchar* _tmp0_;
	UsageResource* _tmp1_;
	UsageResource* _tmp2_;
	UsageResource* _tmp3_;
	gint _tmp4_;
	gchar** _tmp5_;
	gchar** _tmp6_;
	gint _tmp6__length1;
	gchar** _tmp7_;
	gint _tmp7__length1;
	GError * _inner_error_;
};

struct _UsageControllerListResourcesData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	UsageController* self;
	gchar** result;
	gint result_length1;
	gchar** _tmp0_;
	gchar** res;
	gint res_length1;
	gint _res_size_;
	GeeHashMap* _tmp1_;
	GeeSet* _tmp2_;
	GeeSet* _tmp3_;
	GeeSet* _tmp4_;
	GeeIterator* _tmp5_;
	GeeIterator* _tmp6_;
	GeeIterator* _key_it;
	GeeIterator* _tmp7_;
	gboolean _tmp8_;
	GeeIterator* _tmp9_;
	gpointer _tmp10_;
	gchar* key;
	gchar** _tmp11_;
	gint _tmp11__length1;
	const gchar* _tmp12_;
	gchar* _tmp13_;
	gchar** _tmp14_;
	gint _tmp14__length1;
};

struct _UsageControllerRequestResourceData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	UsageController* self;
	char* sender;
	gchar* name;
	const gchar* _tmp0_;
	UsageResource* _tmp1_;
	UsageResource* _tmp2_;
	UsageResource* _tmp3_;
	UsageRequestResource* _tmp4_;
	UsageRequestResource* _tmp5_;
	UsageRequestResource* cmd;
	UsageRequestResource* _tmp6_;
	const char* _tmp7_;
	GError * _inner_error_;
};

struct _UsageControllerReleaseResourceData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	UsageController* self;
	char* sender;
	gchar* name;
	const gchar* _tmp0_;
	UsageResource* _tmp1_;
	UsageResource* _tmp2_;
	UsageResource* _tmp3_;
	UsageReleaseResource* _tmp4_;
	UsageReleaseResource* _tmp5_;
	UsageReleaseResource* cmd;
	UsageReleaseResource* _tmp6_;
	const char* _tmp7_;
	GError * _inner_error_;
};

struct _UsageControllerShutdownData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	UsageController* self;
	UsageShutdown* _tmp0_;
	UsageShutdown* cmd;
	GError * _inner_error_;
};

struct _UsageControllerRebootData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	UsageController* self;
	UsageReboot* _tmp0_;
	UsageReboot* cmd;
	GError * _inner_error_;
};

struct _UsageControllerSuspendData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	UsageController* self;
	UsageSuspend* _tmp0_;
	UsageSuspend* cmd;
	GError * _inner_error_;
};

struct _UsageControllerResumeData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	UsageController* self;
	gchar* source;
	gchar* reason;
	UsageResume* _tmp0_;
	UsageResume* cmd;
	GError * _inner_error_;
};


static gpointer usage_controller_parent_class = NULL;
extern UsageController* usage_instance;
static GType usage_controller_type_id = 0;
UsageController* usage_instance = NULL;

#define RESOURCE_INTERFACE "org.freesmartphone.Resource"
#define CONFIG_SECTION "fsousage"
#define DEFAULT_LOWLEVEL_MODULE "kernel26"
#define FSO_IDLENOTIFIER_BUS "org.freesmartphone.odeviced"
#define FSO_IDLENOTIFIER_PATH "/org/freesmartphone/Device/IdleNotifier/0"
#define FSO_IDLENOTIFIER_IFACE "org.freesmartphone.Device.IdleNotifier"
#define FSO_DBUS_RESOURCE_PROVIDER_SECTION "D-BUS Service"
#define FSO_DBUS_RESOURCE_PROVIDER_KEY "FSO-provides-resource"
GType usage_controller_get_type (void) G_GNUC_CONST;
GType usage_controller_register_type (GTypeModule * module);
guint usage_controller_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
GType usage_resource_get_type (void) G_GNUC_CONST;
GType usage_resource_register_type (GTypeModule * module);
#define USAGE_CONTROLLER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), USAGE_TYPE_CONTROLLER, UsageControllerPrivate))
enum  {
	USAGE_CONTROLLER_DUMMY_PROPERTY
};
UsageController* usage_controller_new (FsoFrameworkSubsystem* subsystem);
UsageController* usage_controller_construct (GType object_type, FsoFrameworkSubsystem* subsystem);
static void usage_controller_onNameOwnerChanged (UsageController* self, const gchar* name, const gchar* oldowner, const gchar* newowner);
static void _usage_controller_onNameOwnerChanged_dbus_service_id_bus_name_owner_changed (DBusServiceIDBus* _sender, const gchar* name, const gchar* oldowner, const gchar* newowner, gpointer self);
static void usage_controller_initResources (UsageController* self);
static void usage_controller_initLowlevel (UsageController* self);
static void usage_controller_scanForResourceProviders (UsageController* self);
static gboolean __lambda2_ (UsageController* self);
void usage_controller_updateSystemStatus (UsageController* self, FreeSmartphoneUsageSystemAction action);
static gboolean ___lambda2__gsource_func (gpointer self);
static gchar* usage_controller_real_repr (FsoFrameworkAbstractObject* base);
UsageResource* usage_resource_new (const gchar* name, const char* busname, const char* objectpath);
UsageResource* usage_resource_construct (GType object_type, const gchar* name, const char* busname, const char* objectpath);
static void usage_controller_onResourceAppearing_data_free (gpointer _data);
static void usage_controller_onResourceAppearing (UsageController* self, UsageResource* r, GAsyncReadyCallback _callback_, gpointer _user_data_);
static void usage_controller_onResourceAppearing_finish (UsageController* self, GAsyncResult* _res_);
static gboolean usage_controller_onResourceAppearing_co (usage_controller_onResourceAppearingData* _data_);
const gchar* usage_resource_get_name (UsageResource* self);
const char* usage_resource_get_busname (UsageResource* self);
const char* usage_resource_get_objectpath (UsageResource* self);
void usage_resource_enable (UsageResource* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void usage_resource_enable_finish (UsageResource* self, GAsyncResult* _res_, GError** error);
static void usage_controller_onResourceAppearing_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
void usage_resource_disable (UsageResource* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void usage_resource_disable_finish (UsageResource* self, GAsyncResult* _res_, GError** error);
static void usage_controller_onResourceVanishing (UsageController* self, UsageResource* r);
gboolean usage_resource_hasUser (UsageResource* self, const gchar* user);
void usage_resource_delUser (UsageResource* self, const gchar* user, GAsyncReadyCallback _callback_, gpointer _user_data_);
void usage_resource_delUser_finish (UsageResource* self, GAsyncResult* _res_, GError** error);
gboolean usage_controller_onIdleForSuspend (UsageController* self);
FsoFrameworkResourceStatus usage_resource_get_status (UsageResource* self);
const gchar* fso_usage_resume_reason_to_string (FsoUsageResumeReason self);
void usage_controller_resumeAllResources (UsageController* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void usage_controller_resumeAllResources_finish (UsageController* self, GAsyncResult* _res_);
const gchar* free_smartphone_device_idle_state_to_string (FreeSmartphoneDeviceIdleState self);
static void usage_controller_updateIdleState (UsageController* self, FreeSmartphoneDeviceIdleState state, GAsyncReadyCallback _callback_, gpointer _user_data_);
static void usage_controller_updateIdleState_finish (UsageController* self, GAsyncResult* _res_);
gboolean usage_controller_onIdleForResume (UsageController* self);
static void usage_controller_updateIdleState_data_free (gpointer _data);
static gboolean usage_controller_updateIdleState_co (usage_controller_updateIdleStateData* _data_);
static void usage_controller_updateIdleState_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
UsageResource* usage_controller_getResource (UsageController* self, const gchar* name, GError** error);
const gchar* free_smartphone_usage_system_action_to_string (FreeSmartphoneUsageSystemAction self);
gchar** usage_resource_allUsers (UsageResource* self, int* result_length1);
static GList* usage_controller_resolveResourceDependencies (UsageController* self, UsageResource* r);
GeeArrayList* usage_resource_get_busDependencies (UsageResource* self);
static void _g_object_unref0_ (gpointer var);
static void _g_list_free__g_object_unref0_ (GList* self);
static void usage_controller_incrementResourcePriority (UsageController* self, GeeHashMap* resourcesWithPriority, const gchar* name);
static UsageResource** usage_controller_retrievePriorizedResourceList (UsageController* self, gboolean revertOrder, int* result_length1);
static Block3Data* block3_data_ref (Block3Data* _data3_);
static void block3_data_unref (void * _userdata_);
static gint __lambda4_ (Block3Data* _data3_, gconstpointer a, gconstpointer b);
static gint ___lambda4__gcompare_data_func (gconstpointer a, gconstpointer b, gpointer self);
static void usage_controller_disableAllResources_data_free (gpointer _data);
void usage_controller_disableAllResources (UsageController* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void usage_controller_disableAllResources_finish (UsageController* self, GAsyncResult* _res_);
static gboolean usage_controller_disableAllResources_co (usage_controller_disableAllResourcesData* _data_);
static void usage_controller_disableAllResources_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static void usage_controller_suspendAllResources_data_free (gpointer _data);
void usage_controller_suspendAllResources (UsageController* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void usage_controller_suspendAllResources_finish (UsageController* self, GAsyncResult* _res_);
static gboolean usage_controller_suspendAllResources_co (usage_controller_suspendAllResourcesData* _data_);
void usage_resource_suspend (UsageResource* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void usage_resource_suspend_finish (UsageResource* self, GAsyncResult* _res_, GError** error);
static void usage_controller_suspendAllResources_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static void usage_controller_resumeAllResources_data_free (gpointer _data);
static gboolean usage_controller_resumeAllResources_co (usage_controller_resumeAllResourcesData* _data_);
void usage_resource_resume (UsageResource* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void usage_resource_resume_finish (UsageResource* self, GAsyncResult* _res_, GError** error);
static void usage_controller_resumeAllResources_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
void usage_controller_register_resource (UsageController* self, const char* sender, const gchar* name, const char* path, GError** error);
void usage_resource_set_objectpath (UsageResource* self, const char* value);
GType usage_iresource_get_type (void) G_GNUC_CONST;
GType usage_iresource_register_type (GTypeModule * module);
gpointer usage_resource_command_ref (gpointer instance);
void usage_resource_command_unref (gpointer instance);
GParamSpec* usage_param_spec_resource_command (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void usage_value_set_resource_command (GValue* value, gpointer v_object);
void usage_value_take_resource_command (GValue* value, gpointer v_object);
gpointer usage_value_get_resource_command (const GValue* value);
GType usage_resource_command_get_type (void) G_GNUC_CONST;
GType usage_resource_command_register_type (GTypeModule * module);
void usage_controller_unregister_resource (UsageController* self, const char* sender, const gchar* name, GError** error);
void usage_controller_shutdownPlugin (UsageController* self);
static void usage_controller_get_resource_policy_data_free (gpointer _data);
void usage_controller_get_resource_policy (UsageController* self, const gchar* name, GAsyncReadyCallback _callback_, gpointer _user_data_);
gchar* usage_controller_get_resource_policy_finish (UsageController* self, GAsyncResult* _res_, GError** error);
static gboolean usage_controller_get_resource_policy_co (UsageControllerGetResourcePolicyData* _data_);
FreeSmartphoneUsageResourcePolicy usage_resource_get_policy (UsageResource* self);
static void usage_controller_set_resource_policy_data_free (gpointer _data);
void usage_controller_set_resource_policy (UsageController* self, const gchar* name, const gchar* policy, GAsyncReadyCallback _callback_, gpointer _user_data_);
void usage_controller_set_resource_policy_finish (UsageController* self, GAsyncResult* _res_, GError** error);
static gboolean usage_controller_set_resource_policy_co (UsageControllerSetResourcePolicyData* _data_);
void usage_resource_setPolicy (UsageResource* self, FreeSmartphoneUsageResourcePolicy policy, GAsyncReadyCallback _callback_, gpointer _user_data_);
void usage_resource_setPolicy_finish (UsageResource* self, GAsyncResult* _res_, GError** error);
static void usage_controller_set_resource_policy_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static void usage_controller_get_resource_state_data_free (gpointer _data);
void usage_controller_get_resource_state (UsageController* self, const gchar* name, GAsyncReadyCallback _callback_, gpointer _user_data_);
gboolean usage_controller_get_resource_state_finish (UsageController* self, GAsyncResult* _res_, GError** error);
static gboolean usage_controller_get_resource_state_co (UsageControllerGetResourceStateData* _data_);
gboolean usage_resource_isEnabled (UsageResource* self);
static void usage_controller_get_resource_users_data_free (gpointer _data);
void usage_controller_get_resource_users (UsageController* self, const gchar* name, GAsyncReadyCallback _callback_, gpointer _user_data_);
gchar** usage_controller_get_resource_users_finish (UsageController* self, GAsyncResult* _res_, int* result_length1, GError** error);
static gboolean usage_controller_get_resource_users_co (UsageControllerGetResourceUsersData* _data_);
static void usage_controller_list_resources_data_free (gpointer _data);
void usage_controller_list_resources (UsageController* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
gchar** usage_controller_list_resources_finish (UsageController* self, GAsyncResult* _res_, int* result_length1, GError** error);
static gboolean usage_controller_list_resources_co (UsageControllerListResourcesData* _data_);
static void _vala_array_add2 (gchar*** array, int* length, int* size, gchar* value);
static void usage_controller_request_resource_data_free (gpointer _data);
void usage_controller_request_resource (UsageController* self, const char* sender, const gchar* name, GAsyncReadyCallback _callback_, gpointer _user_data_);
void usage_controller_request_resource_finish (UsageController* self, GAsyncResult* _res_, GError** error);
static gboolean usage_controller_request_resource_co (UsageControllerRequestResourceData* _data_);
UsageRequestResource* usage_request_resource_new (UsageResource* r);
UsageRequestResource* usage_request_resource_construct (GType object_type, UsageResource* r);
GType usage_request_resource_get_type (void) G_GNUC_CONST;
GType usage_request_resource_register_type (GTypeModule * module);
void usage_request_resource_run (UsageRequestResource* self, const char* user, GAsyncReadyCallback _callback_, gpointer _user_data_);
void usage_request_resource_run_finish (UsageRequestResource* self, GAsyncResult* _res_, GError** error);
static void usage_controller_request_resource_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static void usage_controller_release_resource_data_free (gpointer _data);
void usage_controller_release_resource (UsageController* self, const char* sender, const gchar* name, GAsyncReadyCallback _callback_, gpointer _user_data_);
void usage_controller_release_resource_finish (UsageController* self, GAsyncResult* _res_, GError** error);
static gboolean usage_controller_release_resource_co (UsageControllerReleaseResourceData* _data_);
UsageReleaseResource* usage_release_resource_new (UsageResource* r);
UsageReleaseResource* usage_release_resource_construct (GType object_type, UsageResource* r);
GType usage_release_resource_get_type (void) G_GNUC_CONST;
GType usage_release_resource_register_type (GTypeModule * module);
void usage_release_resource_run (UsageReleaseResource* self, const char* user, GAsyncReadyCallback _callback_, gpointer _user_data_);
void usage_release_resource_run_finish (UsageReleaseResource* self, GAsyncResult* _res_, GError** error);
static void usage_controller_release_resource_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static void usage_controller_shutdown_data_free (gpointer _data);
void usage_controller_shutdown (UsageController* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void usage_controller_shutdown_finish (UsageController* self, GAsyncResult* _res_, GError** error);
static gboolean usage_controller_shutdown_co (UsageControllerShutdownData* _data_);
UsageShutdown* usage_shutdown_new (void);
UsageShutdown* usage_shutdown_construct (GType object_type);
gpointer usage_system_command_ref (gpointer instance);
void usage_system_command_unref (gpointer instance);
GParamSpec* usage_param_spec_system_command (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void usage_value_set_system_command (GValue* value, gpointer v_object);
void usage_value_take_system_command (GValue* value, gpointer v_object);
gpointer usage_value_get_system_command (const GValue* value);
GType usage_system_command_get_type (void) G_GNUC_CONST;
GType usage_system_command_register_type (GTypeModule * module);
GType usage_shutdown_get_type (void) G_GNUC_CONST;
GType usage_shutdown_register_type (GTypeModule * module);
void usage_shutdown_run (UsageShutdown* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void usage_shutdown_run_finish (UsageShutdown* self, GAsyncResult* _res_, GError** error);
static void usage_controller_shutdown_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static void usage_controller_reboot_data_free (gpointer _data);
void usage_controller_reboot (UsageController* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void usage_controller_reboot_finish (UsageController* self, GAsyncResult* _res_, GError** error);
static gboolean usage_controller_reboot_co (UsageControllerRebootData* _data_);
UsageReboot* usage_reboot_new (void);
UsageReboot* usage_reboot_construct (GType object_type);
GType usage_reboot_get_type (void) G_GNUC_CONST;
GType usage_reboot_register_type (GTypeModule * module);
void usage_reboot_run (UsageReboot* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void usage_reboot_run_finish (UsageReboot* self, GAsyncResult* _res_, GError** error);
static void usage_controller_reboot_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static void usage_controller_suspend_data_free (gpointer _data);
void usage_controller_suspend (UsageController* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void usage_controller_suspend_finish (UsageController* self, GAsyncResult* _res_, GError** error);
static gboolean usage_controller_suspend_co (UsageControllerSuspendData* _data_);
UsageSuspend* usage_suspend_new (void);
UsageSuspend* usage_suspend_construct (GType object_type);
GType usage_suspend_get_type (void) G_GNUC_CONST;
GType usage_suspend_register_type (GTypeModule * module);
void usage_suspend_run (UsageSuspend* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void usage_suspend_run_finish (UsageSuspend* self, GAsyncResult* _res_, GError** error);
static void usage_controller_suspend_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static void usage_controller_resume_data_free (gpointer _data);
void usage_controller_resume (UsageController* self, const gchar* source, const gchar* reason, GAsyncReadyCallback _callback_, gpointer _user_data_);
void usage_controller_resume_finish (UsageController* self, GAsyncResult* _res_, GError** error);
static gboolean usage_controller_resume_co (UsageControllerResumeData* _data_);
UsageResume* usage_resume_new (void);
UsageResume* usage_resume_construct (GType object_type);
GType usage_resume_get_type (void) G_GNUC_CONST;
GType usage_resume_register_type (GTypeModule * module);
void usage_resume_run (UsageResume* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void usage_resume_run_finish (UsageResume* self, GAsyncResult* _res_, GError** error);
static void usage_controller_resume_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static void g_cclosure_user_marshal_VOID__STRING_BOOLEAN (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void g_cclosure_user_marshal_VOID__STRING_BOOLEAN_BOXED (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void usage_controller_finalize (GObject* obj);
static void _dbus_usage_controller_register_resource (UsageController* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_usage_controller_unregister_resource (UsageController* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_usage_controller_updateSystemStatus (UsageController* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_usage_controller_get_resource_policy (UsageController* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_usage_controller_get_resource_policy_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_);
static void _dbus_usage_controller_set_resource_policy (UsageController* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_usage_controller_set_resource_policy_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_);
static void _dbus_usage_controller_get_resource_state (UsageController* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_usage_controller_get_resource_state_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_);
static void _dbus_usage_controller_get_resource_users (UsageController* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_usage_controller_get_resource_users_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_);
static void _dbus_usage_controller_list_resources (UsageController* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_usage_controller_list_resources_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_);
static void _dbus_usage_controller_request_resource (UsageController* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_usage_controller_request_resource_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_);
static void _dbus_usage_controller_release_resource (UsageController* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_usage_controller_release_resource_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_);
static void _dbus_usage_controller_shutdown (UsageController* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_usage_controller_shutdown_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_);
static void _dbus_usage_controller_reboot (UsageController* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_usage_controller_reboot_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_);
static void _dbus_usage_controller_suspend (UsageController* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_usage_controller_suspend_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_);
static void _dbus_usage_controller_resume (UsageController* self, GVariant* parameters, GDBusMethodInvocation* invocation);
static void _dbus_usage_controller_resume_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_);
static void usage_controller_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data);
static GVariant* usage_controller_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data);
static gboolean usage_controller_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data);
static void _dbus_usage_controller_resource_available (GObject* _sender, const gchar* name, gboolean availability, gpointer* _data);
static void _dbus_usage_controller_resource_changed (GObject* _sender, const gchar* name, gboolean state, GHashTable* attributes, gpointer* _data);
static void _dbus_usage_controller_system_action (GObject* _sender, FreeSmartphoneUsageSystemAction action, gpointer* _data);
static void _usage_controller_unregister_object (gpointer user_data);
gchar* fso_factory_function (FsoFrameworkSubsystem* subsystem, GError** error);
void fso_shutdown_function (void);
void fso_register_function (GTypeModule* module);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);

static const GDBusArgInfo _usage_controller_dbus_arg_info_register_resource_name = {-1, "name", "s"};
static const GDBusArgInfo _usage_controller_dbus_arg_info_register_resource_path = {-1, "path", "o"};
static const GDBusArgInfo * const _usage_controller_dbus_arg_info_register_resource_in[] = {&_usage_controller_dbus_arg_info_register_resource_name, &_usage_controller_dbus_arg_info_register_resource_path, NULL};
static const GDBusArgInfo * const _usage_controller_dbus_arg_info_register_resource_out[] = {NULL};
static const GDBusMethodInfo _usage_controller_dbus_method_info_register_resource = {-1, "RegisterResource", (GDBusArgInfo **) (&_usage_controller_dbus_arg_info_register_resource_in), (GDBusArgInfo **) (&_usage_controller_dbus_arg_info_register_resource_out)};
static const GDBusArgInfo _usage_controller_dbus_arg_info_unregister_resource_name = {-1, "name", "s"};
static const GDBusArgInfo * const _usage_controller_dbus_arg_info_unregister_resource_in[] = {&_usage_controller_dbus_arg_info_unregister_resource_name, NULL};
static const GDBusArgInfo * const _usage_controller_dbus_arg_info_unregister_resource_out[] = {NULL};
static const GDBusMethodInfo _usage_controller_dbus_method_info_unregister_resource = {-1, "UnregisterResource", (GDBusArgInfo **) (&_usage_controller_dbus_arg_info_unregister_resource_in), (GDBusArgInfo **) (&_usage_controller_dbus_arg_info_unregister_resource_out)};
static const GDBusArgInfo _usage_controller_dbus_arg_info_updateSystemStatus_action = {-1, "action", "s"};
static const GDBusArgInfo * const _usage_controller_dbus_arg_info_updateSystemStatus_in[] = {&_usage_controller_dbus_arg_info_updateSystemStatus_action, NULL};
static const GDBusArgInfo * const _usage_controller_dbus_arg_info_updateSystemStatus_out[] = {NULL};
static const GDBusMethodInfo _usage_controller_dbus_method_info_updateSystemStatus = {-1, "updateSystemStatus", (GDBusArgInfo **) (&_usage_controller_dbus_arg_info_updateSystemStatus_in), (GDBusArgInfo **) (&_usage_controller_dbus_arg_info_updateSystemStatus_out)};
static const GDBusArgInfo _usage_controller_dbus_arg_info_get_resource_policy_name = {-1, "name", "s"};
static const GDBusArgInfo _usage_controller_dbus_arg_info_get_resource_policy_result = {-1, "result", "s"};
static const GDBusArgInfo * const _usage_controller_dbus_arg_info_get_resource_policy_in[] = {&_usage_controller_dbus_arg_info_get_resource_policy_name, NULL};
static const GDBusArgInfo * const _usage_controller_dbus_arg_info_get_resource_policy_out[] = {&_usage_controller_dbus_arg_info_get_resource_policy_result, NULL};
static const GDBusMethodInfo _usage_controller_dbus_method_info_get_resource_policy = {-1, "GetResourcePolicy", (GDBusArgInfo **) (&_usage_controller_dbus_arg_info_get_resource_policy_in), (GDBusArgInfo **) (&_usage_controller_dbus_arg_info_get_resource_policy_out)};
static const GDBusArgInfo _usage_controller_dbus_arg_info_set_resource_policy_name = {-1, "name", "s"};
static const GDBusArgInfo _usage_controller_dbus_arg_info_set_resource_policy_policy = {-1, "policy", "s"};
static const GDBusArgInfo * const _usage_controller_dbus_arg_info_set_resource_policy_in[] = {&_usage_controller_dbus_arg_info_set_resource_policy_name, &_usage_controller_dbus_arg_info_set_resource_policy_policy, NULL};
static const GDBusArgInfo * const _usage_controller_dbus_arg_info_set_resource_policy_out[] = {NULL};
static const GDBusMethodInfo _usage_controller_dbus_method_info_set_resource_policy = {-1, "SetResourcePolicy", (GDBusArgInfo **) (&_usage_controller_dbus_arg_info_set_resource_policy_in), (GDBusArgInfo **) (&_usage_controller_dbus_arg_info_set_resource_policy_out)};
static const GDBusArgInfo _usage_controller_dbus_arg_info_get_resource_state_name = {-1, "name", "s"};
static const GDBusArgInfo _usage_controller_dbus_arg_info_get_resource_state_result = {-1, "result", "b"};
static const GDBusArgInfo * const _usage_controller_dbus_arg_info_get_resource_state_in[] = {&_usage_controller_dbus_arg_info_get_resource_state_name, NULL};
static const GDBusArgInfo * const _usage_controller_dbus_arg_info_get_resource_state_out[] = {&_usage_controller_dbus_arg_info_get_resource_state_result, NULL};
static const GDBusMethodInfo _usage_controller_dbus_method_info_get_resource_state = {-1, "GetResourceState", (GDBusArgInfo **) (&_usage_controller_dbus_arg_info_get_resource_state_in), (GDBusArgInfo **) (&_usage_controller_dbus_arg_info_get_resource_state_out)};
static const GDBusArgInfo _usage_controller_dbus_arg_info_get_resource_users_name = {-1, "name", "s"};
static const GDBusArgInfo _usage_controller_dbus_arg_info_get_resource_users_result = {-1, "result", "as"};
static const GDBusArgInfo * const _usage_controller_dbus_arg_info_get_resource_users_in[] = {&_usage_controller_dbus_arg_info_get_resource_users_name, NULL};
static const GDBusArgInfo * const _usage_controller_dbus_arg_info_get_resource_users_out[] = {&_usage_controller_dbus_arg_info_get_resource_users_result, NULL};
static const GDBusMethodInfo _usage_controller_dbus_method_info_get_resource_users = {-1, "GetResourceUsers", (GDBusArgInfo **) (&_usage_controller_dbus_arg_info_get_resource_users_in), (GDBusArgInfo **) (&_usage_controller_dbus_arg_info_get_resource_users_out)};
static const GDBusArgInfo _usage_controller_dbus_arg_info_list_resources_result = {-1, "result", "as"};
static const GDBusArgInfo * const _usage_controller_dbus_arg_info_list_resources_in[] = {NULL};
static const GDBusArgInfo * const _usage_controller_dbus_arg_info_list_resources_out[] = {&_usage_controller_dbus_arg_info_list_resources_result, NULL};
static const GDBusMethodInfo _usage_controller_dbus_method_info_list_resources = {-1, "ListResources", (GDBusArgInfo **) (&_usage_controller_dbus_arg_info_list_resources_in), (GDBusArgInfo **) (&_usage_controller_dbus_arg_info_list_resources_out)};
static const GDBusArgInfo _usage_controller_dbus_arg_info_request_resource_name = {-1, "name", "s"};
static const GDBusArgInfo * const _usage_controller_dbus_arg_info_request_resource_in[] = {&_usage_controller_dbus_arg_info_request_resource_name, NULL};
static const GDBusArgInfo * const _usage_controller_dbus_arg_info_request_resource_out[] = {NULL};
static const GDBusMethodInfo _usage_controller_dbus_method_info_request_resource = {-1, "RequestResource", (GDBusArgInfo **) (&_usage_controller_dbus_arg_info_request_resource_in), (GDBusArgInfo **) (&_usage_controller_dbus_arg_info_request_resource_out)};
static const GDBusArgInfo _usage_controller_dbus_arg_info_release_resource_name = {-1, "name", "s"};
static const GDBusArgInfo * const _usage_controller_dbus_arg_info_release_resource_in[] = {&_usage_controller_dbus_arg_info_release_resource_name, NULL};
static const GDBusArgInfo * const _usage_controller_dbus_arg_info_release_resource_out[] = {NULL};
static const GDBusMethodInfo _usage_controller_dbus_method_info_release_resource = {-1, "ReleaseResource", (GDBusArgInfo **) (&_usage_controller_dbus_arg_info_release_resource_in), (GDBusArgInfo **) (&_usage_controller_dbus_arg_info_release_resource_out)};
static const GDBusArgInfo * const _usage_controller_dbus_arg_info_shutdown_in[] = {NULL};
static const GDBusArgInfo * const _usage_controller_dbus_arg_info_shutdown_out[] = {NULL};
static const GDBusMethodInfo _usage_controller_dbus_method_info_shutdown = {-1, "Shutdown", (GDBusArgInfo **) (&_usage_controller_dbus_arg_info_shutdown_in), (GDBusArgInfo **) (&_usage_controller_dbus_arg_info_shutdown_out)};
static const GDBusArgInfo * const _usage_controller_dbus_arg_info_reboot_in[] = {NULL};
static const GDBusArgInfo * const _usage_controller_dbus_arg_info_reboot_out[] = {NULL};
static const GDBusMethodInfo _usage_controller_dbus_method_info_reboot = {-1, "Reboot", (GDBusArgInfo **) (&_usage_controller_dbus_arg_info_reboot_in), (GDBusArgInfo **) (&_usage_controller_dbus_arg_info_reboot_out)};
static const GDBusArgInfo * const _usage_controller_dbus_arg_info_suspend_in[] = {NULL};
static const GDBusArgInfo * const _usage_controller_dbus_arg_info_suspend_out[] = {NULL};
static const GDBusMethodInfo _usage_controller_dbus_method_info_suspend = {-1, "Suspend", (GDBusArgInfo **) (&_usage_controller_dbus_arg_info_suspend_in), (GDBusArgInfo **) (&_usage_controller_dbus_arg_info_suspend_out)};
static const GDBusArgInfo _usage_controller_dbus_arg_info_resume_source = {-1, "source", "s"};
static const GDBusArgInfo _usage_controller_dbus_arg_info_resume_reason = {-1, "reason", "s"};
static const GDBusArgInfo * const _usage_controller_dbus_arg_info_resume_in[] = {&_usage_controller_dbus_arg_info_resume_source, &_usage_controller_dbus_arg_info_resume_reason, NULL};
static const GDBusArgInfo * const _usage_controller_dbus_arg_info_resume_out[] = {NULL};
static const GDBusMethodInfo _usage_controller_dbus_method_info_resume = {-1, "Resume", (GDBusArgInfo **) (&_usage_controller_dbus_arg_info_resume_in), (GDBusArgInfo **) (&_usage_controller_dbus_arg_info_resume_out)};
static const GDBusMethodInfo * const _usage_controller_dbus_method_info[] = {&_usage_controller_dbus_method_info_register_resource, &_usage_controller_dbus_method_info_unregister_resource, &_usage_controller_dbus_method_info_updateSystemStatus, &_usage_controller_dbus_method_info_get_resource_policy, &_usage_controller_dbus_method_info_set_resource_policy, &_usage_controller_dbus_method_info_get_resource_state, &_usage_controller_dbus_method_info_get_resource_users, &_usage_controller_dbus_method_info_list_resources, &_usage_controller_dbus_method_info_request_resource, &_usage_controller_dbus_method_info_release_resource, &_usage_controller_dbus_method_info_shutdown, &_usage_controller_dbus_method_info_reboot, &_usage_controller_dbus_method_info_suspend, &_usage_controller_dbus_method_info_resume, NULL};
static const GDBusArgInfo _usage_controller_dbus_arg_info_resource_available_name = {-1, "name", "s"};
static const GDBusArgInfo _usage_controller_dbus_arg_info_resource_available_availability = {-1, "availability", "b"};
static const GDBusArgInfo * const _usage_controller_dbus_arg_info_resource_available[] = {&_usage_controller_dbus_arg_info_resource_available_name, &_usage_controller_dbus_arg_info_resource_available_availability, NULL};
static const GDBusSignalInfo _usage_controller_dbus_signal_info_resource_available = {-1, "ResourceAvailable", (GDBusArgInfo **) (&_usage_controller_dbus_arg_info_resource_available)};
static const GDBusArgInfo _usage_controller_dbus_arg_info_resource_changed_name = {-1, "name", "s"};
static const GDBusArgInfo _usage_controller_dbus_arg_info_resource_changed_state = {-1, "state", "b"};
static const GDBusArgInfo _usage_controller_dbus_arg_info_resource_changed_attributes = {-1, "attributes", "a{sv}"};
static const GDBusArgInfo * const _usage_controller_dbus_arg_info_resource_changed[] = {&_usage_controller_dbus_arg_info_resource_changed_name, &_usage_controller_dbus_arg_info_resource_changed_state, &_usage_controller_dbus_arg_info_resource_changed_attributes, NULL};
static const GDBusSignalInfo _usage_controller_dbus_signal_info_resource_changed = {-1, "ResourceChanged", (GDBusArgInfo **) (&_usage_controller_dbus_arg_info_resource_changed)};
static const GDBusArgInfo _usage_controller_dbus_arg_info_system_action_action = {-1, "action", "s"};
static const GDBusArgInfo * const _usage_controller_dbus_arg_info_system_action[] = {&_usage_controller_dbus_arg_info_system_action_action, NULL};
static const GDBusSignalInfo _usage_controller_dbus_signal_info_system_action = {-1, "SystemAction", (GDBusArgInfo **) (&_usage_controller_dbus_arg_info_system_action)};
static const GDBusSignalInfo * const _usage_controller_dbus_signal_info[] = {&_usage_controller_dbus_signal_info_resource_available, &_usage_controller_dbus_signal_info_resource_changed, &_usage_controller_dbus_signal_info_system_action, NULL};
static const GDBusPropertyInfo * const _usage_controller_dbus_property_info[] = {NULL};
static const GDBusInterfaceInfo _usage_controller_dbus_interface_info = {-1, "org.freesmartphone.Usage", (GDBusMethodInfo **) (&_usage_controller_dbus_method_info), (GDBusSignalInfo **) (&_usage_controller_dbus_signal_info), (GDBusPropertyInfo **) (&_usage_controller_dbus_property_info)};
static const GDBusInterfaceVTable _usage_controller_dbus_interface_vtable = {usage_controller_dbus_interface_method_call, usage_controller_dbus_interface_get_property, usage_controller_dbus_interface_set_property};

static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _usage_controller_onNameOwnerChanged_dbus_service_id_bus_name_owner_changed (DBusServiceIDBus* _sender, const gchar* name, const gchar* oldowner, const gchar* newowner, gpointer self) {
	usage_controller_onNameOwnerChanged (self, name, oldowner, newowner);
}


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


static gboolean __lambda2_ (UsageController* self) {
	gboolean result = FALSE;
	usage_controller_updateSystemStatus (self, FREE_SMARTPHONE_USAGE_SYSTEM_ACTION_ALIVE);
	result = FALSE;
	return result;
}


static gboolean ___lambda2__gsource_func (gpointer self) {
	gboolean result;
	result = __lambda2_ (self);
	return result;
}


UsageController* usage_controller_construct (GType object_type, FsoFrameworkSubsystem* subsystem) {
	UsageController * self = NULL;
	FsoFrameworkSubsystem* _tmp0_;
	FsoFrameworkSubsystem* _tmp1_;
	FsoFrameworkSubsystem* _tmp2_;
	FsoFrameworkSmartKeyFile* _tmp3_;
	gboolean _tmp4_ = FALSE;
	FsoFrameworkSmartKeyFile* _tmp5_;
	gboolean _tmp6_ = FALSE;
	FsoFrameworkSmartKeyFile* _tmp7_;
	gboolean _tmp8_ = FALSE;
	FsoFrameworkSmartKeyFile* _tmp9_;
	gboolean _tmp10_ = FALSE;
	gboolean _tmp11_;
	FsoFrameworkSmartKeyFile* _tmp13_;
	gchar* _tmp14_ = NULL;
	gchar* sync_resources_with_lifecycle;
	gboolean _tmp15_ = FALSE;
	const gchar* _tmp16_;
	gboolean _tmp18_;
	gboolean _tmp19_ = FALSE;
	const gchar* _tmp20_;
	gboolean _tmp22_;
	FsoFrameworkSmartKeyFile* _tmp35_;
	gboolean _tmp36_ = FALSE;
	gboolean useShadowing;
	gboolean _tmp37_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (subsystem != NULL, NULL);
	self = (UsageController*) fso_framework_abstract_object_construct (object_type);
	self->priv->system_status = (FreeSmartphoneUsageSystemAction) 12345;
	_tmp0_ = subsystem;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->subsystem);
	self->priv->subsystem = _tmp1_;
	_tmp2_ = self->priv->subsystem;
	fso_framework_subsystem_registerObjectForService (_tmp2_, USAGE_TYPE_CONTROLLER, (GBoxedCopyFunc) g_object_ref, g_object_unref, FSO_FRAMEWORK_USAGE_ServiceDBusName, FSO_FRAMEWORK_USAGE_ServicePathPrefix, self);
	_tmp3_ = ((FsoFrameworkAbstractObject*) self)->config;
	_tmp4_ = fso_framework_smart_key_file_boolValue (_tmp3_, CONFIG_SECTION, "debug_enable_on_startup", FALSE);
	self->priv->debug_enable_on_startup = _tmp4_;
	_tmp5_ = ((FsoFrameworkAbstractObject*) self)->config;
	_tmp6_ = fso_framework_smart_key_file_boolValue (_tmp5_, CONFIG_SECTION, "debug_do_not_suspend", FALSE);
	self->priv->debug_do_not_suspend = _tmp6_;
	_tmp7_ = ((FsoFrameworkAbstractObject*) self)->config;
	_tmp8_ = fso_framework_smart_key_file_boolValue (_tmp7_, CONFIG_SECTION, "debug_suspend_user_initiated", TRUE);
	self->priv->debug_suspend_user_initiated = _tmp8_;
	_tmp9_ = ((FsoFrameworkAbstractObject*) self)->config;
	_tmp10_ = fso_framework_smart_key_file_boolValue (_tmp9_, CONFIG_SECTION, "wakelock_support", FALSE);
	self->priv->wakelock_support = _tmp10_;
	_tmp11_ = self->priv->wakelock_support;
	if (_tmp11_) {
		FsoFrameworkLogger* _tmp12_;
		_tmp12_ = ((FsoFrameworkAbstractObject*) self)->logger;
		fso_framework_logger_info (_tmp12_, "Running with wakelock support enabled");
	}
	_tmp13_ = ((FsoFrameworkAbstractObject*) self)->config;
	_tmp14_ = fso_framework_smart_key_file_stringValue (_tmp13_, CONFIG_SECTION, "sync_resources_with_lifecycle", "always");
	sync_resources_with_lifecycle = _tmp14_;
	_tmp16_ = sync_resources_with_lifecycle;
	if (g_strcmp0 (_tmp16_, "always") == 0) {
		_tmp15_ = TRUE;
	} else {
		const gchar* _tmp17_;
		_tmp17_ = sync_resources_with_lifecycle;
		_tmp15_ = g_strcmp0 (_tmp17_, "startup") == 0;
	}
	_tmp18_ = _tmp15_;
	self->priv->disable_on_startup = _tmp18_;
	_tmp20_ = sync_resources_with_lifecycle;
	if (g_strcmp0 (_tmp20_, "always") == 0) {
		_tmp19_ = TRUE;
	} else {
		const gchar* _tmp21_;
		_tmp21_ = sync_resources_with_lifecycle;
		_tmp19_ = g_strcmp0 (_tmp21_, "shutdown") == 0;
	}
	_tmp22_ = _tmp19_;
	self->priv->disable_on_shutdown = _tmp22_;
	{
		DBusServiceIDBus* _tmp23_ = NULL;
		DBusServiceIDBus* _tmp24_;
		DBusServiceIDBus* _tmp25_;
		_tmp23_ = g_initable_new (DBUS_SERVICE_TYPE_ID_BUS_PROXY, NULL, &_inner_error_, "g-flags", 0, "g-name", DBUS_SERVICE_DBUS_SERVICE_DBUS, "g-bus-type", G_BUS_TYPE_SYSTEM, "g-object-path", DBUS_SERVICE_DBUS_PATH_DBUS, "g-interface-name", "org.freedesktop.DBus", NULL);
		_tmp24_ = (DBusServiceIDBus*) _tmp23_;
		if (_inner_error_ != NULL) {
			goto __catch8_g_error;
		}
		_g_object_unref0 (self->priv->dbus);
		self->priv->dbus = _tmp24_;
		_tmp25_ = self->priv->dbus;
		g_signal_connect_object (_tmp25_, "name-owner-changed", (GCallback) _usage_controller_onNameOwnerChanged_dbus_service_id_bus_name_owner_changed, self, 0);
	}
	goto __finally8;
	__catch8_g_error:
	{
		GError* err0 = NULL;
		FsoFrameworkLogger* _tmp26_;
		GError* _tmp27_;
		const gchar* _tmp28_;
		const gchar* _tmp29_ = NULL;
		gchar* _tmp30_ = NULL;
		gchar* _tmp31_;
		err0 = _inner_error_;
		_inner_error_ = NULL;
		_tmp26_ = ((FsoFrameworkAbstractObject*) self)->logger;
		_tmp27_ = err0;
		_tmp28_ = _tmp27_->message;
		_tmp29_ = string_to_string (_tmp28_);
		_tmp30_ = g_strconcat ("Can't setup up dbus connection for listener of name ownr changes: ", _tmp29_, NULL);
		_tmp31_ = _tmp30_;
		fso_framework_logger_critical (_tmp26_, _tmp31_);
		_g_free0 (_tmp31_);
		_g_error_free0 (err0);
	}
	__finally8:
	if (_inner_error_ != NULL) {
		_g_free0 (sync_resources_with_lifecycle);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	{
		FreeSmartphoneDeviceIdleNotifier* _tmp32_ = NULL;
		FreeSmartphoneDeviceIdleNotifier* _tmp33_;
		_tmp32_ = g_initable_new (FREE_SMARTPHONE_DEVICE_TYPE_IDLE_NOTIFIER_PROXY, NULL, &_inner_error_, "g-flags", G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START, "g-name", FSO_IDLENOTIFIER_BUS, "g-bus-type", G_BUS_TYPE_SYSTEM, "g-object-path", FSO_IDLENOTIFIER_PATH, "g-interface-name", "org.freesmartphone.Device.IdleNotifier", NULL);
		_tmp33_ = (FreeSmartphoneDeviceIdleNotifier*) _tmp32_;
		if (_inner_error_ != NULL) {
			goto __catch9_g_error;
		}
		_g_object_unref0 (self->priv->idlenotifier);
		self->priv->idlenotifier = _tmp33_;
	}
	goto __finally9;
	__catch9_g_error:
	{
		GError* err1 = NULL;
		FsoFrameworkLogger* _tmp34_;
		err1 = _inner_error_;
		_inner_error_ = NULL;
		_tmp34_ = ((FsoFrameworkAbstractObject*) self)->logger;
		fso_framework_logger_error (_tmp34_, "Can't get a dbus connection for the idle notifier. Will lack functiona" \
"lity ...");
		_g_error_free0 (err1);
	}
	__finally9:
	if (_inner_error_ != NULL) {
		_g_free0 (sync_resources_with_lifecycle);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	usage_controller_initResources (self);
	usage_controller_initLowlevel (self);
	_tmp35_ = ((FsoFrameworkAbstractObject*) self)->config;
	_tmp36_ = fso_framework_smart_key_file_boolValue (_tmp35_, CONFIG_SECTION, "enable_shadow_resources", FALSE);
	useShadowing = _tmp36_;
	_tmp37_ = useShadowing;
	if (_tmp37_) {
		usage_controller_scanForResourceProviders (self);
	}
	g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, ___lambda2__gsource_func, g_object_ref (self), g_object_unref);
	_g_free0 (sync_resources_with_lifecycle);
	return self;
}


UsageController* usage_controller_new (FsoFrameworkSubsystem* subsystem) {
	return usage_controller_construct (USAGE_TYPE_CONTROLLER, subsystem);
}


static gchar* usage_controller_real_repr (FsoFrameworkAbstractObject* base) {
	UsageController * self;
	gchar* result = NULL;
	GeeHashMap* _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_;
	self = (UsageController*) base;
	_tmp0_ = self->priv->resources;
	_tmp1_ = gee_abstract_map_get_size ((GeeMap*) _tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strdup_printf ("%i", _tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = g_strconcat ("<", _tmp4_, " R>", NULL);
	_tmp6_ = _tmp5_;
	_g_free0 (_tmp4_);
	result = _tmp6_;
	return result;
}


static void usage_controller_initResources (UsageController* self) {
	GeeHashMap* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->resources;
	gee_abstract_map_clear ((GeeAbstractMap*) _tmp0_);
}


/**
     * Create the lowlevel handler as configuration requests.
     **/
static void usage_controller_initLowlevel (UsageController* self) {
	FsoFrameworkSmartKeyFile* _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* lowleveltype;
	gchar* _tmp2_;
	gchar* typename;
	const gchar* _tmp3_;
	const gchar* _tmp4_;
	GQuark _tmp6_ = 0U;
	static GQuark _tmp5_label0 = 0;
	static GQuark _tmp5_label1 = 0;
	static GQuark _tmp5_label2 = 0;
	static GQuark _tmp5_label3 = 0;
	const gchar* _tmp17_;
	g_return_if_fail (self != NULL);
	_tmp0_ = ((FsoFrameworkAbstractObject*) self)->config;
	_tmp1_ = fso_framework_smart_key_file_stringValue (_tmp0_, CONFIG_SECTION, "lowlevel_type", DEFAULT_LOWLEVEL_MODULE);
	lowleveltype = _tmp1_;
	_tmp2_ = g_strdup ("none");
	typename = _tmp2_;
	_tmp3_ = lowleveltype;
	_tmp4_ = _tmp3_;
	_tmp6_ = (NULL == _tmp4_) ? 0 : g_quark_from_string (_tmp4_);
	if (_tmp6_ == ((0 != _tmp5_label0) ? _tmp5_label0 : (_tmp5_label0 = g_quark_from_static_string ("android")))) {
		switch (0) {
			default:
			{
				gchar* _tmp7_;
				_tmp7_ = g_strdup ("LowLevelAndroid");
				_g_free0 (typename);
				typename = _tmp7_;
				break;
			}
		}
	} else if (_tmp6_ == ((0 != _tmp5_label1) ? _tmp5_label1 : (_tmp5_label1 = g_quark_from_static_string ("kernel26")))) {
		switch (0) {
			default:
			{
				gchar* _tmp8_;
				_tmp8_ = g_strdup ("LowLevelKernel26");
				_g_free0 (typename);
				typename = _tmp8_;
				break;
			}
		}
	} else if (_tmp6_ == ((0 != _tmp5_label2) ? _tmp5_label2 : (_tmp5_label2 = g_quark_from_static_string ("kernel26_staysalive")))) {
		switch (0) {
			default:
			{
				gchar* _tmp9_;
				_tmp9_ = g_strdup ("LowLevelKernel26_StaysAlive");
				_g_free0 (typename);
				typename = _tmp9_;
				break;
			}
		}
	} else if (_tmp6_ == ((0 != _tmp5_label3) ? _tmp5_label3 : (_tmp5_label3 = g_quark_from_static_string ("openmoko")))) {
		switch (0) {
			default:
			{
				gchar* _tmp10_;
				_tmp10_ = g_strdup ("LowLevelOpenmoko");
				_g_free0 (typename);
				typename = _tmp10_;
				break;
			}
		}
	} else {
		switch (0) {
			default:
			{
				FsoFrameworkLogger* _tmp11_;
				const gchar* _tmp12_;
				const gchar* _tmp13_ = NULL;
				gchar* _tmp14_ = NULL;
				gchar* _tmp15_;
				FsoUsageNullLowLevel* _tmp16_;
				_tmp11_ = ((FsoFrameworkAbstractObject*) self)->logger;
				_tmp12_ = lowleveltype;
				_tmp13_ = string_to_string (_tmp12_);
				_tmp14_ = g_strconcat ("Invalid lowlevel_type ", _tmp13_, "; suspend/resume will NOT be available!", NULL);
				_tmp15_ = _tmp14_;
				fso_framework_logger_warning (_tmp11_, _tmp15_);
				_g_free0 (_tmp15_);
				_tmp16_ = fso_usage_null_low_level_new ();
				_g_object_unref0 (self->priv->lowlevel);
				self->priv->lowlevel = (FsoUsageLowLevel*) _tmp16_;
				_g_free0 (typename);
				_g_free0 (lowleveltype);
				return;
			}
		}
	}
	_tmp17_ = lowleveltype;
	if (g_strcmp0 (_tmp17_, "none") != 0) {
		const gchar* _tmp18_;
		GType _tmp19_ = 0UL;
		GType lowlevelclass;
		GType _tmp20_;
		GType _tmp27_;
		GObject* _tmp28_ = NULL;
		GObject* _tmp29_;
		FsoFrameworkLogger* _tmp30_;
		const gchar* _tmp31_;
		const gchar* _tmp32_ = NULL;
		gchar* _tmp33_ = NULL;
		gchar* _tmp34_;
		_tmp18_ = typename;
		_tmp19_ = g_type_from_name (_tmp18_);
		lowlevelclass = _tmp19_;
		_tmp20_ = lowlevelclass;
		if (_tmp20_ == G_TYPE_INVALID) {
			FsoFrameworkLogger* _tmp21_;
			const gchar* _tmp22_;
			const gchar* _tmp23_ = NULL;
			gchar* _tmp24_ = NULL;
			gchar* _tmp25_;
			FsoUsageNullLowLevel* _tmp26_;
			_tmp21_ = ((FsoFrameworkAbstractObject*) self)->logger;
			_tmp22_ = lowleveltype;
			_tmp23_ = string_to_string (_tmp22_);
			_tmp24_ = g_strconcat ("Can't find plugin for lowlevel_type ", _tmp23_, "; suspend/resume will NOT be available!", NULL);
			_tmp25_ = _tmp24_;
			fso_framework_logger_warning (_tmp21_, _tmp25_);
			_g_free0 (_tmp25_);
			_tmp26_ = fso_usage_null_low_level_new ();
			_g_object_unref0 (self->priv->lowlevel);
			self->priv->lowlevel = (FsoUsageLowLevel*) _tmp26_;
			_g_free0 (typename);
			_g_free0 (lowleveltype);
			return;
		}
		_tmp27_ = lowlevelclass;
		_tmp28_ = g_object_new (_tmp27_, NULL);
		_tmp29_ = G_IS_INITIALLY_UNOWNED (_tmp28_) ? g_object_ref_sink (_tmp28_) : _tmp28_;
		_g_object_unref0 (self->priv->lowlevel);
		self->priv->lowlevel = FSO_USAGE_IS_LOW_LEVEL (_tmp29_) ? ((FsoUsageLowLevel*) _tmp29_) : NULL;
		_tmp30_ = ((FsoFrameworkAbstractObject*) self)->logger;
		_tmp31_ = lowleveltype;
		_tmp32_ = string_to_string (_tmp31_);
		_tmp33_ = g_strconcat ("Ready. Using lowlevel plugin ", _tmp32_, " to handle suspend/resume", NULL);
		_tmp34_ = _tmp33_;
		fso_framework_logger_info (_tmp30_, _tmp34_);
		_g_free0 (_tmp34_);
	}
	_g_free0 (typename);
	_g_free0 (lowleveltype);
}


/**
     * Search for shadow resource providers in the dbus system service dir. Each entry as
     * a FSO-provides-resources entry if it provides a resource.
     **/
static gchar* string_replace (const gchar* self, const gchar* old, const gchar* replacement) {
	gchar* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	{
		const gchar* _tmp0_;
		gchar* _tmp1_ = NULL;
		gchar* _tmp2_;
		GRegex* _tmp3_;
		GRegex* _tmp4_;
		GRegex* regex;
		GRegex* _tmp5_;
		const gchar* _tmp6_;
		gchar* _tmp7_ = NULL;
		gchar* _tmp8_;
		_tmp0_ = old;
		_tmp1_ = g_regex_escape_string (_tmp0_, -1);
		_tmp2_ = _tmp1_;
		_tmp3_ = g_regex_new (_tmp2_, 0, 0, &_inner_error_);
		_tmp4_ = _tmp3_;
		_g_free0 (_tmp2_);
		regex = _tmp4_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch11_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp5_ = regex;
		_tmp6_ = replacement;
		_tmp7_ = g_regex_replace_literal (_tmp5_, self, (gssize) (-1), 0, _tmp6_, 0, &_inner_error_);
		_tmp8_ = _tmp7_;
		if (_inner_error_ != NULL) {
			_g_regex_unref0 (regex);
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch11_g_regex_error;
			}
			_g_regex_unref0 (regex);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		result = _tmp8_;
		_g_regex_unref0 (regex);
		return result;
	}
	goto __finally11;
	__catch11_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally11:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
}


static void usage_controller_scanForResourceProviders (UsageController* self) {
	FsoFrameworkLogger* _tmp0_;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	gboolean _tmp4_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = ((FsoFrameworkAbstractObject*) self)->logger;
	_tmp1_ = string_to_string (DBUS_SYSTEM_SERVICE_DIR);
	_tmp2_ = g_strconcat ("Scanning for resource providers in ", _tmp1_, NULL);
	_tmp3_ = _tmp2_;
	_tmp4_ = fso_framework_logger_debug (_tmp0_, _tmp3_);
	g_assert (_tmp4_);
	_g_free0 (_tmp3_);
	{
		GDir* _tmp5_ = NULL;
		GDir* dir;
		_tmp5_ = g_dir_open (DBUS_SYSTEM_SERVICE_DIR, (guint) 0, &_inner_error_);
		dir = _tmp5_;
		if (_inner_error_ != NULL) {
			goto __catch10_g_error;
		}
		{
			GDir* _tmp6_;
			const gchar* _tmp7_ = NULL;
			gchar* _tmp8_;
			gchar* name;
			_tmp6_ = dir;
			_tmp7_ = g_dir_read_name (_tmp6_);
			_tmp8_ = g_strdup (_tmp7_);
			name = _tmp8_;
			{
				gboolean _tmp9_;
				_tmp9_ = TRUE;
				while (TRUE) {
					gboolean _tmp10_;
					const gchar* _tmp14_;
					const gchar* _tmp15_;
					gboolean _tmp16_ = FALSE;
					_tmp10_ = _tmp9_;
					if (!_tmp10_) {
						GDir* _tmp11_;
						const gchar* _tmp12_ = NULL;
						gchar* _tmp13_;
						_tmp11_ = dir;
						_tmp12_ = g_dir_read_name (_tmp11_);
						_tmp13_ = g_strdup (_tmp12_);
						_g_free0 (name);
						name = _tmp13_;
					}
					_tmp9_ = FALSE;
					_tmp14_ = name;
					if (!(_tmp14_ != NULL)) {
						break;
					}
					_tmp15_ = name;
					_tmp16_ = g_str_has_suffix (_tmp15_, ".service");
					if (_tmp16_) {
						FsoFrameworkSmartKeyFile* _tmp17_;
						FsoFrameworkSmartKeyFile* smk;
						FsoFrameworkSmartKeyFile* _tmp18_;
						const gchar* _tmp19_;
						gchar* _tmp20_ = NULL;
						gchar* _tmp21_;
						gboolean _tmp22_ = FALSE;
						gboolean _tmp23_;
						_tmp17_ = fso_framework_smart_key_file_new ();
						smk = _tmp17_;
						_tmp18_ = smk;
						_tmp19_ = name;
						_tmp20_ = g_build_filename (DBUS_SYSTEM_SERVICE_DIR, _tmp19_, NULL);
						_tmp21_ = _tmp20_;
						_tmp22_ = fso_framework_smart_key_file_loadFromFile (_tmp18_, _tmp21_);
						_tmp23_ = _tmp22_;
						_g_free0 (_tmp21_);
						if (_tmp23_) {
							FsoFrameworkSmartKeyFile* _tmp24_;
							gchar** _tmp25_ = NULL;
							gchar** _tmp26_;
							gint _tmp26__length1;
							gint _tmp27_ = 0;
							gchar** _tmp28_ = NULL;
							gchar** _tmp29_;
							gint _tmp29__length1;
							gchar** fsoresources;
							gint fsoresources_length1;
							gint _fsoresources_size_;
							gchar** _tmp30_;
							gint _tmp30__length1;
							_tmp24_ = smk;
							_tmp25_ = g_new0 (gchar*, 0 + 1);
							_tmp26_ = _tmp25_;
							_tmp26__length1 = 0;
							_tmp28_ = fso_framework_smart_key_file_stringListValue (_tmp24_, FSO_DBUS_RESOURCE_PROVIDER_SECTION, FSO_DBUS_RESOURCE_PROVIDER_KEY, _tmp26_, 0, &_tmp27_);
							_tmp29_ = _tmp28_;
							_tmp29__length1 = _tmp27_;
							_tmp26_ = (_vala_array_free (_tmp26_, _tmp26__length1, (GDestroyNotify) g_free), NULL);
							fsoresources = _tmp29_;
							fsoresources_length1 = _tmp29__length1;
							_fsoresources_size_ = fsoresources_length1;
							_tmp30_ = fsoresources;
							_tmp30__length1 = fsoresources_length1;
							if (_tmp30__length1 > 0) {
								gchar** _tmp31_;
								gint _tmp31__length1;
								_tmp31_ = fsoresources;
								_tmp31__length1 = fsoresources_length1;
								{
									gchar** resource_collection = NULL;
									gint resource_collection_length1 = 0;
									gint _resource_collection_size_ = 0;
									gint resource_it = 0;
									resource_collection = _tmp31_;
									resource_collection_length1 = _tmp31__length1;
									for (resource_it = 0; resource_it < _tmp31__length1; resource_it = resource_it + 1) {
										gchar* _tmp32_;
										gchar* resource = NULL;
										_tmp32_ = g_strdup (resource_collection[resource_it]);
										resource = _tmp32_;
										{
											FsoFrameworkLogger* _tmp33_;
											const gchar* _tmp34_;
											const gchar* _tmp35_ = NULL;
											const gchar* _tmp36_;
											const gchar* _tmp37_ = NULL;
											gchar* _tmp38_ = NULL;
											gchar* _tmp39_;
											gboolean _tmp40_ = FALSE;
											GeeHashMap* _tmp41_;
											GeeSet* _tmp42_;
											GeeSet* _tmp43_;
											GeeSet* _tmp44_;
											const gchar* _tmp45_;
											gboolean _tmp46_ = FALSE;
											gboolean _tmp47_;
											_tmp33_ = ((FsoFrameworkAbstractObject*) self)->logger;
											_tmp34_ = name;
											_tmp35_ = string_to_string (_tmp34_);
											_tmp36_ = resource;
											_tmp37_ = string_to_string (_tmp36_);
											_tmp38_ = g_strconcat ("Service ", _tmp35_, " claims to provide FSO resource ", _tmp37_, NULL);
											_tmp39_ = _tmp38_;
											_tmp40_ = fso_framework_logger_debug (_tmp33_, _tmp39_);
											g_assert (_tmp40_);
											_g_free0 (_tmp39_);
											_tmp41_ = self->priv->resources;
											_tmp42_ = gee_abstract_map_get_keys ((GeeMap*) _tmp41_);
											_tmp43_ = _tmp42_;
											_tmp44_ = _tmp43_;
											_tmp45_ = resource;
											_tmp46_ = gee_collection_contains ((GeeCollection*) _tmp44_, _tmp45_);
											_tmp47_ = _tmp46_;
											_g_object_unref0 (_tmp44_);
											if (_tmp47_) {
												FsoFrameworkLogger* _tmp48_;
												const gchar* _tmp49_;
												const gchar* _tmp50_ = NULL;
												gchar* _tmp51_ = NULL;
												gchar* _tmp52_;
												gboolean _tmp53_ = FALSE;
												_tmp48_ = ((FsoFrameworkAbstractObject*) self)->logger;
												_tmp49_ = resource;
												_tmp50_ = string_to_string (_tmp49_);
												_tmp51_ = g_strconcat ("Skipping resource ", _tmp50_, " which has already been registered", NULL);
												_tmp52_ = _tmp51_;
												_tmp53_ = fso_framework_logger_debug (_tmp48_, _tmp52_);
												g_assert (_tmp53_);
												_g_free0 (_tmp52_);
											} else {
												const gchar* _tmp54_;
												const gchar* _tmp55_;
												gchar* _tmp56_ = NULL;
												gchar* _tmp57_;
												char* _tmp58_;
												char* _tmp59_;
												UsageResource* _tmp60_;
												UsageResource* _tmp61_;
												UsageResource* r;
												GeeHashMap* _tmp62_;
												const gchar* _tmp63_;
												UsageResource* _tmp64_;
												_tmp54_ = resource;
												_tmp55_ = name;
												_tmp56_ = string_replace (_tmp55_, ".service", "");
												_tmp57_ = _tmp56_;
												_tmp58_ = g_strdup (_tmp57_);
												_tmp59_ = _tmp58_;
												_tmp60_ = usage_resource_new (_tmp54_, _tmp59_, NULL);
												_tmp61_ = _tmp60_;
												_g_free0 (_tmp59_);
												_g_free0 (_tmp57_);
												r = _tmp61_;
												_tmp62_ = self->priv->resources;
												_tmp63_ = resource;
												_tmp64_ = r;
												gee_abstract_map_set ((GeeAbstractMap*) _tmp62_, _tmp63_, _tmp64_);
												_g_object_unref0 (r);
											}
											_g_free0 (resource);
										}
									}
								}
							} else {
								FsoFrameworkLogger* _tmp65_;
								const gchar* _tmp66_;
								const gchar* _tmp67_ = NULL;
								gchar* _tmp68_ = NULL;
								gchar* _tmp69_;
								gboolean _tmp70_ = FALSE;
								_tmp65_ = ((FsoFrameworkAbstractObject*) self)->logger;
								_tmp66_ = name;
								_tmp67_ = string_to_string (_tmp66_);
								_tmp68_ = g_strconcat ("Service ", _tmp67_, " does not provide any FSO resources", NULL);
								_tmp69_ = _tmp68_;
								_tmp70_ = fso_framework_logger_debug (_tmp65_, _tmp69_);
								g_assert (_tmp70_);
								_g_free0 (_tmp69_);
							}
							fsoresources = (_vala_array_free (fsoresources, fsoresources_length1, (GDestroyNotify) g_free), NULL);
						}
						_g_object_unref0 (smk);
					}
				}
			}
			_g_free0 (name);
		}
		_g_dir_close0 (dir);
	}
	goto __finally10;
	__catch10_g_error:
	{
		GError* _error_ = NULL;
		FsoFrameworkLogger* _tmp71_;
		GError* _tmp72_;
		const gchar* _tmp73_;
		const gchar* _tmp74_ = NULL;
		gchar* _tmp75_ = NULL;
		gchar* _tmp76_;
		_error_ = _inner_error_;
		_inner_error_ = NULL;
		_tmp71_ = ((FsoFrameworkAbstractObject*) self)->logger;
		_tmp72_ = _error_;
		_tmp73_ = _tmp72_->message;
		_tmp74_ = string_to_string (_tmp73_);
		_tmp75_ = g_strconcat ("Could not detect all shadow resources from service configuration files" \
": ", _tmp74_, NULL);
		_tmp76_ = _tmp75_;
		fso_framework_logger_error (_tmp71_, _tmp76_);
		_g_free0 (_tmp76_);
		_g_error_free0 (_error_);
	}
	__finally10:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void usage_controller_onResourceAppearing_data_free (gpointer _data) {
	usage_controller_onResourceAppearingData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->r);
	_g_object_unref0 (_data_->self);
	g_slice_free (usage_controller_onResourceAppearingData, _data_);
}


static void usage_controller_onResourceAppearing (UsageController* self, UsageResource* r, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	usage_controller_onResourceAppearingData* _data_;
	UsageController* _tmp0_;
	UsageResource* _tmp1_;
	UsageResource* _tmp2_;
	_data_ = g_slice_new0 (usage_controller_onResourceAppearingData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, usage_controller_onResourceAppearing);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, usage_controller_onResourceAppearing_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = r;
	_tmp2_ = _g_object_ref0 (_tmp1_);
	_data_->r = _tmp2_;
	usage_controller_onResourceAppearing_co (_data_);
}


static void usage_controller_onResourceAppearing_finish (UsageController* self, GAsyncResult* _res_) {
	usage_controller_onResourceAppearingData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


/**
     * Handle a resource appearing on the bus. This will send out a notification and
     * enable or disables the resource depending on which debug option is set.
     **/
static void usage_controller_onResourceAppearing_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	usage_controller_onResourceAppearingData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	usage_controller_onResourceAppearing_co (_data_);
}


static gboolean usage_controller_onResourceAppearing_co (usage_controller_onResourceAppearingData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		case 2:
		goto _state_2;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = ((FsoFrameworkAbstractObject*) _data_->self)->logger;
	_data_->_tmp1_ = _data_->r;
	_data_->_tmp2_ = usage_resource_get_name (_data_->_tmp1_);
	_data_->_tmp3_ = _data_->_tmp2_;
	_data_->_tmp4_ = NULL;
	_data_->_tmp4_ = string_to_string (_data_->_tmp3_);
	_data_->_tmp5_ = _data_->r;
	_data_->_tmp6_ = usage_resource_get_busname (_data_->_tmp5_);
	_data_->_tmp7_ = _data_->_tmp6_;
	_data_->_tmp8_ = NULL;
	_data_->_tmp8_ = string_to_string ((const gchar*) _data_->_tmp7_);
	_data_->_tmp9_ = _data_->r;
	_data_->_tmp10_ = usage_resource_get_objectpath (_data_->_tmp9_);
	_data_->_tmp11_ = _data_->_tmp10_;
	_data_->_tmp12_ = NULL;
	_data_->_tmp12_ = string_to_string ((const gchar*) _data_->_tmp11_);
	_data_->_tmp13_ = NULL;
	_data_->_tmp13_ = g_strconcat ("Resource ", _data_->_tmp4_, " served by ", _data_->_tmp8_, " @ ", _data_->_tmp12_, " has just been registered", NULL);
	_data_->_tmp14_ = _data_->_tmp13_;
	_data_->_tmp15_ = FALSE;
	_data_->_tmp15_ = fso_framework_logger_debug (_data_->_tmp0_, _data_->_tmp14_);
	g_assert (_data_->_tmp15_);
	_g_free0 (_data_->_tmp14_);
	_data_->_tmp16_ = _data_->r;
	_data_->_tmp17_ = usage_resource_get_name (_data_->_tmp16_);
	_data_->_tmp18_ = _data_->_tmp17_;
	g_signal_emit_by_name (_data_->self, "resource-available", _data_->_tmp18_, TRUE);
	_data_->_tmp19_ = _data_->self->priv->debug_enable_on_startup;
	if (_data_->_tmp19_) {
		{
			_data_->_tmp20_ = _data_->r;
			_data_->_state_ = 1;
			usage_resource_enable (_data_->_tmp20_, usage_controller_onResourceAppearing_ready, _data_);
			return FALSE;
			_state_1:
			usage_resource_enable_finish (_data_->_tmp20_, _data_->_res_, &_data_->_inner_error_);
			if (_data_->_inner_error_ != NULL) {
				goto __catch12_g_error;
			}
		}
		goto __finally12;
		__catch12_g_error:
		{
			_data_->e0 = _data_->_inner_error_;
			_data_->_inner_error_ = NULL;
			_data_->_tmp21_ = ((FsoFrameworkAbstractObject*) _data_->self)->logger;
			_data_->_tmp22_ = _data_->r;
			_data_->_tmp23_ = usage_resource_get_name (_data_->_tmp22_);
			_data_->_tmp24_ = _data_->_tmp23_;
			_data_->_tmp25_ = NULL;
			_data_->_tmp25_ = string_to_string (_data_->_tmp24_);
			_data_->_tmp26_ = _data_->e0;
			_data_->_tmp27_ = _data_->_tmp26_->message;
			_data_->_tmp28_ = NULL;
			_data_->_tmp28_ = string_to_string (_data_->_tmp27_);
			_data_->_tmp29_ = NULL;
			_data_->_tmp29_ = g_strconcat ("Error while trying to (initially) enable resource ", _data_->_tmp25_, ": ", _data_->_tmp28_, NULL);
			_data_->_tmp30_ = _data_->_tmp29_;
			fso_framework_logger_warning (_data_->_tmp21_, _data_->_tmp30_);
			_g_free0 (_data_->_tmp30_);
			_g_error_free0 (_data_->e0);
		}
		__finally12:
		if (_data_->_inner_error_ != NULL) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
	}
	_data_->_tmp31_ = _data_->self->priv->disable_on_startup;
	if (_data_->_tmp31_) {
		{
			_data_->_tmp32_ = _data_->r;
			_data_->_state_ = 2;
			usage_resource_disable (_data_->_tmp32_, usage_controller_onResourceAppearing_ready, _data_);
			return FALSE;
			_state_2:
			usage_resource_disable_finish (_data_->_tmp32_, _data_->_res_, &_data_->_inner_error_);
			if (_data_->_inner_error_ != NULL) {
				goto __catch13_g_error;
			}
		}
		goto __finally13;
		__catch13_g_error:
		{
			_data_->e1 = _data_->_inner_error_;
			_data_->_inner_error_ = NULL;
			_data_->_tmp33_ = ((FsoFrameworkAbstractObject*) _data_->self)->logger;
			_data_->_tmp34_ = _data_->r;
			_data_->_tmp35_ = usage_resource_get_name (_data_->_tmp34_);
			_data_->_tmp36_ = _data_->_tmp35_;
			_data_->_tmp37_ = NULL;
			_data_->_tmp37_ = string_to_string (_data_->_tmp36_);
			_data_->_tmp38_ = _data_->e1;
			_data_->_tmp39_ = _data_->_tmp38_->message;
			_data_->_tmp40_ = NULL;
			_data_->_tmp40_ = string_to_string (_data_->_tmp39_);
			_data_->_tmp41_ = NULL;
			_data_->_tmp41_ = g_strconcat ("Error while trying to (initially) disable resource ", _data_->_tmp37_, ": ", _data_->_tmp40_, NULL);
			_data_->_tmp42_ = _data_->_tmp41_;
			fso_framework_logger_warning (_data_->_tmp33_, _data_->_tmp42_);
			_g_free0 (_data_->_tmp42_);
			_g_error_free0 (_data_->e1);
		}
		__finally13:
		if (_data_->_inner_error_ != NULL) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
	}
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


/**
     * When a resource is not available on the bus any longer we need to tell this all our
     * connected clients with sending out a notification.
     **/
static void usage_controller_onResourceVanishing (UsageController* self, UsageResource* r) {
	FsoFrameworkLogger* _tmp0_;
	UsageResource* _tmp1_;
	const gchar* _tmp2_;
	const gchar* _tmp3_;
	const gchar* _tmp4_ = NULL;
	UsageResource* _tmp5_;
	const char* _tmp6_;
	const char* _tmp7_;
	const gchar* _tmp8_ = NULL;
	UsageResource* _tmp9_;
	const char* _tmp10_;
	const char* _tmp11_;
	const gchar* _tmp12_ = NULL;
	gchar* _tmp13_ = NULL;
	gchar* _tmp14_;
	gboolean _tmp15_ = FALSE;
	UsageResource* _tmp16_;
	const gchar* _tmp17_;
	const gchar* _tmp18_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (r != NULL);
	_tmp0_ = ((FsoFrameworkAbstractObject*) self)->logger;
	_tmp1_ = r;
	_tmp2_ = usage_resource_get_name (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = string_to_string (_tmp3_);
	_tmp5_ = r;
	_tmp6_ = usage_resource_get_busname (_tmp5_);
	_tmp7_ = _tmp6_;
	_tmp8_ = string_to_string ((const gchar*) _tmp7_);
	_tmp9_ = r;
	_tmp10_ = usage_resource_get_objectpath (_tmp9_);
	_tmp11_ = _tmp10_;
	_tmp12_ = string_to_string ((const gchar*) _tmp11_);
	_tmp13_ = g_strconcat ("Resource ", _tmp4_, " served by ", _tmp8_, " @ ", _tmp12_, " has just been unregistered", NULL);
	_tmp14_ = _tmp13_;
	_tmp15_ = fso_framework_logger_debug (_tmp0_, _tmp14_);
	g_assert (_tmp15_);
	_g_free0 (_tmp14_);
	_tmp16_ = r;
	_tmp17_ = usage_resource_get_name (_tmp16_);
	_tmp18_ = _tmp17_;
	g_signal_emit_by_name (self, "resource-available", _tmp18_, FALSE);
}


/**
     * Implements handling of new and old bus owners. If a new owner arrives on a bus we
     * need to handle this when it provides a resource and vice versa if a owner leaves
     * its bus.
     **/
static void usage_controller_onNameOwnerChanged (UsageController* self, const gchar* name, const gchar* oldowner, const gchar* newowner) {
	const gchar* _tmp0_;
	FsoFrameworkLogger* _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	gboolean _tmp5_ = FALSE;
	GeeHashSet* _tmp6_;
	GeeHashSet* resourcesToRemove;
	g_return_if_fail (self != NULL);
	g_return_if_fail (name != NULL);
	g_return_if_fail (oldowner != NULL);
	g_return_if_fail (newowner != NULL);
	_tmp0_ = newowner;
	if (g_strcmp0 (_tmp0_, "") != 0) {
		return;
	}
	_tmp1_ = ((FsoFrameworkAbstractObject*) self)->logger;
	_tmp2_ = name;
	_tmp3_ = g_strdup_printf ("%s disappeared. checking whether resources are affected...", _tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = fso_framework_logger_debug (_tmp1_, _tmp4_);
	g_assert (_tmp5_);
	_g_free0 (_tmp4_);
	_tmp6_ = gee_hash_set_new (USAGE_TYPE_RESOURCE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL);
	resourcesToRemove = _tmp6_;
	{
		GeeHashMap* _tmp7_;
		GeeCollection* _tmp8_;
		GeeCollection* _tmp9_;
		GeeCollection* _tmp10_;
		GeeIterator* _tmp11_ = NULL;
		GeeIterator* _tmp12_;
		GeeIterator* _r_it;
		_tmp7_ = self->priv->resources;
		_tmp8_ = gee_abstract_map_get_values ((GeeMap*) _tmp7_);
		_tmp9_ = _tmp8_;
		_tmp10_ = _tmp9_;
		_tmp11_ = gee_iterable_iterator ((GeeIterable*) _tmp10_);
		_tmp12_ = _tmp11_;
		_g_object_unref0 (_tmp10_);
		_r_it = _tmp12_;
		while (TRUE) {
			GeeIterator* _tmp13_;
			gboolean _tmp14_ = FALSE;
			GeeIterator* _tmp15_;
			gpointer _tmp16_ = NULL;
			UsageResource* r;
			UsageResource* _tmp17_;
			const char* _tmp18_;
			const char* _tmp19_;
			const gchar* _tmp20_;
			_tmp13_ = _r_it;
			_tmp14_ = gee_iterator_next (_tmp13_);
			if (!_tmp14_) {
				break;
			}
			_tmp15_ = _r_it;
			_tmp16_ = gee_iterator_get (_tmp15_);
			r = (UsageResource*) _tmp16_;
			_tmp17_ = r;
			_tmp18_ = usage_resource_get_busname (_tmp17_);
			_tmp19_ = _tmp18_;
			_tmp20_ = name;
			if (g_strcmp0 (_tmp19_, _tmp20_) == 0) {
				UsageResource* _tmp21_;
				GeeHashSet* _tmp22_;
				UsageResource* _tmp23_;
				_tmp21_ = r;
				usage_controller_onResourceVanishing (self, _tmp21_);
				_tmp22_ = resourcesToRemove;
				_tmp23_ = r;
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp22_, _tmp23_);
			} else {
				UsageResource* _tmp24_;
				const gchar* _tmp25_;
				gboolean _tmp26_ = FALSE;
				_tmp24_ = r;
				_tmp25_ = name;
				_tmp26_ = usage_resource_hasUser (_tmp24_, _tmp25_);
				if (_tmp26_) {
					UsageResource* _tmp27_;
					const gchar* _tmp28_;
					_tmp27_ = r;
					_tmp28_ = name;
					usage_resource_delUser (_tmp27_, _tmp28_, NULL, NULL);
				}
			}
			_g_object_unref0 (r);
		}
		_g_object_unref0 (_r_it);
	}
	{
		GeeHashSet* _tmp29_;
		GeeIterator* _tmp30_ = NULL;
		GeeIterator* _r_it;
		_tmp29_ = resourcesToRemove;
		_tmp30_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) _tmp29_);
		_r_it = _tmp30_;
		while (TRUE) {
			GeeIterator* _tmp31_;
			gboolean _tmp32_ = FALSE;
			GeeIterator* _tmp33_;
			gpointer _tmp34_ = NULL;
			UsageResource* r;
			GeeHashMap* _tmp35_;
			UsageResource* _tmp36_;
			const gchar* _tmp37_;
			const gchar* _tmp38_;
			_tmp31_ = _r_it;
			_tmp32_ = gee_iterator_next (_tmp31_);
			if (!_tmp32_) {
				break;
			}
			_tmp33_ = _r_it;
			_tmp34_ = gee_iterator_get (_tmp33_);
			r = (UsageResource*) _tmp34_;
			_tmp35_ = self->priv->resources;
			_tmp36_ = r;
			_tmp37_ = usage_resource_get_name (_tmp36_);
			_tmp38_ = _tmp37_;
			gee_abstract_map_unset ((GeeAbstractMap*) _tmp35_, _tmp38_, NULL);
			_g_object_unref0 (r);
		}
		_g_object_unref0 (_r_it);
	}
	_g_object_unref0 (resourcesToRemove);
}


/**
     * When suspend command is issued this will handle the suspend and resume process
     * itself by calling into the lowlevel handler and processing the resource handling.
     **/
static gchar* bool_to_string (gboolean self) {
	gchar* result = NULL;
	if (self) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup ("true");
		result = _tmp0_;
		return result;
	} else {
		gchar* _tmp1_;
		_tmp1_ = g_strdup ("false");
		result = _tmp1_;
		return result;
	}
}


gboolean usage_controller_onIdleForSuspend (UsageController* self) {
	gboolean result = FALSE;
	gint resourcesAlive;
	FreeSmartphoneDeviceIdleState idleState;
	FsoUsageResumeReason reason;
	gboolean user_initiated;
	gint _tmp31_;
	gboolean _tmp38_;
	gboolean _tmp51_;
	g_return_val_if_fail (self != NULL, FALSE);
	resourcesAlive = 0;
	idleState = FREE_SMARTPHONE_DEVICE_IDLE_STATE_BUSY;
	reason = FSO_USAGE_RESUME_REASON_Invalid;
	user_initiated = FALSE;
	{
		GeeHashMap* _tmp0_;
		GeeCollection* _tmp1_;
		GeeCollection* _tmp2_;
		GeeCollection* _tmp3_;
		GeeIterator* _tmp4_ = NULL;
		GeeIterator* _tmp5_;
		GeeIterator* _r_it;
		_tmp0_ = self->priv->resources;
		_tmp1_ = gee_abstract_map_get_values ((GeeMap*) _tmp0_);
		_tmp2_ = _tmp1_;
		_tmp3_ = _tmp2_;
		_tmp4_ = gee_iterable_iterator ((GeeIterable*) _tmp3_);
		_tmp5_ = _tmp4_;
		_g_object_unref0 (_tmp3_);
		_r_it = _tmp5_;
		while (TRUE) {
			GeeIterator* _tmp6_;
			gboolean _tmp7_ = FALSE;
			GeeIterator* _tmp8_;
			gpointer _tmp9_ = NULL;
			UsageResource* r;
			gboolean _tmp10_ = FALSE;
			gboolean _tmp11_ = FALSE;
			UsageResource* _tmp12_;
			FsoFrameworkResourceStatus _tmp13_;
			FsoFrameworkResourceStatus _tmp14_;
			gboolean _tmp18_;
			gboolean _tmp22_;
			_tmp6_ = _r_it;
			_tmp7_ = gee_iterator_next (_tmp6_);
			if (!_tmp7_) {
				break;
			}
			_tmp8_ = _r_it;
			_tmp9_ = gee_iterator_get (_tmp8_);
			r = (UsageResource*) _tmp9_;
			_tmp12_ = r;
			_tmp13_ = usage_resource_get_status (_tmp12_);
			_tmp14_ = _tmp13_;
			if (_tmp14_ != FSO_FRAMEWORK_RESOURCE_STATUS_SUSPENDED) {
				UsageResource* _tmp15_;
				FsoFrameworkResourceStatus _tmp16_;
				FsoFrameworkResourceStatus _tmp17_;
				_tmp15_ = r;
				_tmp16_ = usage_resource_get_status (_tmp15_);
				_tmp17_ = _tmp16_;
				_tmp11_ = _tmp17_ != FSO_FRAMEWORK_RESOURCE_STATUS_DISABLED;
			} else {
				_tmp11_ = FALSE;
			}
			_tmp18_ = _tmp11_;
			if (_tmp18_) {
				UsageResource* _tmp19_;
				FsoFrameworkResourceStatus _tmp20_;
				FsoFrameworkResourceStatus _tmp21_;
				_tmp19_ = r;
				_tmp20_ = usage_resource_get_status (_tmp19_);
				_tmp21_ = _tmp20_;
				_tmp10_ = _tmp21_ != FSO_FRAMEWORK_RESOURCE_STATUS_UNKNOWN;
			} else {
				_tmp10_ = FALSE;
			}
			_tmp22_ = _tmp10_;
			if (_tmp22_) {
				FsoFrameworkLogger* _tmp23_;
				UsageResource* _tmp24_;
				const gchar* _tmp25_;
				const gchar* _tmp26_;
				const gchar* _tmp27_ = NULL;
				gchar* _tmp28_ = NULL;
				gchar* _tmp29_;
				gint _tmp30_;
				_tmp23_ = ((FsoFrameworkAbstractObject*) self)->logger;
				_tmp24_ = r;
				_tmp25_ = usage_resource_get_name (_tmp24_);
				_tmp26_ = _tmp25_;
				_tmp27_ = string_to_string (_tmp26_);
				_tmp28_ = g_strconcat ("Resource ", _tmp27_, " is not suspended nor disabled", NULL);
				_tmp29_ = _tmp28_;
				fso_framework_logger_warning (_tmp23_, _tmp29_);
				_g_free0 (_tmp29_);
				_tmp30_ = resourcesAlive;
				resourcesAlive = _tmp30_ + 1;
			}
			_g_object_unref0 (r);
		}
		_g_object_unref0 (_r_it);
	}
	_tmp31_ = resourcesAlive;
	if (_tmp31_ > 0) {
		FsoFrameworkLogger* _tmp32_;
		gint _tmp33_;
		gchar* _tmp34_ = NULL;
		gchar* _tmp35_;
		gchar* _tmp36_ = NULL;
		gchar* _tmp37_;
		_tmp32_ = ((FsoFrameworkAbstractObject*) self)->logger;
		_tmp33_ = resourcesAlive;
		_tmp34_ = g_strdup_printf ("%i", _tmp33_);
		_tmp35_ = _tmp34_;
		_tmp36_ = g_strconcat (_tmp35_, " resources still alive :( Aborting Suspend!", NULL);
		_tmp37_ = _tmp36_;
		fso_framework_logger_error (_tmp32_, _tmp37_);
		_g_free0 (_tmp37_);
		_g_free0 (_tmp35_);
		result = FALSE;
		return result;
	}
	_tmp38_ = self->priv->debug_do_not_suspend;
	if (!_tmp38_) {
		FsoFrameworkLogger* _tmp39_;
		FsoUsageLowLevel* _tmp40_;
		gboolean _tmp41_;
		_tmp39_ = ((FsoFrameworkAbstractObject*) self)->logger;
		fso_framework_logger_info (_tmp39_, "Entering lowlevel suspend");
		_tmp40_ = self->priv->lowlevel;
		fso_usage_low_level_suspend (_tmp40_);
		_tmp41_ = self->priv->wakelock_support;
		if (!_tmp41_) {
			FsoFrameworkLogger* _tmp42_;
			FsoUsageLowLevel* _tmp43_;
			FsoUsageResumeReason _tmp44_ = 0;
			FsoFrameworkLogger* _tmp45_;
			FsoUsageResumeReason _tmp46_;
			GEnumValue* _tmp47_;
			gchar* _tmp48_ = NULL;
			gchar* _tmp49_;
			_tmp42_ = ((FsoFrameworkAbstractObject*) self)->logger;
			fso_framework_logger_info (_tmp42_, "Leaving lowlevel suspend");
			_tmp43_ = self->priv->lowlevel;
			_tmp44_ = fso_usage_low_level_resume (_tmp43_);
			reason = _tmp44_;
			_tmp45_ = ((FsoFrameworkAbstractObject*) self)->logger;
			_tmp46_ = reason;
			_tmp47_ = g_enum_get_value (g_type_class_ref (FSO_USAGE_TYPE_RESUME_REASON), _tmp46_);
			_tmp48_ = g_strconcat ("Resume reason seems to be ", (_tmp47_ != NULL) ? _tmp47_->value_name : NULL, NULL);
			_tmp49_ = _tmp48_;
			fso_framework_logger_info (_tmp45_, _tmp49_);
			_g_free0 (_tmp49_);
		}
	} else {
		FsoFrameworkLogger* _tmp50_;
		_tmp50_ = ((FsoFrameworkAbstractObject*) self)->logger;
		fso_framework_logger_info (_tmp50_, "Not suspending due to configuration. System will stay in SUSPEND mode.");
	}
	_tmp51_ = self->priv->wakelock_support;
	if (!_tmp51_) {
		UsageController* _tmp52_;
		gboolean _tmp53_;
		FreeSmartphoneDeviceIdleState _tmp58_ = 0;
		gboolean _tmp59_;
		FreeSmartphoneDeviceIdleState _tmp60_;
		FsoFrameworkLogger* _tmp61_;
		gboolean _tmp62_;
		gchar* _tmp63_ = NULL;
		gchar* _tmp64_;
		FreeSmartphoneDeviceIdleState _tmp65_;
		GEnumValue* _tmp66_;
		gchar* _tmp67_ = NULL;
		gchar* _tmp68_;
		gboolean _tmp69_ = FALSE;
		FreeSmartphoneDeviceIdleState _tmp70_;
		UsageController* _tmp71_;
		usage_controller_resumeAllResources (self, NULL, NULL);
		_tmp52_ = usage_instance;
		usage_controller_updateSystemStatus (_tmp52_, FREE_SMARTPHONE_USAGE_SYSTEM_ACTION_RESUME);
		_tmp53_ = self->priv->debug_do_not_suspend;
		if (!_tmp53_) {
			FsoUsageLowLevel* _tmp54_;
			FsoUsageResumeReason _tmp55_;
			gboolean _tmp56_ = FALSE;
			_tmp54_ = self->priv->lowlevel;
			_tmp55_ = reason;
			_tmp56_ = fso_usage_low_level_isUserInitiated (_tmp54_, _tmp55_);
			user_initiated = _tmp56_;
		} else {
			gboolean _tmp57_;
			_tmp57_ = self->priv->debug_suspend_user_initiated;
			user_initiated = _tmp57_;
		}
		_tmp59_ = user_initiated;
		if (_tmp59_) {
			_tmp58_ = FREE_SMARTPHONE_DEVICE_IDLE_STATE_BUSY;
		} else {
			_tmp58_ = FREE_SMARTPHONE_DEVICE_IDLE_STATE_LOCK;
		}
		_tmp60_ = _tmp58_;
		idleState = _tmp60_;
		_tmp61_ = ((FsoFrameworkAbstractObject*) self)->logger;
		_tmp62_ = user_initiated;
		_tmp63_ = bool_to_string (_tmp62_);
		_tmp64_ = _tmp63_;
		_tmp65_ = idleState;
		_tmp66_ = g_enum_get_value (g_type_class_ref (FREE_SMARTPHONE_DEVICE_TYPE_IDLE_STATE), _tmp65_);
		_tmp67_ = g_strconcat ("Resume is initiated by the user: ", _tmp64_, "; switching to ", (_tmp66_ != NULL) ? _tmp66_->value_name : NULL, " idle state ...", NULL);
		_tmp68_ = _tmp67_;
		_tmp69_ = fso_framework_logger_debug (_tmp61_, _tmp68_);
		g_assert (_tmp69_);
		_g_free0 (_tmp68_);
		_g_free0 (_tmp64_);
		_tmp70_ = idleState;
		usage_controller_updateIdleState (self, _tmp70_, NULL, NULL);
		_tmp71_ = usage_instance;
		usage_controller_updateSystemStatus (_tmp71_, FREE_SMARTPHONE_USAGE_SYSTEM_ACTION_ALIVE);
	}
	result = FALSE;
	return result;
}


gboolean usage_controller_onIdleForResume (UsageController* self) {
	gboolean result = FALSE;
	gboolean _tmp0_;
	FreeSmartphoneDeviceIdleState idleState;
	FsoUsageResumeReason reason;
	gboolean user_initiated;
	FsoUsageLowLevel* _tmp1_;
	FsoUsageResumeReason _tmp2_ = 0;
	FsoUsageLowLevel* _tmp3_;
	FsoUsageResumeReason _tmp4_;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp6_;
	FreeSmartphoneDeviceIdleState _tmp8_ = 0;
	gboolean _tmp9_;
	FreeSmartphoneDeviceIdleState _tmp10_;
	FsoFrameworkLogger* _tmp11_;
	gboolean _tmp12_;
	gchar* _tmp13_ = NULL;
	gchar* _tmp14_;
	FreeSmartphoneDeviceIdleState _tmp15_;
	GEnumValue* _tmp16_;
	gchar* _tmp17_ = NULL;
	gchar* _tmp18_;
	gboolean _tmp19_ = FALSE;
	FreeSmartphoneDeviceIdleState _tmp20_;
	UsageController* _tmp21_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->wakelock_support;
	if (!_tmp0_) {
		usage_controller_resumeAllResources (self, NULL, NULL);
		result = FALSE;
		return result;
	}
	idleState = FREE_SMARTPHONE_DEVICE_IDLE_STATE_BUSY;
	reason = FSO_USAGE_RESUME_REASON_Invalid;
	user_initiated = FALSE;
	_tmp1_ = self->priv->lowlevel;
	_tmp2_ = fso_usage_low_level_resume (_tmp1_);
	reason = _tmp2_;
	usage_controller_resumeAllResources (self, NULL, NULL);
	_tmp3_ = self->priv->lowlevel;
	_tmp4_ = reason;
	_tmp5_ = fso_usage_low_level_isUserInitiated (_tmp3_, _tmp4_);
	user_initiated = _tmp5_;
	_tmp6_ = self->priv->debug_do_not_suspend;
	if (_tmp6_) {
		gboolean _tmp7_;
		_tmp7_ = self->priv->debug_suspend_user_initiated;
		user_initiated = _tmp7_;
	}
	_tmp9_ = user_initiated;
	if (_tmp9_) {
		_tmp8_ = FREE_SMARTPHONE_DEVICE_IDLE_STATE_BUSY;
	} else {
		_tmp8_ = FREE_SMARTPHONE_DEVICE_IDLE_STATE_LOCK;
	}
	_tmp10_ = _tmp8_;
	idleState = _tmp10_;
	_tmp11_ = ((FsoFrameworkAbstractObject*) self)->logger;
	_tmp12_ = user_initiated;
	_tmp13_ = bool_to_string (_tmp12_);
	_tmp14_ = _tmp13_;
	_tmp15_ = idleState;
	_tmp16_ = g_enum_get_value (g_type_class_ref (FREE_SMARTPHONE_DEVICE_TYPE_IDLE_STATE), _tmp15_);
	_tmp17_ = g_strconcat ("Resume is initiated by the user: ", _tmp14_, "; switching to ", (_tmp16_ != NULL) ? _tmp16_->value_name : NULL, " idle state ...", NULL);
	_tmp18_ = _tmp17_;
	_tmp19_ = fso_framework_logger_debug (_tmp11_, _tmp18_);
	g_assert (_tmp19_);
	_g_free0 (_tmp18_);
	_g_free0 (_tmp14_);
	_tmp20_ = idleState;
	usage_controller_updateIdleState (self, _tmp20_, NULL, NULL);
	_tmp21_ = usage_instance;
	usage_controller_updateSystemStatus (_tmp21_, FREE_SMARTPHONE_USAGE_SYSTEM_ACTION_ALIVE);
	result = FALSE;
	return result;
}


static void usage_controller_updateIdleState_data_free (gpointer _data) {
	usage_controller_updateIdleStateData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (usage_controller_updateIdleStateData, _data_);
}


static void usage_controller_updateIdleState (UsageController* self, FreeSmartphoneDeviceIdleState state, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	usage_controller_updateIdleStateData* _data_;
	UsageController* _tmp0_;
	FreeSmartphoneDeviceIdleState _tmp1_;
	_data_ = g_slice_new0 (usage_controller_updateIdleStateData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, usage_controller_updateIdleState);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, usage_controller_updateIdleState_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = state;
	_data_->state = _tmp1_;
	usage_controller_updateIdleState_co (_data_);
}


static void usage_controller_updateIdleState_finish (UsageController* self, GAsyncResult* _res_) {
	usage_controller_updateIdleStateData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void usage_controller_updateIdleState_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	usage_controller_updateIdleStateData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	usage_controller_updateIdleState_co (_data_);
}


static gboolean usage_controller_updateIdleState_co (usage_controller_updateIdleStateData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	{
		_data_->_tmp0_ = _data_->self->priv->idlenotifier;
		_data_->_tmp1_ = _data_->state;
		_data_->_state_ = 1;
		free_smartphone_device_idle_notifier_set_state (_data_->_tmp0_, _data_->_tmp1_, usage_controller_updateIdleState_ready, _data_);
		return FALSE;
		_state_1:
		free_smartphone_device_idle_notifier_set_state_finish (_data_->_tmp0_, _data_->_res_, &_data_->_inner_error_);
		if (_data_->_inner_error_ != NULL) {
			goto __catch14_g_error;
		}
	}
	goto __finally14;
	__catch14_g_error:
	{
		_data_->e = _data_->_inner_error_;
		_data_->_inner_error_ = NULL;
		_data_->_tmp2_ = ((FsoFrameworkAbstractObject*) _data_->self)->logger;
		_data_->_tmp3_ = _data_->e;
		_data_->_tmp4_ = _data_->_tmp3_->message;
		_data_->_tmp5_ = NULL;
		_data_->_tmp5_ = string_to_string (_data_->_tmp4_);
		_data_->_tmp6_ = NULL;
		_data_->_tmp6_ = g_strconcat ("Error while talking to IdleNotifier: ", _data_->_tmp5_, NULL);
		_data_->_tmp7_ = _data_->_tmp6_;
		fso_framework_logger_error (_data_->_tmp2_, _data_->_tmp7_);
		_g_free0 (_data_->_tmp7_);
		_g_error_free0 (_data_->e);
	}
	__finally14:
	if (_data_->_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
		g_clear_error (&_data_->_inner_error_);
		return FALSE;
	}
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


/**
     * Simple helper method to get a resource by its name from our internal storage.
     **/
UsageResource* usage_controller_getResource (UsageController* self, const gchar* name, GError** error) {
	UsageResource* result = NULL;
	FreeSmartphoneUsageSystemAction _tmp0_;
	GeeHashMap* _tmp7_;
	const gchar* _tmp8_;
	gpointer _tmp9_ = NULL;
	UsageResource* r;
	UsageResource* _tmp10_;
	FsoFrameworkLogger* _tmp17_;
	UsageResource* _tmp18_;
	const gchar* _tmp19_;
	const gchar* _tmp20_;
	UsageResource* _tmp21_;
	gint _tmp22_ = 0;
	gchar** _tmp23_ = NULL;
	gchar** _tmp24_;
	gint _tmp24__length1;
	gchar* _tmp25_ = NULL;
	gchar* _tmp26_;
	gchar* _tmp27_ = NULL;
	gchar* _tmp28_;
	gboolean _tmp29_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (name != NULL, NULL);
	_tmp0_ = self->priv->system_status;
	if (_tmp0_ != FREE_SMARTPHONE_USAGE_SYSTEM_ACTION_ALIVE) {
		FreeSmartphoneUsageSystemAction _tmp1_;
		GEnumValue* _tmp2_;
		gchar* _tmp3_ = NULL;
		gchar* _tmp4_;
		GError* _tmp5_;
		GError* _tmp6_;
		_tmp1_ = self->priv->system_status;
		_tmp2_ = g_enum_get_value (g_type_class_ref (FREE_SMARTPHONE_TYPE_USAGE_SYSTEM_ACTION), _tmp1_);
		_tmp3_ = g_strconcat ("System action ", (_tmp2_ != NULL) ? _tmp2_->value_name : NULL, " in progress; please try again later.", NULL);
		_tmp4_ = _tmp3_;
		_tmp5_ = g_error_new_literal (FREE_SMARTPHONE_ERROR, FREE_SMARTPHONE_ERROR_INVALID_PARAMETER, _tmp4_);
		_tmp6_ = _tmp5_;
		_g_free0 (_tmp4_);
		_inner_error_ = _tmp6_;
		if ((_inner_error_->domain == FREE_SMARTPHONE_USAGE_ERROR) || (_inner_error_->domain == FREE_SMARTPHONE_ERROR)) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp7_ = self->priv->resources;
	_tmp8_ = name;
	_tmp9_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp7_, _tmp8_);
	r = (UsageResource*) _tmp9_;
	_tmp10_ = r;
	if (_tmp10_ == NULL) {
		const gchar* _tmp11_;
		const gchar* _tmp12_ = NULL;
		gchar* _tmp13_ = NULL;
		gchar* _tmp14_;
		GError* _tmp15_;
		GError* _tmp16_;
		_tmp11_ = name;
		_tmp12_ = string_to_string (_tmp11_);
		_tmp13_ = g_strconcat ("Resource ", _tmp12_, " had never been registered", NULL);
		_tmp14_ = _tmp13_;
		_tmp15_ = g_error_new_literal (FREE_SMARTPHONE_USAGE_ERROR, FREE_SMARTPHONE_USAGE_ERROR_RESOURCE_UNKNOWN, _tmp14_);
		_tmp16_ = _tmp15_;
		_g_free0 (_tmp14_);
		_inner_error_ = _tmp16_;
		if ((_inner_error_->domain == FREE_SMARTPHONE_USAGE_ERROR) || (_inner_error_->domain == FREE_SMARTPHONE_ERROR)) {
			g_propagate_error (error, _inner_error_);
			_g_object_unref0 (r);
			return NULL;
		} else {
			_g_object_unref0 (r);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp17_ = ((FsoFrameworkAbstractObject*) self)->logger;
	_tmp18_ = r;
	_tmp19_ = usage_resource_get_name (_tmp18_);
	_tmp20_ = _tmp19_;
	_tmp21_ = r;
	_tmp23_ = usage_resource_allUsers (_tmp21_, &_tmp22_);
	_tmp24_ = _tmp23_;
	_tmp24__length1 = _tmp22_;
	_tmp25_ = fso_framework_string_handling_stringListToString (_tmp24_, _tmp22_);
	_tmp26_ = _tmp25_;
	_tmp27_ = g_strdup_printf ("Current users for %s = %s", _tmp20_, _tmp26_);
	_tmp28_ = _tmp27_;
	_tmp29_ = fso_framework_logger_debug (_tmp17_, _tmp28_);
	g_assert (_tmp29_);
	_g_free0 (_tmp28_);
	_g_free0 (_tmp26_);
	_tmp24_ = (_vala_array_free (_tmp24_, _tmp24__length1, (GDestroyNotify) g_free), NULL);
	result = r;
	return result;
}


/**
     * This will create a list of all dependency resources for the given resource.
     */
static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static void _g_list_free__g_object_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_object_unref0_, NULL);
	g_list_free (self);
}


static GList* usage_controller_resolveResourceDependencies (UsageController* self, UsageResource* r) {
	GList* result = NULL;
	GList* resourceWithDependencies;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (r != NULL, NULL);
	resourceWithDependencies = NULL;
	{
		UsageResource* _tmp0_;
		GeeArrayList* _tmp1_;
		GeeArrayList* _tmp2_;
		GeeArrayList* _tmp3_;
		GeeArrayList* _dependencyName_list;
		GeeArrayList* _tmp4_;
		gint _tmp5_;
		gint _tmp6_;
		gint _dependencyName_size;
		gint _dependencyName_index;
		_tmp0_ = r;
		_tmp1_ = usage_resource_get_busDependencies (_tmp0_);
		_tmp2_ = _tmp1_;
		_tmp3_ = _g_object_ref0 (_tmp2_);
		_dependencyName_list = _tmp3_;
		_tmp4_ = _dependencyName_list;
		_tmp5_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp4_);
		_tmp6_ = _tmp5_;
		_dependencyName_size = _tmp6_;
		_dependencyName_index = -1;
		while (TRUE) {
			gint _tmp7_;
			gint _tmp8_;
			gint _tmp9_;
			GeeArrayList* _tmp10_;
			gint _tmp11_;
			gpointer _tmp12_ = NULL;
			gchar* dependencyName;
			GeeHashMap* _tmp13_;
			const gchar* _tmp14_;
			gboolean _tmp15_ = FALSE;
			_tmp7_ = _dependencyName_index;
			_dependencyName_index = _tmp7_ + 1;
			_tmp8_ = _dependencyName_index;
			_tmp9_ = _dependencyName_size;
			if (!(_tmp8_ < _tmp9_)) {
				break;
			}
			_tmp10_ = _dependencyName_list;
			_tmp11_ = _dependencyName_index;
			_tmp12_ = gee_abstract_list_get ((GeeAbstractList*) _tmp10_, _tmp11_);
			dependencyName = (gchar*) _tmp12_;
			_tmp13_ = self->priv->resources;
			_tmp14_ = dependencyName;
			_tmp15_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp13_, _tmp14_);
			if (_tmp15_) {
				GeeHashMap* _tmp16_;
				const gchar* _tmp17_;
				gpointer _tmp18_ = NULL;
				_tmp16_ = self->priv->resources;
				_tmp17_ = dependencyName;
				_tmp18_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp16_, _tmp17_);
				resourceWithDependencies = g_list_append (resourceWithDependencies, (UsageResource*) _tmp18_);
			} else {
				FsoFrameworkLogger* _tmp19_;
				const gchar* _tmp20_;
				const gchar* _tmp21_ = NULL;
				UsageResource* _tmp22_;
				const gchar* _tmp23_;
				const gchar* _tmp24_;
				const gchar* _tmp25_ = NULL;
				gchar* _tmp26_ = NULL;
				gchar* _tmp27_;
				_tmp19_ = ((FsoFrameworkAbstractObject*) self)->logger;
				_tmp20_ = dependencyName;
				_tmp21_ = string_to_string (_tmp20_);
				_tmp22_ = r;
				_tmp23_ = usage_resource_get_name (_tmp22_);
				_tmp24_ = _tmp23_;
				_tmp25_ = string_to_string (_tmp24_);
				_tmp26_ = g_strconcat ("Found not registered resource dependency '", _tmp21_, "' for resource '", _tmp25_, "'", NULL);
				_tmp27_ = _tmp26_;
				fso_framework_logger_warning (_tmp19_, _tmp27_);
				_g_free0 (_tmp27_);
			}
			_g_free0 (dependencyName);
		}
		_g_object_unref0 (_dependencyName_list);
	}
	result = resourceWithDependencies;
	return result;
}


/**
     * This will increment the usage number of a resource with the given name by one.
     **/
static void usage_controller_incrementResourcePriority (UsageController* self, GeeHashMap* resourcesWithPriority, const gchar* name) {
	GeeHashMap* _tmp0_;
	const gchar* _tmp1_;
	gboolean _tmp2_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (resourcesWithPriority != NULL);
	g_return_if_fail (name != NULL);
	_tmp0_ = resourcesWithPriority;
	_tmp1_ = name;
	_tmp2_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp0_, _tmp1_);
	if (_tmp2_) {
		GeeHashMap* _tmp3_;
		const gchar* _tmp4_;
		_tmp3_ = resourcesWithPriority;
		_tmp4_ = name;
		gee_abstract_map_set ((GeeAbstractMap*) _tmp3_, _tmp4_, GINT_TO_POINTER (1));
	} else {
		GeeHashMap* _tmp5_;
		const gchar* _tmp6_;
		_tmp5_ = resourcesWithPriority;
		_tmp6_ = name;
		gee_abstract_map_set ((GeeAbstractMap*) _tmp5_, _tmp6_, GINT_TO_POINTER (1));
	}
}


/**
     * Create a list of priorized resources. The priority is calculated by the
     * dependencies of each resource. If a resouce is a dependency of another one it get's
     * a higher priority. The first resource in the returned list is the resource with the
     * lowest priority.
     **/
static Block3Data* block3_data_ref (Block3Data* _data3_) {
	g_atomic_int_inc (&_data3_->_ref_count_);
	return _data3_;
}


static void block3_data_unref (void * _userdata_) {
	Block3Data* _data3_;
	_data3_ = (Block3Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data3_->_ref_count_)) {
		UsageController * self;
		self = _data3_->self;
		_g_object_unref0 (_data3_->resourcesWithPriority);
		_g_object_unref0 (self);
		g_slice_free (Block3Data, _data3_);
	}
}


static gint __lambda4_ (Block3Data* _data3_, gconstpointer a, gconstpointer b) {
	UsageController * self;
	gint result = 0;
	gint rc;
	gconstpointer _tmp0_;
	UsageResource* _tmp1_;
	UsageResource* ra;
	gconstpointer _tmp2_;
	UsageResource* _tmp3_;
	UsageResource* rb;
	UsageResource* _tmp4_;
	UsageResource* _tmp5_;
	GeeHashMap* _tmp6_;
	UsageResource* _tmp7_;
	const gchar* _tmp8_;
	const gchar* _tmp9_;
	gpointer _tmp10_ = NULL;
	gint priorityRa;
	GeeHashMap* _tmp11_;
	UsageResource* _tmp12_;
	const gchar* _tmp13_;
	const gchar* _tmp14_;
	gpointer _tmp15_ = NULL;
	gint priorityRb;
	gint _tmp16_;
	gint _tmp17_;
	self = _data3_->self;
	rc = 0;
	_tmp0_ = a;
	_tmp1_ = _g_object_ref0 (USAGE_IS_RESOURCE (_tmp0_) ? ((UsageResource*) _tmp0_) : NULL);
	ra = _tmp1_;
	_tmp2_ = b;
	_tmp3_ = _g_object_ref0 (USAGE_IS_RESOURCE (_tmp2_) ? ((UsageResource*) _tmp2_) : NULL);
	rb = _tmp3_;
	_tmp4_ = ra;
	g_assert (_tmp4_ != NULL);
	_tmp5_ = rb;
	g_assert (_tmp5_ != NULL);
	_tmp6_ = _data3_->resourcesWithPriority;
	_tmp7_ = ra;
	_tmp8_ = usage_resource_get_name (_tmp7_);
	_tmp9_ = _tmp8_;
	_tmp10_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp6_, _tmp9_);
	priorityRa = GPOINTER_TO_INT (_tmp10_);
	_tmp11_ = _data3_->resourcesWithPriority;
	_tmp12_ = rb;
	_tmp13_ = usage_resource_get_name (_tmp12_);
	_tmp14_ = _tmp13_;
	_tmp15_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp11_, _tmp14_);
	priorityRb = GPOINTER_TO_INT (_tmp15_);
	_tmp16_ = priorityRa;
	_tmp17_ = priorityRb;
	if (_tmp16_ > _tmp17_) {
		rc = 1;
	} else {
		gint _tmp18_;
		gint _tmp19_;
		_tmp18_ = priorityRa;
		_tmp19_ = priorityRb;
		if (_tmp18_ < _tmp19_) {
			rc = -1;
		}
	}
	result = rc;
	_g_object_unref0 (rb);
	_g_object_unref0 (ra);
	return result;
}


static gint ___lambda4__gcompare_data_func (gconstpointer a, gconstpointer b, gpointer self) {
	gint result;
	result = __lambda4_ (self, a, b);
	return result;
}


static UsageResource** usage_controller_retrievePriorizedResourceList (UsageController* self, gboolean revertOrder, int* result_length1) {
	UsageResource** result = NULL;
	Block3Data* _data3_;
	GeeHashMap* _tmp0_;
	GeeArrayList* _tmp1_;
	GeeArrayList* priorizedResources;
	UsageResource** _result_;
	gint _result__length1;
	gint __result__size_;
	GeeArrayList* _tmp26_;
	GeeArrayList* _tmp27_;
	gint _tmp28_ = 0;
	gpointer* _tmp29_ = NULL;
	gboolean _tmp30_;
	UsageResource** _tmp49_;
	gint _tmp49__length1;
	g_return_val_if_fail (self != NULL, NULL);
	_data3_ = g_slice_new0 (Block3Data);
	_data3_->_ref_count_ = 1;
	_data3_->self = g_object_ref (self);
	_tmp0_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_INT, NULL, NULL, NULL, NULL, NULL);
	_data3_->resourcesWithPriority = _tmp0_;
	_tmp1_ = gee_array_list_new (USAGE_TYPE_RESOURCE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	priorizedResources = _tmp1_;
	_result_ = NULL;
	_result__length1 = 0;
	__result__size_ = _result__length1;
	{
		GeeHashMap* _tmp2_;
		GeeCollection* _tmp3_;
		GeeCollection* _tmp4_;
		GeeCollection* _tmp5_;
		GeeIterator* _tmp6_ = NULL;
		GeeIterator* _tmp7_;
		GeeIterator* _r_it;
		_tmp2_ = self->priv->resources;
		_tmp3_ = gee_abstract_map_get_values ((GeeMap*) _tmp2_);
		_tmp4_ = _tmp3_;
		_tmp5_ = _tmp4_;
		_tmp6_ = gee_iterable_iterator ((GeeIterable*) _tmp5_);
		_tmp7_ = _tmp6_;
		_g_object_unref0 (_tmp5_);
		_r_it = _tmp7_;
		while (TRUE) {
			GeeIterator* _tmp8_;
			gboolean _tmp9_ = FALSE;
			GeeIterator* _tmp10_;
			gpointer _tmp11_ = NULL;
			UsageResource* r;
			GeeHashMap* _tmp12_;
			UsageResource* _tmp13_;
			const gchar* _tmp14_;
			const gchar* _tmp15_;
			UsageResource* _tmp16_;
			GList* _tmp17_ = NULL;
			GList* resourceDependencies;
			GList* _tmp18_;
			GeeArrayList* _tmp24_;
			UsageResource* _tmp25_;
			_tmp8_ = _r_it;
			_tmp9_ = gee_iterator_next (_tmp8_);
			if (!_tmp9_) {
				break;
			}
			_tmp10_ = _r_it;
			_tmp11_ = gee_iterator_get (_tmp10_);
			r = (UsageResource*) _tmp11_;
			_tmp12_ = _data3_->resourcesWithPriority;
			_tmp13_ = r;
			_tmp14_ = usage_resource_get_name (_tmp13_);
			_tmp15_ = _tmp14_;
			usage_controller_incrementResourcePriority (self, _tmp12_, _tmp15_);
			_tmp16_ = r;
			_tmp17_ = usage_controller_resolveResourceDependencies (self, _tmp16_);
			resourceDependencies = _tmp17_;
			_tmp18_ = resourceDependencies;
			{
				GList* resourceDependency_collection = NULL;
				GList* resourceDependency_it = NULL;
				resourceDependency_collection = _tmp18_;
				for (resourceDependency_it = resourceDependency_collection; resourceDependency_it != NULL; resourceDependency_it = resourceDependency_it->next) {
					UsageResource* _tmp19_;
					UsageResource* resourceDependency = NULL;
					_tmp19_ = _g_object_ref0 ((UsageResource*) resourceDependency_it->data);
					resourceDependency = _tmp19_;
					{
						GeeHashMap* _tmp20_;
						UsageResource* _tmp21_;
						const gchar* _tmp22_;
						const gchar* _tmp23_;
						_tmp20_ = _data3_->resourcesWithPriority;
						_tmp21_ = resourceDependency;
						_tmp22_ = usage_resource_get_name (_tmp21_);
						_tmp23_ = _tmp22_;
						usage_controller_incrementResourcePriority (self, _tmp20_, _tmp23_);
						_g_object_unref0 (resourceDependency);
					}
				}
			}
			_tmp24_ = priorizedResources;
			_tmp25_ = r;
			gee_abstract_collection_add ((GeeAbstractCollection*) _tmp24_, _tmp25_);
			__g_list_free__g_object_unref0_0 (resourceDependencies);
			_g_object_unref0 (r);
		}
		_g_object_unref0 (_r_it);
	}
	_tmp26_ = priorizedResources;
	gee_array_list_sort_with_data (_tmp26_, ___lambda4__gcompare_data_func, _data3_);
	_tmp27_ = priorizedResources;
	_tmp29_ = gee_abstract_collection_to_array ((GeeAbstractCollection*) _tmp27_, &_tmp28_);
	_result_ = (_vala_array_free (_result_, _result__length1, (GDestroyNotify) g_object_unref), NULL);
	_result_ = _tmp29_;
	_result__length1 = _tmp28_;
	__result__size_ = _result__length1;
	_tmp30_ = revertOrder;
	if (_tmp30_) {
		GeeArrayList* _tmp31_;
		gint _tmp32_;
		gint _tmp33_;
		UsageResource** _tmp34_ = NULL;
		gint m;
		_tmp31_ = priorizedResources;
		_tmp32_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp31_);
		_tmp33_ = _tmp32_;
		_tmp34_ = g_new0 (UsageResource*, _tmp33_ + 1);
		_result_ = (_vala_array_free (_result_, _result__length1, (GDestroyNotify) g_object_unref), NULL);
		_result_ = _tmp34_;
		_result__length1 = _tmp33_;
		__result__size_ = _result__length1;
		m = 0;
		{
			GeeArrayList* _tmp35_;
			gint _tmp36_;
			gint _tmp37_;
			gint n;
			_tmp35_ = priorizedResources;
			_tmp36_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp35_);
			_tmp37_ = _tmp36_;
			n = _tmp37_ - 1;
			{
				gboolean _tmp38_;
				_tmp38_ = TRUE;
				while (TRUE) {
					gboolean _tmp39_;
					gint _tmp41_;
					UsageResource** _tmp42_;
					gint _tmp42__length1;
					gint _tmp43_;
					GeeArrayList* _tmp44_;
					gint _tmp45_;
					gpointer _tmp46_ = NULL;
					UsageResource* _tmp47_;
					gint _tmp48_;
					_tmp39_ = _tmp38_;
					if (!_tmp39_) {
						gint _tmp40_;
						_tmp40_ = n;
						n = _tmp40_ - 1;
					}
					_tmp38_ = FALSE;
					_tmp41_ = n;
					if (!(_tmp41_ >= 0)) {
						break;
					}
					_tmp42_ = _result_;
					_tmp42__length1 = _result__length1;
					_tmp43_ = m;
					_tmp44_ = priorizedResources;
					_tmp45_ = n;
					_tmp46_ = gee_abstract_list_get ((GeeAbstractList*) _tmp44_, _tmp45_);
					_g_object_unref0 (_tmp42_[_tmp43_]);
					_tmp42_[_tmp43_] = (UsageResource*) _tmp46_;
					_tmp47_ = _tmp42_[_tmp43_];
					_tmp48_ = m;
					m = _tmp48_ + 1;
				}
			}
		}
	}
	_tmp49_ = _result_;
	_tmp49__length1 = _result__length1;
	if (result_length1) {
		*result_length1 = _tmp49__length1;
	}
	result = _tmp49_;
	_g_object_unref0 (priorizedResources);
	block3_data_unref (_data3_);
	_data3_ = NULL;
	return result;
}


static void usage_controller_disableAllResources_data_free (gpointer _data) {
	usage_controller_disableAllResourcesData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (usage_controller_disableAllResourcesData, _data_);
}


void usage_controller_disableAllResources (UsageController* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	usage_controller_disableAllResourcesData* _data_;
	UsageController* _tmp0_;
	_data_ = g_slice_new0 (usage_controller_disableAllResourcesData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, usage_controller_disableAllResources);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, usage_controller_disableAllResources_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	usage_controller_disableAllResources_co (_data_);
}


void usage_controller_disableAllResources_finish (UsageController* self, GAsyncResult* _res_) {
	usage_controller_disableAllResourcesData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void usage_controller_disableAllResources_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	usage_controller_disableAllResourcesData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	usage_controller_disableAllResources_co (_data_);
}


static gboolean usage_controller_disableAllResources_co (usage_controller_disableAllResourcesData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = ((FsoFrameworkAbstractObject*) _data_->self)->logger;
	_data_->_tmp1_ = FALSE;
	_data_->_tmp1_ = fso_framework_logger_debug (_data_->_tmp0_, "Disabling all resources...");
	g_assert (_data_->_tmp1_);
	_data_->_tmp2_ = 0;
	_data_->_tmp3_ = NULL;
	_data_->_tmp3_ = usage_controller_retrievePriorizedResourceList (_data_->self, FALSE, &_data_->_tmp2_);
	{
		_data_->r_collection_length1 = 0;
		_data_->_r_collection_size_ = 0;
		_data_->r_collection = _data_->_tmp3_;
		_data_->r_collection_length1 = _data_->_tmp2_;
		for (_data_->r_it = 0; _data_->r_it < _data_->_tmp2_; _data_->r_it = _data_->r_it + 1) {
			_data_->_tmp4_ = _g_object_ref0 (_data_->r_collection[_data_->r_it]);
			_data_->r = _data_->_tmp4_;
			{
				{
					_data_->_tmp5_ = _data_->r;
					_data_->_state_ = 1;
					usage_resource_disable (_data_->_tmp5_, usage_controller_disableAllResources_ready, _data_);
					return FALSE;
					_state_1:
					usage_resource_disable_finish (_data_->_tmp5_, _data_->_res_, &_data_->_inner_error_);
					if (_data_->_inner_error_ != NULL) {
						goto __catch15_g_error;
					}
				}
				goto __finally15;
				__catch15_g_error:
				{
					_data_->e = _data_->_inner_error_;
					_data_->_inner_error_ = NULL;
					_data_->_tmp6_ = ((FsoFrameworkAbstractObject*) _data_->self)->logger;
					_data_->_tmp7_ = _data_->r;
					_data_->_tmp8_ = usage_resource_get_name (_data_->_tmp7_);
					_data_->_tmp9_ = _data_->_tmp8_;
					_data_->_tmp10_ = NULL;
					_data_->_tmp10_ = string_to_string (_data_->_tmp9_);
					_data_->_tmp11_ = _data_->e;
					_data_->_tmp12_ = _data_->_tmp11_->message;
					_data_->_tmp13_ = NULL;
					_data_->_tmp13_ = string_to_string (_data_->_tmp12_);
					_data_->_tmp14_ = NULL;
					_data_->_tmp14_ = g_strconcat ("Error while trying to disable resource ", _data_->_tmp10_, ": ", _data_->_tmp13_, NULL);
					_data_->_tmp15_ = _data_->_tmp14_;
					fso_framework_logger_warning (_data_->_tmp6_, _data_->_tmp15_);
					_g_free0 (_data_->_tmp15_);
					_g_error_free0 (_data_->e);
				}
				__finally15:
				if (_data_->_inner_error_ != NULL) {
					_g_object_unref0 (_data_->r);
					_data_->r_collection = (_vala_array_free (_data_->r_collection, _data_->r_collection_length1, (GDestroyNotify) g_object_unref), NULL);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
					g_clear_error (&_data_->_inner_error_);
					return FALSE;
				}
				_g_object_unref0 (_data_->r);
			}
		}
		_data_->r_collection = (_vala_array_free (_data_->r_collection, _data_->r_collection_length1, (GDestroyNotify) g_object_unref), NULL);
	}
	_data_->_tmp16_ = ((FsoFrameworkAbstractObject*) _data_->self)->logger;
	_data_->_tmp17_ = FALSE;
	_data_->_tmp17_ = fso_framework_logger_debug (_data_->_tmp16_, "... done");
	g_assert (_data_->_tmp17_);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void usage_controller_suspendAllResources_data_free (gpointer _data) {
	usage_controller_suspendAllResourcesData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (usage_controller_suspendAllResourcesData, _data_);
}


void usage_controller_suspendAllResources (UsageController* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	usage_controller_suspendAllResourcesData* _data_;
	UsageController* _tmp0_;
	_data_ = g_slice_new0 (usage_controller_suspendAllResourcesData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, usage_controller_suspendAllResources);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, usage_controller_suspendAllResources_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	usage_controller_suspendAllResources_co (_data_);
}


void usage_controller_suspendAllResources_finish (UsageController* self, GAsyncResult* _res_) {
	usage_controller_suspendAllResourcesData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void usage_controller_suspendAllResources_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	usage_controller_suspendAllResourcesData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	usage_controller_suspendAllResources_co (_data_);
}


static gboolean usage_controller_suspendAllResources_co (usage_controller_suspendAllResourcesData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = ((FsoFrameworkAbstractObject*) _data_->self)->logger;
	_data_->_tmp1_ = FALSE;
	_data_->_tmp1_ = fso_framework_logger_debug (_data_->_tmp0_, "Suspending all resources...");
	g_assert (_data_->_tmp1_);
	_data_->_tmp2_ = 0;
	_data_->_tmp3_ = NULL;
	_data_->_tmp3_ = usage_controller_retrievePriorizedResourceList (_data_->self, FALSE, &_data_->_tmp2_);
	{
		_data_->r_collection_length1 = 0;
		_data_->_r_collection_size_ = 0;
		_data_->r_collection = _data_->_tmp3_;
		_data_->r_collection_length1 = _data_->_tmp2_;
		for (_data_->r_it = 0; _data_->r_it < _data_->_tmp2_; _data_->r_it = _data_->r_it + 1) {
			_data_->_tmp4_ = _g_object_ref0 (_data_->r_collection[_data_->r_it]);
			_data_->r = _data_->_tmp4_;
			{
				{
					_data_->_tmp5_ = _data_->r;
					_data_->_state_ = 1;
					usage_resource_suspend (_data_->_tmp5_, usage_controller_suspendAllResources_ready, _data_);
					return FALSE;
					_state_1:
					usage_resource_suspend_finish (_data_->_tmp5_, _data_->_res_, &_data_->_inner_error_);
					if (_data_->_inner_error_ != NULL) {
						goto __catch16_g_error;
					}
				}
				goto __finally16;
				__catch16_g_error:
				{
					_data_->e = _data_->_inner_error_;
					_data_->_inner_error_ = NULL;
					_data_->_tmp6_ = ((FsoFrameworkAbstractObject*) _data_->self)->logger;
					_data_->_tmp7_ = _data_->r;
					_data_->_tmp8_ = usage_resource_get_name (_data_->_tmp7_);
					_data_->_tmp9_ = _data_->_tmp8_;
					_data_->_tmp10_ = NULL;
					_data_->_tmp10_ = string_to_string (_data_->_tmp9_);
					_data_->_tmp11_ = _data_->e;
					_data_->_tmp12_ = _data_->_tmp11_->message;
					_data_->_tmp13_ = NULL;
					_data_->_tmp13_ = string_to_string (_data_->_tmp12_);
					_data_->_tmp14_ = NULL;
					_data_->_tmp14_ = g_strconcat ("Error while trying to suspend resource ", _data_->_tmp10_, ": ", _data_->_tmp13_, NULL);
					_data_->_tmp15_ = _data_->_tmp14_;
					fso_framework_logger_warning (_data_->_tmp6_, _data_->_tmp15_);
					_g_free0 (_data_->_tmp15_);
					_g_error_free0 (_data_->e);
				}
				__finally16:
				if (_data_->_inner_error_ != NULL) {
					_g_object_unref0 (_data_->r);
					_data_->r_collection = (_vala_array_free (_data_->r_collection, _data_->r_collection_length1, (GDestroyNotify) g_object_unref), NULL);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
					g_clear_error (&_data_->_inner_error_);
					return FALSE;
				}
				_g_object_unref0 (_data_->r);
			}
		}
		_data_->r_collection = (_vala_array_free (_data_->r_collection, _data_->r_collection_length1, (GDestroyNotify) g_object_unref), NULL);
	}
	_data_->_tmp16_ = ((FsoFrameworkAbstractObject*) _data_->self)->logger;
	_data_->_tmp17_ = FALSE;
	_data_->_tmp17_ = fso_framework_logger_debug (_data_->_tmp16_, "... done disabling.");
	g_assert (_data_->_tmp17_);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void usage_controller_resumeAllResources_data_free (gpointer _data) {
	usage_controller_resumeAllResourcesData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (usage_controller_resumeAllResourcesData, _data_);
}


void usage_controller_resumeAllResources (UsageController* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	usage_controller_resumeAllResourcesData* _data_;
	UsageController* _tmp0_;
	_data_ = g_slice_new0 (usage_controller_resumeAllResourcesData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, usage_controller_resumeAllResources);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, usage_controller_resumeAllResources_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	usage_controller_resumeAllResources_co (_data_);
}


void usage_controller_resumeAllResources_finish (UsageController* self, GAsyncResult* _res_) {
	usage_controller_resumeAllResourcesData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void usage_controller_resumeAllResources_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	usage_controller_resumeAllResourcesData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	usage_controller_resumeAllResources_co (_data_);
}


static gboolean usage_controller_resumeAllResources_co (usage_controller_resumeAllResourcesData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = ((FsoFrameworkAbstractObject*) _data_->self)->logger;
	_data_->_tmp1_ = FALSE;
	_data_->_tmp1_ = fso_framework_logger_debug (_data_->_tmp0_, "Resuming all resources...");
	g_assert (_data_->_tmp1_);
	_data_->_tmp2_ = 0;
	_data_->_tmp3_ = NULL;
	_data_->_tmp3_ = usage_controller_retrievePriorizedResourceList (_data_->self, TRUE, &_data_->_tmp2_);
	{
		_data_->r_collection_length1 = 0;
		_data_->_r_collection_size_ = 0;
		_data_->r_collection = _data_->_tmp3_;
		_data_->r_collection_length1 = _data_->_tmp2_;
		for (_data_->r_it = 0; _data_->r_it < _data_->_tmp2_; _data_->r_it = _data_->r_it + 1) {
			_data_->_tmp4_ = _g_object_ref0 (_data_->r_collection[_data_->r_it]);
			_data_->r = _data_->_tmp4_;
			{
				{
					_data_->_tmp5_ = ((FsoFrameworkAbstractObject*) _data_->self)->logger;
					_data_->_tmp6_ = _data_->r;
					_data_->_tmp7_ = usage_resource_get_name (_data_->_tmp6_);
					_data_->_tmp8_ = _data_->_tmp7_;
					_data_->_tmp9_ = NULL;
					_data_->_tmp9_ = string_to_string (_data_->_tmp8_);
					_data_->_tmp10_ = NULL;
					_data_->_tmp10_ = g_strconcat ("Resuming resource '", _data_->_tmp9_, "'", NULL);
					_data_->_tmp11_ = _data_->_tmp10_;
					_data_->_tmp12_ = FALSE;
					_data_->_tmp12_ = fso_framework_logger_debug (_data_->_tmp5_, _data_->_tmp11_);
					g_assert (_data_->_tmp12_);
					_g_free0 (_data_->_tmp11_);
					_data_->_tmp13_ = _data_->r;
					_data_->_state_ = 1;
					usage_resource_resume (_data_->_tmp13_, usage_controller_resumeAllResources_ready, _data_);
					return FALSE;
					_state_1:
					usage_resource_resume_finish (_data_->_tmp13_, _data_->_res_, &_data_->_inner_error_);
					if (_data_->_inner_error_ != NULL) {
						goto __catch17_g_error;
					}
				}
				goto __finally17;
				__catch17_g_error:
				{
					_data_->e = _data_->_inner_error_;
					_data_->_inner_error_ = NULL;
					_data_->_tmp14_ = ((FsoFrameworkAbstractObject*) _data_->self)->logger;
					_data_->_tmp15_ = _data_->r;
					_data_->_tmp16_ = usage_resource_get_name (_data_->_tmp15_);
					_data_->_tmp17_ = _data_->_tmp16_;
					_data_->_tmp18_ = NULL;
					_data_->_tmp18_ = string_to_string (_data_->_tmp17_);
					_data_->_tmp19_ = _data_->e;
					_data_->_tmp20_ = _data_->_tmp19_->message;
					_data_->_tmp21_ = NULL;
					_data_->_tmp21_ = string_to_string (_data_->_tmp20_);
					_data_->_tmp22_ = NULL;
					_data_->_tmp22_ = g_strconcat ("Error while trying to resume resource ", _data_->_tmp18_, ": ", _data_->_tmp21_, NULL);
					_data_->_tmp23_ = _data_->_tmp22_;
					fso_framework_logger_warning (_data_->_tmp14_, _data_->_tmp23_);
					_g_free0 (_data_->_tmp23_);
					_g_error_free0 (_data_->e);
				}
				__finally17:
				if (_data_->_inner_error_ != NULL) {
					_g_object_unref0 (_data_->r);
					_data_->r_collection = (_vala_array_free (_data_->r_collection, _data_->r_collection_length1, (GDestroyNotify) g_object_unref), NULL);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
					g_clear_error (&_data_->_inner_error_);
					return FALSE;
				}
				_g_object_unref0 (_data_->r);
			}
		}
		_data_->r_collection = (_vala_array_free (_data_->r_collection, _data_->r_collection_length1, (GDestroyNotify) g_object_unref), NULL);
	}
	_data_->_tmp24_ = ((FsoFrameworkAbstractObject*) _data_->self)->logger;
	_data_->_tmp25_ = FALSE;
	_data_->_tmp25_ = fso_framework_logger_debug (_data_->_tmp24_, "... done resuming.");
	g_assert (_data_->_tmp25_);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


void usage_controller_register_resource (UsageController* self, const char* sender, const gchar* name, const char* path, GError** error) {
	GeeHashMap* _tmp0_;
	GeeSet* _tmp1_;
	GeeSet* _tmp2_;
	GeeSet* _tmp3_;
	const gchar* _tmp4_;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp6_;
	const gchar* _tmp33_;
	const char* _tmp34_;
	const char* _tmp35_;
	UsageResource* _tmp36_;
	UsageResource* r;
	GeeHashMap* _tmp37_;
	const gchar* _tmp38_;
	UsageResource* _tmp39_;
	UsageResource* _tmp40_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (sender != NULL);
	g_return_if_fail (name != NULL);
	g_return_if_fail (path != NULL);
	_tmp0_ = self->priv->resources;
	_tmp1_ = gee_abstract_map_get_keys ((GeeMap*) _tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = _tmp2_;
	_tmp4_ = name;
	_tmp5_ = gee_collection_contains ((GeeCollection*) _tmp3_, _tmp4_);
	_tmp6_ = _tmp5_;
	_g_object_unref0 (_tmp3_);
	if (_tmp6_) {
		GeeHashMap* _tmp7_;
		const gchar* _tmp8_;
		gpointer _tmp9_ = NULL;
		UsageResource* _tmp10_;
		const char* _tmp11_;
		const char* _tmp12_;
		gboolean _tmp13_;
		_tmp7_ = self->priv->resources;
		_tmp8_ = name;
		_tmp9_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp7_, _tmp8_);
		_tmp10_ = (UsageResource*) _tmp9_;
		_tmp11_ = usage_resource_get_objectpath (_tmp10_);
		_tmp12_ = _tmp11_;
		_tmp13_ = _tmp12_ != NULL;
		_g_object_unref0 (_tmp10_);
		if (_tmp13_) {
			const gchar* _tmp14_;
			const gchar* _tmp15_ = NULL;
			gchar* _tmp16_ = NULL;
			gchar* _tmp17_;
			GError* _tmp18_;
			GError* _tmp19_;
			_tmp14_ = name;
			_tmp15_ = string_to_string (_tmp14_);
			_tmp16_ = g_strconcat ("Resource ", _tmp15_, " already registered", NULL);
			_tmp17_ = _tmp16_;
			_tmp18_ = g_error_new_literal (FREE_SMARTPHONE_USAGE_ERROR, FREE_SMARTPHONE_USAGE_ERROR_RESOURCE_EXISTS, _tmp17_);
			_tmp19_ = _tmp18_;
			_g_free0 (_tmp17_);
			_inner_error_ = _tmp19_;
			if ((((_inner_error_->domain == FREE_SMARTPHONE_USAGE_ERROR) || (_inner_error_->domain == FREE_SMARTPHONE_ERROR)) || (_inner_error_->domain == G_DBUS_ERROR)) || (_inner_error_->domain == G_IO_ERROR)) {
				g_propagate_error (error, _inner_error_);
				return;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		} else {
			GeeHashMap* _tmp20_;
			const gchar* _tmp21_;
			gpointer _tmp22_ = NULL;
			UsageResource* _tmp23_;
			const char* _tmp24_;
			const char* _tmp25_;
			const char* _tmp26_;
			FreeSmartphoneResource* _tmp27_ = NULL;
			FreeSmartphoneResource* _tmp28_;
			GeeHashMap* _tmp29_;
			const gchar* _tmp30_;
			gpointer _tmp31_ = NULL;
			UsageResource* _tmp32_;
			_tmp20_ = self->priv->resources;
			_tmp21_ = name;
			_tmp22_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp20_, _tmp21_);
			_tmp23_ = (UsageResource*) _tmp22_;
			_tmp24_ = path;
			usage_resource_set_objectpath (_tmp23_, _tmp24_);
			_g_object_unref0 (_tmp23_);
			_tmp25_ = sender;
			_tmp26_ = path;
			_tmp27_ = g_initable_new (FREE_SMARTPHONE_TYPE_RESOURCE_PROXY, NULL, &_inner_error_, "g-flags", 0, "g-name", (const gchar*) _tmp25_, "g-bus-type", G_BUS_TYPE_SYSTEM, "g-object-path", (const gchar*) _tmp26_, "g-interface-name", "org.freesmartphone.Resource", NULL);
			_tmp28_ = (FreeSmartphoneResource*) _tmp27_;
			if (_inner_error_ != NULL) {
				if ((((_inner_error_->domain == FREE_SMARTPHONE_USAGE_ERROR) || (_inner_error_->domain == FREE_SMARTPHONE_ERROR)) || (_inner_error_->domain == G_DBUS_ERROR)) || (_inner_error_->domain == G_IO_ERROR)) {
					g_propagate_error (error, _inner_error_);
					return;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
			_tmp29_ = self->priv->resources;
			_tmp30_ = name;
			_tmp31_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp29_, _tmp30_);
			_tmp32_ = (UsageResource*) _tmp31_;
			_g_object_unref0 (_tmp32_->proxy);
			_tmp32_->proxy = _tmp28_;
			_g_object_unref0 (_tmp32_);
			return;
		}
	}
	_tmp33_ = name;
	_tmp34_ = sender;
	_tmp35_ = path;
	_tmp36_ = usage_resource_new (_tmp33_, _tmp34_, _tmp35_);
	r = _tmp36_;
	_tmp37_ = self->priv->resources;
	_tmp38_ = name;
	_tmp39_ = r;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp37_, _tmp38_, _tmp39_);
	_tmp40_ = r;
	usage_controller_onResourceAppearing (self, _tmp40_, NULL, NULL);
	_g_object_unref0 (r);
}


void usage_controller_unregister_resource (UsageController* self, const char* sender, const gchar* name, GError** error) {
	const gchar* _tmp0_;
	UsageResource* _tmp1_ = NULL;
	UsageResource* r;
	UsageResource* _tmp2_;
	const char* _tmp3_;
	const char* _tmp4_;
	const char* _tmp5_;
	UsageResource* _tmp12_;
	GeeHashMap* _tmp13_;
	const gchar* _tmp14_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (sender != NULL);
	g_return_if_fail (name != NULL);
	_tmp0_ = name;
	_tmp1_ = usage_controller_getResource (self, _tmp0_, &_inner_error_);
	r = _tmp1_;
	if (_inner_error_ != NULL) {
		if ((((_inner_error_->domain == FREE_SMARTPHONE_ERROR) || (_inner_error_->domain == FREE_SMARTPHONE_USAGE_ERROR)) || (_inner_error_->domain == G_DBUS_ERROR)) || (_inner_error_->domain == G_IO_ERROR)) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp2_ = r;
	_tmp3_ = usage_resource_get_busname (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = sender;
	if (g_strcmp0 (_tmp4_, _tmp5_) != 0) {
		const gchar* _tmp6_;
		const gchar* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		gchar* _tmp9_;
		GError* _tmp10_;
		GError* _tmp11_;
		_tmp6_ = name;
		_tmp7_ = string_to_string (_tmp6_);
		_tmp8_ = g_strconcat ("Resource ", _tmp7_, " not yours", NULL);
		_tmp9_ = _tmp8_;
		_tmp10_ = g_error_new_literal (FREE_SMARTPHONE_USAGE_ERROR, FREE_SMARTPHONE_USAGE_ERROR_RESOURCE_UNKNOWN, _tmp9_);
		_tmp11_ = _tmp10_;
		_g_free0 (_tmp9_);
		_inner_error_ = _tmp11_;
		if ((((_inner_error_->domain == FREE_SMARTPHONE_ERROR) || (_inner_error_->domain == FREE_SMARTPHONE_USAGE_ERROR)) || (_inner_error_->domain == G_DBUS_ERROR)) || (_inner_error_->domain == G_IO_ERROR)) {
			g_propagate_error (error, _inner_error_);
			_g_object_unref0 (r);
			return;
		} else {
			_g_object_unref0 (r);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp12_ = r;
	usage_controller_onResourceVanishing (self, _tmp12_);
	_tmp13_ = self->priv->resources;
	_tmp14_ = name;
	gee_abstract_map_unset ((GeeAbstractMap*) _tmp13_, _tmp14_, NULL);
	_g_object_unref0 (r);
}


void usage_controller_shutdownPlugin (UsageController* self) {
	gboolean _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->disable_on_shutdown;
	if (_tmp0_) {
		usage_controller_disableAllResources (self, NULL, NULL);
	}
}


void usage_controller_updateSystemStatus (UsageController* self, FreeSmartphoneUsageSystemAction action) {
	FreeSmartphoneUsageSystemAction _tmp0_;
	FreeSmartphoneUsageSystemAction _tmp1_;
	FreeSmartphoneUsageSystemAction _tmp2_;
	FreeSmartphoneUsageSystemAction _tmp3_;
	g_return_if_fail (self != NULL);
	_tmp0_ = action;
	_tmp1_ = self->priv->system_status;
	if (_tmp0_ == _tmp1_) {
		return;
	}
	_tmp2_ = action;
	self->priv->system_status = _tmp2_;
	_tmp3_ = action;
	g_signal_emit_by_name (self, "system-action", _tmp3_);
}


static void usage_controller_get_resource_policy_data_free (gpointer _data) {
	UsageControllerGetResourcePolicyData* _data_;
	_data_ = _data;
	_g_free0 (_data_->name);
	_g_free0 (_data_->result);
	_g_object_unref0 (_data_->self);
	g_slice_free (UsageControllerGetResourcePolicyData, _data_);
}


void usage_controller_get_resource_policy (UsageController* self, const gchar* name, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	UsageControllerGetResourcePolicyData* _data_;
	UsageController* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	_data_ = g_slice_new0 (UsageControllerGetResourcePolicyData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, usage_controller_get_resource_policy);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, usage_controller_get_resource_policy_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = name;
	_tmp2_ = g_strdup (_tmp1_);
	_data_->name = _tmp2_;
	usage_controller_get_resource_policy_co (_data_);
}


gchar* usage_controller_get_resource_policy_finish (UsageController* self, GAsyncResult* _res_, GError** error) {
	gchar* result;
	UsageControllerGetResourcePolicyData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return NULL;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
	result = _data_->result;
	_data_->result = NULL;
	return result;
}


static gboolean usage_controller_get_resource_policy_co (UsageControllerGetResourcePolicyData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = _data_->name;
	_data_->_tmp1_ = NULL;
	_data_->_tmp1_ = usage_controller_getResource (_data_->self, _data_->_tmp0_, &_data_->_inner_error_);
	_data_->_tmp2_ = _data_->_tmp1_;
	if (_data_->_inner_error_ != NULL) {
		if ((((_data_->_inner_error_->domain == FREE_SMARTPHONE_USAGE_ERROR) || (_data_->_inner_error_->domain == FREE_SMARTPHONE_ERROR)) || (_data_->_inner_error_->domain == G_DBUS_ERROR)) || (_data_->_inner_error_->domain == G_IO_ERROR)) {
			g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
			g_error_free (_data_->_inner_error_);
			if (_data_->_state_ == 0) {
				g_simple_async_result_complete_in_idle (_data_->_async_result);
			} else {
				g_simple_async_result_complete (_data_->_async_result);
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
	}
	_data_->_tmp3_ = _data_->_tmp2_;
	_data_->_tmp4_ = usage_resource_get_policy (_data_->_tmp3_);
	_data_->_tmp5_ = _data_->_tmp4_;
	_data_->_tmp6_ = _data_->_tmp5_;
	_g_object_unref0 (_data_->_tmp3_);
	switch (_data_->_tmp6_) {
		case FREE_SMARTPHONE_USAGE_RESOURCE_POLICY_ENABLED:
		{
			_data_->_tmp7_ = g_strdup ("enabled");
			_data_->result = _data_->_tmp7_;
			if (_data_->_state_ == 0) {
				g_simple_async_result_complete_in_idle (_data_->_async_result);
			} else {
				g_simple_async_result_complete (_data_->_async_result);
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		}
		case FREE_SMARTPHONE_USAGE_RESOURCE_POLICY_DISABLED:
		{
			_data_->_tmp8_ = g_strdup ("disabled");
			_data_->result = _data_->_tmp8_;
			if (_data_->_state_ == 0) {
				g_simple_async_result_complete_in_idle (_data_->_async_result);
			} else {
				g_simple_async_result_complete (_data_->_async_result);
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		}
		case FREE_SMARTPHONE_USAGE_RESOURCE_POLICY_AUTO:
		{
			_data_->_tmp9_ = g_strdup ("auto");
			_data_->result = _data_->_tmp9_;
			if (_data_->_state_ == 0) {
				g_simple_async_result_complete_in_idle (_data_->_async_result);
			} else {
				g_simple_async_result_complete (_data_->_async_result);
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		}
		default:
		{
			_data_->_tmp10_ = _data_->name;
			_data_->_tmp11_ = NULL;
			_data_->_tmp11_ = usage_controller_getResource (_data_->self, _data_->_tmp10_, &_data_->_inner_error_);
			_data_->_tmp12_ = _data_->_tmp11_;
			if (_data_->_inner_error_ != NULL) {
				if ((((_data_->_inner_error_->domain == FREE_SMARTPHONE_USAGE_ERROR) || (_data_->_inner_error_->domain == FREE_SMARTPHONE_ERROR)) || (_data_->_inner_error_->domain == G_DBUS_ERROR)) || (_data_->_inner_error_->domain == G_IO_ERROR)) {
					g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
					g_error_free (_data_->_inner_error_);
					if (_data_->_state_ == 0) {
						g_simple_async_result_complete_in_idle (_data_->_async_result);
					} else {
						g_simple_async_result_complete (_data_->_async_result);
					}
					g_object_unref (_data_->_async_result);
					return FALSE;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
					g_clear_error (&_data_->_inner_error_);
					return FALSE;
				}
			}
			_data_->_tmp13_ = _data_->_tmp12_;
			_data_->_tmp14_ = usage_resource_get_policy (_data_->_tmp13_);
			_data_->_tmp15_ = _data_->_tmp14_;
			_data_->_tmp16_ = _data_->name;
			_data_->_tmp17_ = NULL;
			_data_->_tmp17_ = g_strdup_printf ("unknown resource policy value %d for resource %s", (gint) _data_->_tmp15_, _data_->_tmp16_);
			_data_->_tmp18_ = _data_->_tmp17_;
			_g_object_unref0 (_data_->_tmp13_);
			_data_->_error_ = _data_->_tmp18_;
			_data_->_tmp19_ = ((FsoFrameworkAbstractObject*) _data_->self)->logger;
			_data_->_tmp20_ = _data_->_error_;
			fso_framework_logger_error (_data_->_tmp19_, _data_->_tmp20_);
			_data_->_tmp21_ = _data_->_error_;
			_data_->_tmp22_ = g_error_new_literal (FREE_SMARTPHONE_ERROR, FREE_SMARTPHONE_ERROR_INTERNAL_ERROR, _data_->_tmp21_);
			_data_->_inner_error_ = _data_->_tmp22_;
			if ((((_data_->_inner_error_->domain == FREE_SMARTPHONE_USAGE_ERROR) || (_data_->_inner_error_->domain == FREE_SMARTPHONE_ERROR)) || (_data_->_inner_error_->domain == G_DBUS_ERROR)) || (_data_->_inner_error_->domain == G_IO_ERROR)) {
				g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
				g_error_free (_data_->_inner_error_);
				_g_free0 (_data_->_error_);
				if (_data_->_state_ == 0) {
					g_simple_async_result_complete_in_idle (_data_->_async_result);
				} else {
					g_simple_async_result_complete (_data_->_async_result);
				}
				g_object_unref (_data_->_async_result);
				return FALSE;
			} else {
				_g_free0 (_data_->_error_);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
				g_clear_error (&_data_->_inner_error_);
				return FALSE;
			}
			_g_free0 (_data_->_error_);
		}
	}
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void usage_controller_set_resource_policy_data_free (gpointer _data) {
	UsageControllerSetResourcePolicyData* _data_;
	_data_ = _data;
	_g_free0 (_data_->name);
	_g_free0 (_data_->policy);
	_g_object_unref0 (_data_->self);
	g_slice_free (UsageControllerSetResourcePolicyData, _data_);
}


void usage_controller_set_resource_policy (UsageController* self, const gchar* name, const gchar* policy, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	UsageControllerSetResourcePolicyData* _data_;
	UsageController* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	const gchar* _tmp3_;
	gchar* _tmp4_;
	_data_ = g_slice_new0 (UsageControllerSetResourcePolicyData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, usage_controller_set_resource_policy);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, usage_controller_set_resource_policy_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = name;
	_tmp2_ = g_strdup (_tmp1_);
	_data_->name = _tmp2_;
	_tmp3_ = policy;
	_tmp4_ = g_strdup (_tmp3_);
	_data_->policy = _tmp4_;
	usage_controller_set_resource_policy_co (_data_);
}


void usage_controller_set_resource_policy_finish (UsageController* self, GAsyncResult* _res_, GError** error) {
	UsageControllerSetResourcePolicyData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void usage_controller_set_resource_policy_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	UsageControllerSetResourcePolicyData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	usage_controller_set_resource_policy_co (_data_);
}


static gboolean usage_controller_set_resource_policy_co (UsageControllerSetResourcePolicyData* _data_) {
	static GQuark _tmp11_label0 = 0;
	static GQuark _tmp11_label1 = 0;
	static GQuark _tmp11_label2 = 0;
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = ((FsoFrameworkAbstractObject*) _data_->self)->logger;
	_data_->_tmp1_ = _data_->name;
	_data_->_tmp2_ = NULL;
	_data_->_tmp2_ = string_to_string (_data_->_tmp1_);
	_data_->_tmp3_ = _data_->policy;
	_data_->_tmp4_ = NULL;
	_data_->_tmp4_ = string_to_string (_data_->_tmp3_);
	_data_->_tmp5_ = NULL;
	_data_->_tmp5_ = g_strconcat ("Set resource policy for ", _data_->_tmp2_, " to ", _data_->_tmp4_, NULL);
	_data_->_tmp6_ = _data_->_tmp5_;
	fso_framework_logger_debug (_data_->_tmp0_, _data_->_tmp6_);
	_g_free0 (_data_->_tmp6_);
	_data_->_tmp7_ = _data_->name;
	_data_->_tmp8_ = NULL;
	_data_->_tmp8_ = usage_controller_getResource (_data_->self, _data_->_tmp7_, &_data_->_inner_error_);
	_data_->resource = _data_->_tmp8_;
	if (_data_->_inner_error_ != NULL) {
		g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
		g_error_free (_data_->_inner_error_);
		if (_data_->_state_ == 0) {
			g_simple_async_result_complete_in_idle (_data_->_async_result);
		} else {
			g_simple_async_result_complete (_data_->_async_result);
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->policyToSet = FREE_SMARTPHONE_USAGE_RESOURCE_POLICY_AUTO;
	_data_->_tmp9_ = _data_->policy;
	_data_->_tmp12_ = 0U;
	_data_->_tmp10_ = _data_->_tmp9_;
	_data_->_tmp12_ = (NULL == _data_->_tmp10_) ? 0 : g_quark_from_string (_data_->_tmp10_);
	if (_data_->_tmp12_ == ((0 != _tmp11_label0) ? _tmp11_label0 : (_tmp11_label0 = g_quark_from_static_string ("enabled")))) {
		switch (0) {
			default:
			{
				_data_->policyToSet = FREE_SMARTPHONE_USAGE_RESOURCE_POLICY_ENABLED;
				break;
			}
		}
	} else if (_data_->_tmp12_ == ((0 != _tmp11_label1) ? _tmp11_label1 : (_tmp11_label1 = g_quark_from_static_string ("disabled")))) {
		switch (0) {
			default:
			{
				_data_->policyToSet = FREE_SMARTPHONE_USAGE_RESOURCE_POLICY_DISABLED;
				break;
			}
		}
	} else if (_data_->_tmp12_ == ((0 != _tmp11_label2) ? _tmp11_label2 : (_tmp11_label2 = g_quark_from_static_string ("auto")))) {
		switch (0) {
			default:
			{
				_data_->policyToSet = FREE_SMARTPHONE_USAGE_RESOURCE_POLICY_AUTO;
				break;
			}
		}
	} else {
		switch (0) {
			default:
			{
				_data_->_tmp13_ = g_error_new_literal (FREE_SMARTPHONE_ERROR, FREE_SMARTPHONE_ERROR_INVALID_PARAMETER, "ResourcePolicy needs to be one of { \"enabled\", \"disabled\", \"auto\"" \
" }");
				_data_->_inner_error_ = _data_->_tmp13_;
				g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
				g_error_free (_data_->_inner_error_);
				_g_object_unref0 (_data_->resource);
				if (_data_->_state_ == 0) {
					g_simple_async_result_complete_in_idle (_data_->_async_result);
				} else {
					g_simple_async_result_complete (_data_->_async_result);
				}
				g_object_unref (_data_->_async_result);
				return FALSE;
			}
		}
	}
	_data_->_tmp14_ = _data_->resource;
	_data_->_tmp15_ = _data_->policyToSet;
	_data_->_state_ = 1;
	usage_resource_setPolicy (_data_->_tmp14_, _data_->_tmp15_, usage_controller_set_resource_policy_ready, _data_);
	return FALSE;
	_state_1:
	usage_resource_setPolicy_finish (_data_->_tmp14_, _data_->_res_, &_data_->_inner_error_);
	if (_data_->_inner_error_ != NULL) {
		g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
		g_error_free (_data_->_inner_error_);
		_g_object_unref0 (_data_->resource);
		if (_data_->_state_ == 0) {
			g_simple_async_result_complete_in_idle (_data_->_async_result);
		} else {
			g_simple_async_result_complete (_data_->_async_result);
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_g_object_unref0 (_data_->resource);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void usage_controller_get_resource_state_data_free (gpointer _data) {
	UsageControllerGetResourceStateData* _data_;
	_data_ = _data;
	_g_free0 (_data_->name);
	_g_object_unref0 (_data_->self);
	g_slice_free (UsageControllerGetResourceStateData, _data_);
}


void usage_controller_get_resource_state (UsageController* self, const gchar* name, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	UsageControllerGetResourceStateData* _data_;
	UsageController* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	_data_ = g_slice_new0 (UsageControllerGetResourceStateData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, usage_controller_get_resource_state);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, usage_controller_get_resource_state_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = name;
	_tmp2_ = g_strdup (_tmp1_);
	_data_->name = _tmp2_;
	usage_controller_get_resource_state_co (_data_);
}


gboolean usage_controller_get_resource_state_finish (UsageController* self, GAsyncResult* _res_, GError** error) {
	gboolean result;
	UsageControllerGetResourceStateData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return FALSE;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
	result = _data_->result;
	return result;
}


static gboolean usage_controller_get_resource_state_co (UsageControllerGetResourceStateData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = _data_->name;
	_data_->_tmp1_ = NULL;
	_data_->_tmp1_ = usage_controller_getResource (_data_->self, _data_->_tmp0_, &_data_->_inner_error_);
	_data_->_tmp2_ = _data_->_tmp1_;
	if (_data_->_inner_error_ != NULL) {
		if ((((_data_->_inner_error_->domain == FREE_SMARTPHONE_ERROR) || (_data_->_inner_error_->domain == FREE_SMARTPHONE_USAGE_ERROR)) || (_data_->_inner_error_->domain == G_DBUS_ERROR)) || (_data_->_inner_error_->domain == G_IO_ERROR)) {
			g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
			g_error_free (_data_->_inner_error_);
			if (_data_->_state_ == 0) {
				g_simple_async_result_complete_in_idle (_data_->_async_result);
			} else {
				g_simple_async_result_complete (_data_->_async_result);
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
	}
	_data_->_tmp3_ = _data_->_tmp2_;
	_data_->_tmp4_ = FALSE;
	_data_->_tmp4_ = usage_resource_isEnabled (_data_->_tmp3_);
	_data_->_tmp5_ = _data_->_tmp4_;
	_g_object_unref0 (_data_->_tmp3_);
	_data_->result = _data_->_tmp5_;
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void usage_controller_get_resource_users_data_free (gpointer _data) {
	UsageControllerGetResourceUsersData* _data_;
	_data_ = _data;
	_g_free0 (_data_->name);
	_data_->result = (_vala_array_free (_data_->result, _data_->result_length1, (GDestroyNotify) g_free), NULL);
	_g_object_unref0 (_data_->self);
	g_slice_free (UsageControllerGetResourceUsersData, _data_);
}


void usage_controller_get_resource_users (UsageController* self, const gchar* name, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	UsageControllerGetResourceUsersData* _data_;
	UsageController* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	_data_ = g_slice_new0 (UsageControllerGetResourceUsersData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, usage_controller_get_resource_users);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, usage_controller_get_resource_users_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = name;
	_tmp2_ = g_strdup (_tmp1_);
	_data_->name = _tmp2_;
	usage_controller_get_resource_users_co (_data_);
}


gchar** usage_controller_get_resource_users_finish (UsageController* self, GAsyncResult* _res_, int* result_length1, GError** error) {
	gchar** result;
	UsageControllerGetResourceUsersData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return NULL;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
	result = _data_->result;
	*result_length1 = _data_->result_length1;
	_data_->result = NULL;
	return result;
}


static gboolean usage_controller_get_resource_users_co (UsageControllerGetResourceUsersData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = _data_->name;
	_data_->_tmp1_ = NULL;
	_data_->_tmp1_ = usage_controller_getResource (_data_->self, _data_->_tmp0_, &_data_->_inner_error_);
	_data_->_tmp2_ = _data_->_tmp1_;
	if (_data_->_inner_error_ != NULL) {
		if ((((_data_->_inner_error_->domain == FREE_SMARTPHONE_ERROR) || (_data_->_inner_error_->domain == FREE_SMARTPHONE_USAGE_ERROR)) || (_data_->_inner_error_->domain == G_DBUS_ERROR)) || (_data_->_inner_error_->domain == G_IO_ERROR)) {
			g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
			g_error_free (_data_->_inner_error_);
			if (_data_->_state_ == 0) {
				g_simple_async_result_complete_in_idle (_data_->_async_result);
			} else {
				g_simple_async_result_complete (_data_->_async_result);
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
	}
	_data_->_tmp3_ = _data_->_tmp2_;
	_data_->_tmp4_ = 0;
	_data_->_tmp5_ = NULL;
	_data_->_tmp5_ = usage_resource_allUsers (_data_->_tmp3_, &_data_->_tmp4_);
	_data_->_tmp6_ = _data_->_tmp5_;
	_data_->_tmp6__length1 = _data_->_tmp4_;
	_g_object_unref0 (_data_->_tmp3_);
	_data_->_tmp7_ = _data_->_tmp6_;
	_data_->_tmp7__length1 = _data_->_tmp6__length1;
	_data_->result_length1 = _data_->_tmp7__length1;
	_data_->result = _data_->_tmp7_;
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void usage_controller_list_resources_data_free (gpointer _data) {
	UsageControllerListResourcesData* _data_;
	_data_ = _data;
	_data_->result = (_vala_array_free (_data_->result, _data_->result_length1, (GDestroyNotify) g_free), NULL);
	_g_object_unref0 (_data_->self);
	g_slice_free (UsageControllerListResourcesData, _data_);
}


void usage_controller_list_resources (UsageController* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	UsageControllerListResourcesData* _data_;
	UsageController* _tmp0_;
	_data_ = g_slice_new0 (UsageControllerListResourcesData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, usage_controller_list_resources);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, usage_controller_list_resources_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	usage_controller_list_resources_co (_data_);
}


gchar** usage_controller_list_resources_finish (UsageController* self, GAsyncResult* _res_, int* result_length1, GError** error) {
	gchar** result;
	UsageControllerListResourcesData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return NULL;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
	result = _data_->result;
	*result_length1 = _data_->result_length1;
	_data_->result = NULL;
	return result;
}


static void _vala_array_add2 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static gboolean usage_controller_list_resources_co (UsageControllerListResourcesData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = NULL;
	_data_->_tmp0_ = g_new0 (gchar*, 0 + 1);
	_data_->res = _data_->_tmp0_;
	_data_->res_length1 = 0;
	_data_->_res_size_ = _data_->res_length1;
	{
		_data_->_tmp1_ = _data_->self->priv->resources;
		_data_->_tmp2_ = gee_abstract_map_get_keys ((GeeMap*) _data_->_tmp1_);
		_data_->_tmp3_ = _data_->_tmp2_;
		_data_->_tmp4_ = _data_->_tmp3_;
		_data_->_tmp5_ = NULL;
		_data_->_tmp5_ = gee_iterable_iterator ((GeeIterable*) _data_->_tmp4_);
		_data_->_tmp6_ = _data_->_tmp5_;
		_g_object_unref0 (_data_->_tmp4_);
		_data_->_key_it = _data_->_tmp6_;
		while (TRUE) {
			_data_->_tmp7_ = _data_->_key_it;
			_data_->_tmp8_ = FALSE;
			_data_->_tmp8_ = gee_iterator_next (_data_->_tmp7_);
			if (!_data_->_tmp8_) {
				break;
			}
			_data_->_tmp9_ = _data_->_key_it;
			_data_->_tmp10_ = NULL;
			_data_->_tmp10_ = gee_iterator_get (_data_->_tmp9_);
			_data_->key = (gchar*) _data_->_tmp10_;
			_data_->_tmp11_ = _data_->res;
			_data_->_tmp11__length1 = _data_->res_length1;
			_data_->_tmp12_ = _data_->key;
			_data_->_tmp13_ = g_strdup (_data_->_tmp12_);
			_vala_array_add2 (&_data_->res, &_data_->res_length1, &_data_->_res_size_, _data_->_tmp13_);
			_g_free0 (_data_->key);
		}
		_g_object_unref0 (_data_->_key_it);
	}
	_data_->_tmp14_ = _data_->res;
	_data_->_tmp14__length1 = _data_->res_length1;
	_data_->result_length1 = _data_->_tmp14__length1;
	_data_->result = _data_->_tmp14_;
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
	_data_->res = (_vala_array_free (_data_->res, _data_->res_length1, (GDestroyNotify) g_free), NULL);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void usage_controller_request_resource_data_free (gpointer _data) {
	UsageControllerRequestResourceData* _data_;
	_data_ = _data;
	_g_free0 (_data_->sender);
	_g_free0 (_data_->name);
	_g_object_unref0 (_data_->self);
	g_slice_free (UsageControllerRequestResourceData, _data_);
}


void usage_controller_request_resource (UsageController* self, const char* sender, const gchar* name, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	UsageControllerRequestResourceData* _data_;
	UsageController* _tmp0_;
	const char* _tmp1_;
	char* _tmp2_;
	const gchar* _tmp3_;
	gchar* _tmp4_;
	_data_ = g_slice_new0 (UsageControllerRequestResourceData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, usage_controller_request_resource);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, usage_controller_request_resource_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = sender;
	_tmp2_ = g_strdup (_tmp1_);
	_data_->sender = _tmp2_;
	_tmp3_ = name;
	_tmp4_ = g_strdup (_tmp3_);
	_data_->name = _tmp4_;
	usage_controller_request_resource_co (_data_);
}


void usage_controller_request_resource_finish (UsageController* self, GAsyncResult* _res_, GError** error) {
	UsageControllerRequestResourceData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void usage_controller_request_resource_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	UsageControllerRequestResourceData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	usage_controller_request_resource_co (_data_);
}


static gboolean usage_controller_request_resource_co (UsageControllerRequestResourceData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = _data_->name;
	_data_->_tmp1_ = NULL;
	_data_->_tmp1_ = usage_controller_getResource (_data_->self, _data_->_tmp0_, &_data_->_inner_error_);
	_data_->_tmp2_ = _data_->_tmp1_;
	if (_data_->_inner_error_ != NULL) {
		if (((((_data_->_inner_error_->domain == FREE_SMARTPHONE_ERROR) || (_data_->_inner_error_->domain == FREE_SMARTPHONE_RESOURCE_ERROR)) || (_data_->_inner_error_->domain == FREE_SMARTPHONE_USAGE_ERROR)) || (_data_->_inner_error_->domain == G_DBUS_ERROR)) || (_data_->_inner_error_->domain == G_IO_ERROR)) {
			g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
			g_error_free (_data_->_inner_error_);
			if (_data_->_state_ == 0) {
				g_simple_async_result_complete_in_idle (_data_->_async_result);
			} else {
				g_simple_async_result_complete (_data_->_async_result);
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
	}
	_data_->_tmp3_ = _data_->_tmp2_;
	_data_->_tmp4_ = usage_request_resource_new (_data_->_tmp3_);
	_data_->_tmp5_ = _data_->_tmp4_;
	_g_object_unref0 (_data_->_tmp3_);
	_data_->cmd = _data_->_tmp5_;
	_data_->_tmp6_ = _data_->cmd;
	_data_->_tmp7_ = _data_->sender;
	_data_->_state_ = 1;
	usage_request_resource_run (_data_->_tmp6_, _data_->_tmp7_, usage_controller_request_resource_ready, _data_);
	return FALSE;
	_state_1:
	usage_request_resource_run_finish (_data_->_tmp6_, _data_->_res_, &_data_->_inner_error_);
	if (_data_->_inner_error_ != NULL) {
		if (((((_data_->_inner_error_->domain == FREE_SMARTPHONE_ERROR) || (_data_->_inner_error_->domain == FREE_SMARTPHONE_RESOURCE_ERROR)) || (_data_->_inner_error_->domain == FREE_SMARTPHONE_USAGE_ERROR)) || (_data_->_inner_error_->domain == G_DBUS_ERROR)) || (_data_->_inner_error_->domain == G_IO_ERROR)) {
			g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
			g_error_free (_data_->_inner_error_);
			_usage_resource_command_unref0 (_data_->cmd);
			if (_data_->_state_ == 0) {
				g_simple_async_result_complete_in_idle (_data_->_async_result);
			} else {
				g_simple_async_result_complete (_data_->_async_result);
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		} else {
			_usage_resource_command_unref0 (_data_->cmd);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
	}
	_usage_resource_command_unref0 (_data_->cmd);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void usage_controller_release_resource_data_free (gpointer _data) {
	UsageControllerReleaseResourceData* _data_;
	_data_ = _data;
	_g_free0 (_data_->sender);
	_g_free0 (_data_->name);
	_g_object_unref0 (_data_->self);
	g_slice_free (UsageControllerReleaseResourceData, _data_);
}


void usage_controller_release_resource (UsageController* self, const char* sender, const gchar* name, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	UsageControllerReleaseResourceData* _data_;
	UsageController* _tmp0_;
	const char* _tmp1_;
	char* _tmp2_;
	const gchar* _tmp3_;
	gchar* _tmp4_;
	_data_ = g_slice_new0 (UsageControllerReleaseResourceData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, usage_controller_release_resource);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, usage_controller_release_resource_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = sender;
	_tmp2_ = g_strdup (_tmp1_);
	_data_->sender = _tmp2_;
	_tmp3_ = name;
	_tmp4_ = g_strdup (_tmp3_);
	_data_->name = _tmp4_;
	usage_controller_release_resource_co (_data_);
}


void usage_controller_release_resource_finish (UsageController* self, GAsyncResult* _res_, GError** error) {
	UsageControllerReleaseResourceData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void usage_controller_release_resource_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	UsageControllerReleaseResourceData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	usage_controller_release_resource_co (_data_);
}


static gboolean usage_controller_release_resource_co (UsageControllerReleaseResourceData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = _data_->name;
	_data_->_tmp1_ = NULL;
	_data_->_tmp1_ = usage_controller_getResource (_data_->self, _data_->_tmp0_, &_data_->_inner_error_);
	_data_->_tmp2_ = _data_->_tmp1_;
	if (_data_->_inner_error_ != NULL) {
		if ((((_data_->_inner_error_->domain == FREE_SMARTPHONE_ERROR) || (_data_->_inner_error_->domain == FREE_SMARTPHONE_USAGE_ERROR)) || (_data_->_inner_error_->domain == G_DBUS_ERROR)) || (_data_->_inner_error_->domain == G_IO_ERROR)) {
			g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
			g_error_free (_data_->_inner_error_);
			if (_data_->_state_ == 0) {
				g_simple_async_result_complete_in_idle (_data_->_async_result);
			} else {
				g_simple_async_result_complete (_data_->_async_result);
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
	}
	_data_->_tmp3_ = _data_->_tmp2_;
	_data_->_tmp4_ = usage_release_resource_new (_data_->_tmp3_);
	_data_->_tmp5_ = _data_->_tmp4_;
	_g_object_unref0 (_data_->_tmp3_);
	_data_->cmd = _data_->_tmp5_;
	_data_->_tmp6_ = _data_->cmd;
	_data_->_tmp7_ = _data_->sender;
	_data_->_state_ = 1;
	usage_release_resource_run (_data_->_tmp6_, _data_->_tmp7_, usage_controller_release_resource_ready, _data_);
	return FALSE;
	_state_1:
	usage_release_resource_run_finish (_data_->_tmp6_, _data_->_res_, &_data_->_inner_error_);
	if (_data_->_inner_error_ != NULL) {
		if ((((_data_->_inner_error_->domain == FREE_SMARTPHONE_ERROR) || (_data_->_inner_error_->domain == FREE_SMARTPHONE_USAGE_ERROR)) || (_data_->_inner_error_->domain == G_DBUS_ERROR)) || (_data_->_inner_error_->domain == G_IO_ERROR)) {
			g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
			g_error_free (_data_->_inner_error_);
			_usage_resource_command_unref0 (_data_->cmd);
			if (_data_->_state_ == 0) {
				g_simple_async_result_complete_in_idle (_data_->_async_result);
			} else {
				g_simple_async_result_complete (_data_->_async_result);
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		} else {
			_usage_resource_command_unref0 (_data_->cmd);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
	}
	_usage_resource_command_unref0 (_data_->cmd);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void usage_controller_shutdown_data_free (gpointer _data) {
	UsageControllerShutdownData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (UsageControllerShutdownData, _data_);
}


void usage_controller_shutdown (UsageController* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	UsageControllerShutdownData* _data_;
	UsageController* _tmp0_;
	_data_ = g_slice_new0 (UsageControllerShutdownData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, usage_controller_shutdown);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, usage_controller_shutdown_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	usage_controller_shutdown_co (_data_);
}


void usage_controller_shutdown_finish (UsageController* self, GAsyncResult* _res_, GError** error) {
	UsageControllerShutdownData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void usage_controller_shutdown_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	UsageControllerShutdownData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	usage_controller_shutdown_co (_data_);
}


static gboolean usage_controller_shutdown_co (UsageControllerShutdownData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = usage_shutdown_new ();
	_data_->cmd = _data_->_tmp0_;
	_data_->_state_ = 1;
	usage_shutdown_run (_data_->cmd, usage_controller_shutdown_ready, _data_);
	return FALSE;
	_state_1:
	usage_shutdown_run_finish (_data_->cmd, _data_->_res_, &_data_->_inner_error_);
	if (_data_->_inner_error_ != NULL) {
		if ((((_data_->_inner_error_->domain == FREE_SMARTPHONE_USAGE_ERROR) || (_data_->_inner_error_->domain == FREE_SMARTPHONE_ERROR)) || (_data_->_inner_error_->domain == G_DBUS_ERROR)) || (_data_->_inner_error_->domain == G_IO_ERROR)) {
			g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
			g_error_free (_data_->_inner_error_);
			_usage_system_command_unref0 (_data_->cmd);
			if (_data_->_state_ == 0) {
				g_simple_async_result_complete_in_idle (_data_->_async_result);
			} else {
				g_simple_async_result_complete (_data_->_async_result);
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		} else {
			_usage_system_command_unref0 (_data_->cmd);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
	}
	_usage_system_command_unref0 (_data_->cmd);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void usage_controller_reboot_data_free (gpointer _data) {
	UsageControllerRebootData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (UsageControllerRebootData, _data_);
}


void usage_controller_reboot (UsageController* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	UsageControllerRebootData* _data_;
	UsageController* _tmp0_;
	_data_ = g_slice_new0 (UsageControllerRebootData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, usage_controller_reboot);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, usage_controller_reboot_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	usage_controller_reboot_co (_data_);
}


void usage_controller_reboot_finish (UsageController* self, GAsyncResult* _res_, GError** error) {
	UsageControllerRebootData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void usage_controller_reboot_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	UsageControllerRebootData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	usage_controller_reboot_co (_data_);
}


static gboolean usage_controller_reboot_co (UsageControllerRebootData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = usage_reboot_new ();
	_data_->cmd = _data_->_tmp0_;
	_data_->_state_ = 1;
	usage_reboot_run (_data_->cmd, usage_controller_reboot_ready, _data_);
	return FALSE;
	_state_1:
	usage_reboot_run_finish (_data_->cmd, _data_->_res_, &_data_->_inner_error_);
	if (_data_->_inner_error_ != NULL) {
		if ((((_data_->_inner_error_->domain == FREE_SMARTPHONE_USAGE_ERROR) || (_data_->_inner_error_->domain == FREE_SMARTPHONE_ERROR)) || (_data_->_inner_error_->domain == G_DBUS_ERROR)) || (_data_->_inner_error_->domain == G_IO_ERROR)) {
			g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
			g_error_free (_data_->_inner_error_);
			_usage_system_command_unref0 (_data_->cmd);
			if (_data_->_state_ == 0) {
				g_simple_async_result_complete_in_idle (_data_->_async_result);
			} else {
				g_simple_async_result_complete (_data_->_async_result);
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		} else {
			_usage_system_command_unref0 (_data_->cmd);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
	}
	_usage_system_command_unref0 (_data_->cmd);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void usage_controller_suspend_data_free (gpointer _data) {
	UsageControllerSuspendData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (UsageControllerSuspendData, _data_);
}


void usage_controller_suspend (UsageController* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	UsageControllerSuspendData* _data_;
	UsageController* _tmp0_;
	_data_ = g_slice_new0 (UsageControllerSuspendData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, usage_controller_suspend);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, usage_controller_suspend_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	usage_controller_suspend_co (_data_);
}


void usage_controller_suspend_finish (UsageController* self, GAsyncResult* _res_, GError** error) {
	UsageControllerSuspendData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void usage_controller_suspend_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	UsageControllerSuspendData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	usage_controller_suspend_co (_data_);
}


static gboolean usage_controller_suspend_co (UsageControllerSuspendData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = usage_suspend_new ();
	_data_->cmd = _data_->_tmp0_;
	_data_->_state_ = 1;
	usage_suspend_run (_data_->cmd, usage_controller_suspend_ready, _data_);
	return FALSE;
	_state_1:
	usage_suspend_run_finish (_data_->cmd, _data_->_res_, &_data_->_inner_error_);
	if (_data_->_inner_error_ != NULL) {
		if ((((_data_->_inner_error_->domain == FREE_SMARTPHONE_USAGE_ERROR) || (_data_->_inner_error_->domain == FREE_SMARTPHONE_ERROR)) || (_data_->_inner_error_->domain == G_DBUS_ERROR)) || (_data_->_inner_error_->domain == G_IO_ERROR)) {
			g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
			g_error_free (_data_->_inner_error_);
			_usage_system_command_unref0 (_data_->cmd);
			if (_data_->_state_ == 0) {
				g_simple_async_result_complete_in_idle (_data_->_async_result);
			} else {
				g_simple_async_result_complete (_data_->_async_result);
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		} else {
			_usage_system_command_unref0 (_data_->cmd);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
	}
	_usage_system_command_unref0 (_data_->cmd);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void usage_controller_resume_data_free (gpointer _data) {
	UsageControllerResumeData* _data_;
	_data_ = _data;
	_g_free0 (_data_->source);
	_g_free0 (_data_->reason);
	_g_object_unref0 (_data_->self);
	g_slice_free (UsageControllerResumeData, _data_);
}


void usage_controller_resume (UsageController* self, const gchar* source, const gchar* reason, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	UsageControllerResumeData* _data_;
	UsageController* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	const gchar* _tmp3_;
	gchar* _tmp4_;
	_data_ = g_slice_new0 (UsageControllerResumeData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, usage_controller_resume);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, usage_controller_resume_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = source;
	_tmp2_ = g_strdup (_tmp1_);
	_data_->source = _tmp2_;
	_tmp3_ = reason;
	_tmp4_ = g_strdup (_tmp3_);
	_data_->reason = _tmp4_;
	usage_controller_resume_co (_data_);
}


void usage_controller_resume_finish (UsageController* self, GAsyncResult* _res_, GError** error) {
	UsageControllerResumeData* _data_;
	if (g_simple_async_result_propagate_error (G_SIMPLE_ASYNC_RESULT (_res_), error)) {
		return;
	}
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void usage_controller_resume_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	UsageControllerResumeData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	usage_controller_resume_co (_data_);
}


static gboolean usage_controller_resume_co (UsageControllerResumeData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = usage_resume_new ();
	_data_->cmd = _data_->_tmp0_;
	_data_->_state_ = 1;
	usage_resume_run (_data_->cmd, usage_controller_resume_ready, _data_);
	return FALSE;
	_state_1:
	usage_resume_run_finish (_data_->cmd, _data_->_res_, &_data_->_inner_error_);
	if (_data_->_inner_error_ != NULL) {
		if ((((_data_->_inner_error_->domain == FREE_SMARTPHONE_USAGE_ERROR) || (_data_->_inner_error_->domain == FREE_SMARTPHONE_ERROR)) || (_data_->_inner_error_->domain == G_DBUS_ERROR)) || (_data_->_inner_error_->domain == G_IO_ERROR)) {
			g_simple_async_result_set_from_error (_data_->_async_result, _data_->_inner_error_);
			g_error_free (_data_->_inner_error_);
			_usage_system_command_unref0 (_data_->cmd);
			if (_data_->_state_ == 0) {
				g_simple_async_result_complete_in_idle (_data_->_async_result);
			} else {
				g_simple_async_result_complete (_data_->_async_result);
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		} else {
			_usage_system_command_unref0 (_data_->cmd);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
			g_clear_error (&_data_->_inner_error_);
			return FALSE;
		}
	}
	_usage_system_command_unref0 (_data_->cmd);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void g_cclosure_user_marshal_VOID__STRING_BOOLEAN (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__STRING_BOOLEAN) (gpointer data1, const char* arg_1, gboolean arg_2, gpointer data2);
	register GMarshalFunc_VOID__STRING_BOOLEAN callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__STRING_BOOLEAN) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_string (param_values + 1), g_value_get_boolean (param_values + 2), data2);
}


static void g_cclosure_user_marshal_VOID__STRING_BOOLEAN_BOXED (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__STRING_BOOLEAN_BOXED) (gpointer data1, const char* arg_1, gboolean arg_2, gpointer arg_3, gpointer data2);
	register GMarshalFunc_VOID__STRING_BOOLEAN_BOXED callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 4);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__STRING_BOOLEAN_BOXED) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_string (param_values + 1), g_value_get_boolean (param_values + 2), g_value_get_boxed (param_values + 3), data2);
}


static void usage_controller_class_init (UsageControllerClass * klass) {
	usage_controller_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UsageControllerPrivate));
	FSO_FRAMEWORK_ABSTRACT_OBJECT_CLASS (klass)->repr = usage_controller_real_repr;
	G_OBJECT_CLASS (klass)->finalize = usage_controller_finalize;
	g_signal_new ("resource_available", USAGE_TYPE_CONTROLLER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_BOOLEAN, G_TYPE_NONE, 2, G_TYPE_STRING, G_TYPE_BOOLEAN);
	g_signal_new ("resource_changed", USAGE_TYPE_CONTROLLER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_BOOLEAN_BOXED, G_TYPE_NONE, 3, G_TYPE_STRING, G_TYPE_BOOLEAN, G_TYPE_HASH_TABLE);
	g_signal_new ("system_action", USAGE_TYPE_CONTROLLER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__ENUM, G_TYPE_NONE, 1, FREE_SMARTPHONE_TYPE_USAGE_SYSTEM_ACTION);
}


static void usage_controller_instance_init (UsageController * self) {
	GHashFunc _tmp0_;
	GEqualFunc _tmp1_;
	GeeHashMap* _tmp2_;
	self->priv = USAGE_CONTROLLER_GET_PRIVATE (self);
	_tmp0_ = g_str_hash;
	_tmp1_ = g_str_equal;
	_tmp2_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, USAGE_TYPE_RESOURCE, (GBoxedCopyFunc) g_object_ref, g_object_unref, _tmp0_, _tmp1_, NULL);
	self->priv->resources = _tmp2_;
}


static void usage_controller_finalize (GObject* obj) {
	UsageController * self;
	self = USAGE_CONTROLLER (obj);
	_g_object_unref0 (self->priv->subsystem);
	_g_object_unref0 (self->priv->lowlevel);
	_g_object_unref0 (self->priv->resources);
	_g_object_unref0 (self->priv->dbus);
	_g_object_unref0 (self->priv->idlenotifier);
	G_OBJECT_CLASS (usage_controller_parent_class)->finalize (obj);
}


/**
 * Controller class implementing org.freesmartphone.Usage API
 *
 * Note: Unfortunately we can't just use libfso-glib (FreeSmartphone.Usage interface)
 * here, since we need access to the dbus sender name (which modifies the interface signature).
 **/
GType usage_controller_get_type (void) {
	return usage_controller_type_id;
}


GType usage_controller_register_type (GTypeModule * module) {
	static const GTypeInfo g_define_type_info = { sizeof (UsageControllerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) usage_controller_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UsageController), 0, (GInstanceInitFunc) usage_controller_instance_init, NULL };
	usage_controller_type_id = g_type_module_register_type (module, FSO_FRAMEWORK_TYPE_ABSTRACT_OBJECT, "UsageController", &g_define_type_info, 0);
	g_type_set_qdata (usage_controller_type_id, g_quark_from_static_string ("vala-dbus-register-object"), (void*) usage_controller_register_object);
	return usage_controller_type_id;
}


static void _dbus_usage_controller_register_resource (UsageController* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	gchar* name = NULL;
	GVariant* _tmp0_;
	char* path = NULL;
	GVariant* _tmp1_;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	g_variant_iter_init (&_arguments_iter, parameters);
	_tmp0_ = g_variant_iter_next_value (&_arguments_iter);
	name = g_variant_dup_string (_tmp0_, NULL);
	g_variant_unref (_tmp0_);
	_tmp1_ = g_variant_iter_next_value (&_arguments_iter);
	path = g_variant_dup_string (_tmp1_, NULL);
	g_variant_unref (_tmp1_);
	usage_controller_register_resource (self, g_dbus_method_invocation_get_sender (invocation), name, path, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	_g_free0 (name);
	_g_free0 (path);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_usage_controller_unregister_resource (UsageController* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	gchar* name = NULL;
	GVariant* _tmp2_;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	g_variant_iter_init (&_arguments_iter, parameters);
	_tmp2_ = g_variant_iter_next_value (&_arguments_iter);
	name = g_variant_dup_string (_tmp2_, NULL);
	g_variant_unref (_tmp2_);
	usage_controller_unregister_resource (self, g_dbus_method_invocation_get_sender (invocation), name, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	_g_free0 (name);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_usage_controller_updateSystemStatus (UsageController* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	FreeSmartphoneUsageSystemAction action = 0;
	GVariant* _tmp3_;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	g_variant_iter_init (&_arguments_iter, parameters);
	_tmp3_ = g_variant_iter_next_value (&_arguments_iter);
	action = free_smartphone_usage_system_action_from_string (g_variant_get_string (_tmp3_, NULL), &error);
	g_variant_unref (_tmp3_);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	usage_controller_updateSystemStatus (self, action);
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_usage_controller_get_resource_policy (UsageController* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GVariantIter _arguments_iter;
	gchar* name = NULL;
	GVariant* _tmp4_;
	g_variant_iter_init (&_arguments_iter, parameters);
	_tmp4_ = g_variant_iter_next_value (&_arguments_iter);
	name = g_variant_dup_string (_tmp4_, NULL);
	g_variant_unref (_tmp4_);
	usage_controller_get_resource_policy (self, name, (GAsyncReadyCallback) _dbus_usage_controller_get_resource_policy_ready, invocation);
	_g_free0 (name);
}


static void _dbus_usage_controller_get_resource_policy_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_) {
	GDBusMethodInvocation * invocation;
	GError* error = NULL;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	gchar* result;
	invocation = _user_data_;
	result = usage_controller_get_resource_policy_finish ((UsageController*) source_object, _res_, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_reply_builder, g_variant_new_string (result));
	_g_free0 (result);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_usage_controller_set_resource_policy (UsageController* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GVariantIter _arguments_iter;
	gchar* name = NULL;
	GVariant* _tmp5_;
	gchar* policy = NULL;
	GVariant* _tmp6_;
	g_variant_iter_init (&_arguments_iter, parameters);
	_tmp5_ = g_variant_iter_next_value (&_arguments_iter);
	name = g_variant_dup_string (_tmp5_, NULL);
	g_variant_unref (_tmp5_);
	_tmp6_ = g_variant_iter_next_value (&_arguments_iter);
	policy = g_variant_dup_string (_tmp6_, NULL);
	g_variant_unref (_tmp6_);
	usage_controller_set_resource_policy (self, name, policy, (GAsyncReadyCallback) _dbus_usage_controller_set_resource_policy_ready, invocation);
	_g_free0 (name);
	_g_free0 (policy);
}


static void _dbus_usage_controller_set_resource_policy_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_) {
	GDBusMethodInvocation * invocation;
	GError* error = NULL;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	invocation = _user_data_;
	usage_controller_set_resource_policy_finish ((UsageController*) source_object, _res_, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_usage_controller_get_resource_state (UsageController* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GVariantIter _arguments_iter;
	gchar* name = NULL;
	GVariant* _tmp7_;
	g_variant_iter_init (&_arguments_iter, parameters);
	_tmp7_ = g_variant_iter_next_value (&_arguments_iter);
	name = g_variant_dup_string (_tmp7_, NULL);
	g_variant_unref (_tmp7_);
	usage_controller_get_resource_state (self, name, (GAsyncReadyCallback) _dbus_usage_controller_get_resource_state_ready, invocation);
	_g_free0 (name);
}


static void _dbus_usage_controller_get_resource_state_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_) {
	GDBusMethodInvocation * invocation;
	GError* error = NULL;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	gboolean result;
	invocation = _user_data_;
	result = usage_controller_get_resource_state_finish ((UsageController*) source_object, _res_, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_reply_builder, g_variant_new_boolean (result));
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_usage_controller_get_resource_users (UsageController* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GVariantIter _arguments_iter;
	gchar* name = NULL;
	GVariant* _tmp8_;
	g_variant_iter_init (&_arguments_iter, parameters);
	_tmp8_ = g_variant_iter_next_value (&_arguments_iter);
	name = g_variant_dup_string (_tmp8_, NULL);
	g_variant_unref (_tmp8_);
	usage_controller_get_resource_users (self, name, (GAsyncReadyCallback) _dbus_usage_controller_get_resource_users_ready, invocation);
	_g_free0 (name);
}


static void _dbus_usage_controller_get_resource_users_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_) {
	GDBusMethodInvocation * invocation;
	GError* error = NULL;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	gchar** result;
	int result_length1 = 0;
	gchar** _tmp9_;
	GVariantBuilder _tmp10_;
	int _tmp11_;
	invocation = _user_data_;
	result = usage_controller_get_resource_users_finish ((UsageController*) source_object, _res_, &result_length1, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_tmp9_ = result;
	g_variant_builder_init (&_tmp10_, G_VARIANT_TYPE ("as"));
	for (_tmp11_ = 0; _tmp11_ < result_length1; _tmp11_++) {
		g_variant_builder_add_value (&_tmp10_, g_variant_new_string (*_tmp9_));
		_tmp9_++;
	}
	g_variant_builder_add_value (&_reply_builder, g_variant_builder_end (&_tmp10_));
	result = (_vala_array_free (result, result_length1, (GDestroyNotify) g_free), NULL);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_usage_controller_list_resources (UsageController* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GVariantIter _arguments_iter;
	g_variant_iter_init (&_arguments_iter, parameters);
	usage_controller_list_resources (self, (GAsyncReadyCallback) _dbus_usage_controller_list_resources_ready, invocation);
}


static void _dbus_usage_controller_list_resources_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_) {
	GDBusMethodInvocation * invocation;
	GError* error = NULL;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	gchar** result;
	int result_length1 = 0;
	gchar** _tmp12_;
	GVariantBuilder _tmp13_;
	int _tmp14_;
	invocation = _user_data_;
	result = usage_controller_list_resources_finish ((UsageController*) source_object, _res_, &result_length1, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_tmp12_ = result;
	g_variant_builder_init (&_tmp13_, G_VARIANT_TYPE ("as"));
	for (_tmp14_ = 0; _tmp14_ < result_length1; _tmp14_++) {
		g_variant_builder_add_value (&_tmp13_, g_variant_new_string (*_tmp12_));
		_tmp12_++;
	}
	g_variant_builder_add_value (&_reply_builder, g_variant_builder_end (&_tmp13_));
	result = (_vala_array_free (result, result_length1, (GDestroyNotify) g_free), NULL);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_usage_controller_request_resource (UsageController* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GVariantIter _arguments_iter;
	gchar* name = NULL;
	GVariant* _tmp15_;
	g_variant_iter_init (&_arguments_iter, parameters);
	_tmp15_ = g_variant_iter_next_value (&_arguments_iter);
	name = g_variant_dup_string (_tmp15_, NULL);
	g_variant_unref (_tmp15_);
	usage_controller_request_resource (self, g_dbus_method_invocation_get_sender (invocation), name, (GAsyncReadyCallback) _dbus_usage_controller_request_resource_ready, invocation);
	_g_free0 (name);
}


static void _dbus_usage_controller_request_resource_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_) {
	GDBusMethodInvocation * invocation;
	GError* error = NULL;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	invocation = _user_data_;
	usage_controller_request_resource_finish ((UsageController*) source_object, _res_, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_usage_controller_release_resource (UsageController* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GVariantIter _arguments_iter;
	gchar* name = NULL;
	GVariant* _tmp16_;
	g_variant_iter_init (&_arguments_iter, parameters);
	_tmp16_ = g_variant_iter_next_value (&_arguments_iter);
	name = g_variant_dup_string (_tmp16_, NULL);
	g_variant_unref (_tmp16_);
	usage_controller_release_resource (self, g_dbus_method_invocation_get_sender (invocation), name, (GAsyncReadyCallback) _dbus_usage_controller_release_resource_ready, invocation);
	_g_free0 (name);
}


static void _dbus_usage_controller_release_resource_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_) {
	GDBusMethodInvocation * invocation;
	GError* error = NULL;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	invocation = _user_data_;
	usage_controller_release_resource_finish ((UsageController*) source_object, _res_, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_usage_controller_shutdown (UsageController* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GVariantIter _arguments_iter;
	g_variant_iter_init (&_arguments_iter, parameters);
	usage_controller_shutdown (self, (GAsyncReadyCallback) _dbus_usage_controller_shutdown_ready, invocation);
}


static void _dbus_usage_controller_shutdown_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_) {
	GDBusMethodInvocation * invocation;
	GError* error = NULL;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	invocation = _user_data_;
	usage_controller_shutdown_finish ((UsageController*) source_object, _res_, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_usage_controller_reboot (UsageController* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GVariantIter _arguments_iter;
	g_variant_iter_init (&_arguments_iter, parameters);
	usage_controller_reboot (self, (GAsyncReadyCallback) _dbus_usage_controller_reboot_ready, invocation);
}


static void _dbus_usage_controller_reboot_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_) {
	GDBusMethodInvocation * invocation;
	GError* error = NULL;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	invocation = _user_data_;
	usage_controller_reboot_finish ((UsageController*) source_object, _res_, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_usage_controller_suspend (UsageController* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GVariantIter _arguments_iter;
	g_variant_iter_init (&_arguments_iter, parameters);
	usage_controller_suspend (self, (GAsyncReadyCallback) _dbus_usage_controller_suspend_ready, invocation);
}


static void _dbus_usage_controller_suspend_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_) {
	GDBusMethodInvocation * invocation;
	GError* error = NULL;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	invocation = _user_data_;
	usage_controller_suspend_finish ((UsageController*) source_object, _res_, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_usage_controller_resume (UsageController* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
	GVariantIter _arguments_iter;
	gchar* source = NULL;
	GVariant* _tmp17_;
	gchar* reason = NULL;
	GVariant* _tmp18_;
	g_variant_iter_init (&_arguments_iter, parameters);
	_tmp17_ = g_variant_iter_next_value (&_arguments_iter);
	source = g_variant_dup_string (_tmp17_, NULL);
	g_variant_unref (_tmp17_);
	_tmp18_ = g_variant_iter_next_value (&_arguments_iter);
	reason = g_variant_dup_string (_tmp18_, NULL);
	g_variant_unref (_tmp18_);
	usage_controller_resume (self, source, reason, (GAsyncReadyCallback) _dbus_usage_controller_resume_ready, invocation);
	_g_free0 (source);
	_g_free0 (reason);
}


static void _dbus_usage_controller_resume_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_) {
	GDBusMethodInvocation * invocation;
	GError* error = NULL;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	invocation = _user_data_;
	usage_controller_resume_finish ((UsageController*) source_object, _res_, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void usage_controller_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	if (strcmp (method_name, "RegisterResource") == 0) {
		_dbus_usage_controller_register_resource (object, parameters, invocation);
	} else if (strcmp (method_name, "UnregisterResource") == 0) {
		_dbus_usage_controller_unregister_resource (object, parameters, invocation);
	} else if (strcmp (method_name, "updateSystemStatus") == 0) {
		_dbus_usage_controller_updateSystemStatus (object, parameters, invocation);
	} else if (strcmp (method_name, "GetResourcePolicy") == 0) {
		_dbus_usage_controller_get_resource_policy (object, parameters, invocation);
	} else if (strcmp (method_name, "SetResourcePolicy") == 0) {
		_dbus_usage_controller_set_resource_policy (object, parameters, invocation);
	} else if (strcmp (method_name, "GetResourceState") == 0) {
		_dbus_usage_controller_get_resource_state (object, parameters, invocation);
	} else if (strcmp (method_name, "GetResourceUsers") == 0) {
		_dbus_usage_controller_get_resource_users (object, parameters, invocation);
	} else if (strcmp (method_name, "ListResources") == 0) {
		_dbus_usage_controller_list_resources (object, parameters, invocation);
	} else if (strcmp (method_name, "RequestResource") == 0) {
		_dbus_usage_controller_request_resource (object, parameters, invocation);
	} else if (strcmp (method_name, "ReleaseResource") == 0) {
		_dbus_usage_controller_release_resource (object, parameters, invocation);
	} else if (strcmp (method_name, "Shutdown") == 0) {
		_dbus_usage_controller_shutdown (object, parameters, invocation);
	} else if (strcmp (method_name, "Reboot") == 0) {
		_dbus_usage_controller_reboot (object, parameters, invocation);
	} else if (strcmp (method_name, "Suspend") == 0) {
		_dbus_usage_controller_suspend (object, parameters, invocation);
	} else if (strcmp (method_name, "Resume") == 0) {
		_dbus_usage_controller_resume (object, parameters, invocation);
	} else {
		g_object_unref (invocation);
	}
}


static GVariant* usage_controller_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return NULL;
}


static gboolean usage_controller_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return FALSE;
}


static void _dbus_usage_controller_resource_available (GObject* _sender, const gchar* name, gboolean availability, gpointer* _data) {
	GDBusConnection * _connection;
	const gchar * _path;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	_connection = _data[1];
	_path = _data[2];
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string (name));
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_boolean (availability));
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_connection_emit_signal (_connection, NULL, _path, "org.freesmartphone.Usage", "ResourceAvailable", _arguments, NULL);
}


static void _dbus_usage_controller_resource_changed (GObject* _sender, const gchar* name, gboolean state, GHashTable* attributes, gpointer* _data) {
	GDBusConnection * _connection;
	const gchar * _path;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	GVariantBuilder _tmp19_;
	GHashTableIter _tmp20_;
	gpointer _tmp21_;
	gpointer _tmp22_;
	_connection = _data[1];
	_path = _data[2];
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string (name));
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_boolean (state));
	g_hash_table_iter_init (&_tmp20_, attributes);
	g_variant_builder_init (&_tmp19_, G_VARIANT_TYPE ("a{sv}"));
	while (g_hash_table_iter_next (&_tmp20_, &_tmp21_, &_tmp22_)) {
		gchar* _key;
		GVariant* _value;
		_key = (gchar*) _tmp21_;
		_value = (GVariant*) _tmp22_;
		g_variant_builder_add (&_tmp19_, "{?*}", g_variant_new_string (_key), g_variant_new_variant (_value));
	}
	g_variant_builder_add_value (&_arguments_builder, g_variant_builder_end (&_tmp19_));
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_connection_emit_signal (_connection, NULL, _path, "org.freesmartphone.Usage", "ResourceChanged", _arguments, NULL);
}


static void _dbus_usage_controller_system_action (GObject* _sender, FreeSmartphoneUsageSystemAction action, gpointer* _data) {
	GDBusConnection * _connection;
	const gchar * _path;
	GVariant *_arguments;
	GVariantBuilder _arguments_builder;
	_connection = _data[1];
	_path = _data[2];
	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string (free_smartphone_usage_system_action_to_string (action)));
	_arguments = g_variant_builder_end (&_arguments_builder);
	g_dbus_connection_emit_signal (_connection, NULL, _path, "org.freesmartphone.Usage", "SystemAction", _arguments, NULL);
}


guint usage_controller_register_object (gpointer object, GDBusConnection* connection, const gchar* path, GError** error) {
	guint result;
	gpointer *data;
	data = g_new (gpointer, 3);
	data[0] = g_object_ref (object);
	data[1] = g_object_ref (connection);
	data[2] = g_strdup (path);
	result = g_dbus_connection_register_object (connection, path, (GDBusInterfaceInfo *) (&_usage_controller_dbus_interface_info), &_usage_controller_dbus_interface_vtable, data, _usage_controller_unregister_object, error);
	if (!result) {
		return 0;
	}
	g_signal_connect (object, "resource-available", (GCallback) _dbus_usage_controller_resource_available, data);
	g_signal_connect (object, "resource-changed", (GCallback) _dbus_usage_controller_resource_changed, data);
	g_signal_connect (object, "system-action", (GCallback) _dbus_usage_controller_system_action, data);
	return result;
}


static void _usage_controller_unregister_object (gpointer user_data) {
	gpointer* data;
	data = user_data;
	g_signal_handlers_disconnect_by_func (data[0], _dbus_usage_controller_resource_available, data);
	g_signal_handlers_disconnect_by_func (data[0], _dbus_usage_controller_resource_changed, data);
	g_signal_handlers_disconnect_by_func (data[0], _dbus_usage_controller_system_action, data);
	g_object_unref (data[0]);
	g_object_unref (data[1]);
	g_free (data[2]);
	g_free (data);
}


gchar* fso_factory_function (FsoFrameworkSubsystem* subsystem, GError** error) {
	gchar* result = NULL;
	FsoFrameworkSubsystem* _tmp0_;
	UsageController* _tmp1_;
	gchar* _tmp2_;
	g_return_val_if_fail (subsystem != NULL, NULL);
	_tmp0_ = subsystem;
	_tmp1_ = usage_controller_new (_tmp0_);
	_g_object_unref0 (usage_instance);
	usage_instance = _tmp1_;
	_tmp2_ = g_strdup ("fsousage.dbus_service");
	result = _tmp2_;
	return result;
}


void fso_shutdown_function (void) {
	UsageController* _tmp0_;
	_tmp0_ = usage_instance;
	usage_controller_shutdownPlugin (_tmp0_);
}


void fso_register_function (GTypeModule* module) {
	FsoFrameworkLogger* _tmp0_;
	g_return_if_fail (module != NULL);
	usage_iresource_register_type (module);
	usage_resource_register_type (module);
	usage_resource_command_register_type (module);
	usage_system_command_register_type (module);
	usage_request_resource_register_type (module);
	usage_release_resource_register_type (module);
	usage_set_resource_policy_register_type (module);
	usage_get_resource_policy_register_type (module);
	usage_suspend_register_type (module);
	usage_shutdown_register_type (module);
	usage_reboot_register_type (module);
	usage_resume_register_type (module);
	usage_controller_register_type (module);
	_tmp0_ = fso_framework_theLogger;
	fso_framework_logger_debug (_tmp0_, "usage dbus_service fso_register_function()");
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



