/* plugin.c generated by valac 0.14.2, the Vala compiler
 * generated from plugin.vala, do not modify */

/*
 * Copyright (C) 2010 Simon Busch <morphis@gravedo.de>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <fsobasics.h>
#include <fsousage.h>
#include <fsoframework.h>


#define LOW_LEVEL_TYPE_PALM_PRE (low_level_palm_pre_get_type ())
#define LOW_LEVEL_PALM_PRE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), LOW_LEVEL_TYPE_PALM_PRE, LowLevelPalmPre))
#define LOW_LEVEL_PALM_PRE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), LOW_LEVEL_TYPE_PALM_PRE, LowLevelPalmPreClass))
#define LOW_LEVEL_IS_PALM_PRE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), LOW_LEVEL_TYPE_PALM_PRE))
#define LOW_LEVEL_IS_PALM_PRE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), LOW_LEVEL_TYPE_PALM_PRE))
#define LOW_LEVEL_PALM_PRE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), LOW_LEVEL_TYPE_PALM_PRE, LowLevelPalmPreClass))

typedef struct _LowLevelPalmPre LowLevelPalmPre;
typedef struct _LowLevelPalmPreClass LowLevelPalmPreClass;
typedef struct _LowLevelPalmPrePrivate LowLevelPalmPrePrivate;
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _LowLevelPalmPre {
	FsoFrameworkAbstractObject parent_instance;
	LowLevelPalmPrePrivate * priv;
};

struct _LowLevelPalmPreClass {
	FsoFrameworkAbstractObjectClass parent_class;
};

struct _LowLevelPalmPrePrivate {
	GHashTable* eventSources;
};


static gpointer low_level_palm_pre_parent_class = NULL;
extern gchar* sys_power_state;
extern gchar* sys_resume_reason;
static FsoUsageLowLevelIface* low_level_palm_pre_fso_usage_low_level_parent_iface = NULL;
static GType low_level_palm_pre_type_id = 0;
gchar* sys_power_state = NULL;
gchar* sys_resume_reason = NULL;

#define SYSFS_RESUME_REASON_PATH "/power/wakeup_event_list"
GType low_level_palm_pre_get_type (void) G_GNUC_CONST;
GType low_level_palm_pre_register_type (GTypeModule * module);
#define LOW_LEVEL_PALM_PRE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), LOW_LEVEL_TYPE_PALM_PRE, LowLevelPalmPrePrivate))
enum  {
	LOW_LEVEL_PALM_PRE_DUMMY_PROPERTY
};
static gchar* low_level_palm_pre_real_repr (FsoFrameworkAbstractObject* base);
static void low_level_palm_pre_real_suspend (FsoUsageLowLevel* base);
static FsoUsageResumeReason low_level_palm_pre_real_resume (FsoUsageLowLevel* base);
LowLevelPalmPre* low_level_palm_pre_new (void);
LowLevelPalmPre* low_level_palm_pre_construct (GType object_type);
static GObject * low_level_palm_pre_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void _g_free0_ (gpointer var);
static void low_level_palm_pre_finalize (GObject* obj);
gchar* fso_factory_function (FsoFrameworkSubsystem* subsystem, GError** error);
void fso_register_function (GTypeModule* module);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


static gchar* low_level_palm_pre_real_repr (FsoFrameworkAbstractObject* base) {
	LowLevelPalmPre * self;
	gchar* result = NULL;
	gchar* _tmp0_;
	self = (LowLevelPalmPre*) base;
	_tmp0_ = g_strdup ("<>");
	result = _tmp0_;
	return result;
}


static void low_level_palm_pre_real_suspend (FsoUsageLowLevel* base) {
	LowLevelPalmPre * self;
	const gchar* _tmp0_;
	self = (LowLevelPalmPre*) base;
	_tmp0_ = sys_power_state;
	fso_framework_file_handling_write ("mem", _tmp0_, FALSE);
}


static FsoUsageResumeReason low_level_palm_pre_real_resume (FsoUsageLowLevel* base) {
	LowLevelPalmPre * self;
	FsoUsageResumeReason result = 0;
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gchar** _tmp3_;
	gchar** _tmp4_ = NULL;
	gchar** _tmp5_;
	gint _tmp5__length1;
	gchar** reasons;
	gint reasons_length1;
	gint _reasons_size_;
	gchar* _tmp6_;
	gchar* reasonkey;
	GHashTable* _tmp25_;
	const gchar* _tmp26_;
	gconstpointer _tmp27_ = NULL;
	guint reasonvalue;
	guint _tmp28_;
	guint _tmp33_;
	GError * _inner_error_ = NULL;
	self = (LowLevelPalmPre*) base;
	_tmp0_ = sys_resume_reason;
	_tmp1_ = fso_framework_file_handling_read (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp4_ = _tmp3_ = g_strsplit (_tmp2_, "\n", 0);
	_tmp5_ = _tmp4_;
	_tmp5__length1 = _vala_array_length (_tmp3_);
	_g_free0 (_tmp2_);
	reasons = _tmp5_;
	reasons_length1 = _tmp5__length1;
	_reasons_size_ = reasons_length1;
	_tmp6_ = g_strdup ("unknown");
	reasonkey = _tmp6_;
	{
		GRegex* _tmp7_;
		GRegex* regex;
		gboolean _tmp8_ = FALSE;
		gchar** _tmp9_;
		gint _tmp9__length1;
		gboolean _tmp11_;
		_tmp7_ = g_regex_new ("^\\[.*\\]\\s.*\\s\\((\\w*)\\)\\s.*\\s\\(.*\\)$", 0, 0, &_inner_error_);
		regex = _tmp7_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch0_g_regex_error;
			}
			_g_free0 (reasonkey);
			reasons = (_vala_array_free (reasons, reasons_length1, (GDestroyNotify) g_free), NULL);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return 0;
		}
		_tmp9_ = reasons;
		_tmp9__length1 = reasons_length1;
		if (_tmp9_ != NULL) {
			gchar** _tmp10_;
			gint _tmp10__length1;
			_tmp10_ = reasons;
			_tmp10__length1 = reasons_length1;
			_tmp8_ = _tmp10__length1 > 0;
		} else {
			_tmp8_ = FALSE;
		}
		_tmp11_ = _tmp8_;
		if (_tmp11_) {
			GRegex* _tmp12_;
			gchar** _tmp13_;
			gint _tmp13__length1;
			const gchar* _tmp14_;
			gchar** _tmp15_;
			gchar** _tmp16_ = NULL;
			gchar** parts;
			gint parts_length1;
			gint _parts_size_;
			gboolean _tmp17_ = FALSE;
			gchar** _tmp18_;
			gint _tmp18__length1;
			gboolean _tmp20_;
			_tmp12_ = regex;
			_tmp13_ = reasons;
			_tmp13__length1 = reasons_length1;
			_tmp14_ = _tmp13_[0];
			_tmp16_ = _tmp15_ = g_regex_split_full (_tmp12_, _tmp14_, (gssize) (-1), 0, 0, 0, &_inner_error_);
			parts = _tmp16_;
			parts_length1 = _vala_array_length (_tmp15_);
			_parts_size_ = parts_length1;
			if (_inner_error_ != NULL) {
				_g_regex_unref0 (regex);
				if (_inner_error_->domain == G_REGEX_ERROR) {
					goto __catch0_g_regex_error;
				}
				_g_regex_unref0 (regex);
				_g_free0 (reasonkey);
				reasons = (_vala_array_free (reasons, reasons_length1, (GDestroyNotify) g_free), NULL);
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return 0;
			}
			_tmp18_ = parts;
			_tmp18__length1 = parts_length1;
			if (_tmp18_ != NULL) {
				gchar** _tmp19_;
				gint _tmp19__length1;
				_tmp19_ = parts;
				_tmp19__length1 = parts_length1;
				_tmp17_ = _tmp19__length1 == 3;
			} else {
				_tmp17_ = FALSE;
			}
			_tmp20_ = _tmp17_;
			if (_tmp20_) {
				gchar** _tmp21_;
				gint _tmp21__length1;
				const gchar* _tmp22_;
				gchar* _tmp23_;
				_tmp21_ = parts;
				_tmp21__length1 = parts_length1;
				_tmp22_ = _tmp21_[1];
				_tmp23_ = g_strdup (_tmp22_);
				_g_free0 (reasonkey);
				reasonkey = _tmp23_;
			}
			parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
		}
		_g_regex_unref0 (regex);
	}
	goto __finally0;
	__catch0_g_regex_error:
	{
		GError* err = NULL;
		FsoFrameworkLogger* _tmp24_;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp24_ = ((FsoFrameworkAbstractObject*) self)->logger;
		fso_framework_logger_error (_tmp24_, "Regex determination of the resumevalue failed");
		_g_error_free0 (err);
	}
	__finally0:
	if (_inner_error_ != NULL) {
		_g_free0 (reasonkey);
		reasons = (_vala_array_free (reasons, reasons_length1, (GDestroyNotify) g_free), NULL);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	_tmp25_ = self->priv->eventSources;
	_tmp26_ = reasonkey;
	_tmp27_ = g_hash_table_lookup (_tmp25_, _tmp26_);
	reasonvalue = GPOINTER_TO_UINT (_tmp27_);
	_tmp28_ = reasonvalue;
	if (_tmp28_ == ((guint) 0)) {
		FsoFrameworkLogger* _tmp29_;
		const gchar* _tmp30_;
		gchar* _tmp31_ = NULL;
		gchar* _tmp32_;
		_tmp29_ = ((FsoFrameworkAbstractObject*) self)->logger;
		_tmp30_ = sys_resume_reason;
		_tmp31_ = g_strdup_printf ("No resume reason marked in %s", _tmp30_);
		_tmp32_ = _tmp31_;
		fso_framework_logger_info (_tmp29_, _tmp32_);
		_g_free0 (_tmp32_);
		result = FSO_USAGE_RESUME_REASON_Unknown;
		_g_free0 (reasonkey);
		reasons = (_vala_array_free (reasons, reasons_length1, (GDestroyNotify) g_free), NULL);
		return result;
	}
	_tmp33_ = reasonvalue;
	result = (FsoUsageResumeReason) _tmp33_;
	_g_free0 (reasonkey);
	reasons = (_vala_array_free (reasons, reasons_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


LowLevelPalmPre* low_level_palm_pre_construct (GType object_type) {
	LowLevelPalmPre * self = NULL;
	self = (LowLevelPalmPre*) fso_framework_abstract_object_construct (object_type);
	return self;
}


LowLevelPalmPre* low_level_palm_pre_new (void) {
	return low_level_palm_pre_construct (LOW_LEVEL_TYPE_PALM_PRE);
}


static void _g_free0_ (gpointer var) {
	var = (g_free (var), NULL);
}


static GObject * low_level_palm_pre_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	LowLevelPalmPre * self;
	FsoFrameworkLogger* _tmp0_;
	FsoFrameworkSmartKeyFile* _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* sysfs_root;
	const gchar* _tmp3_;
	gchar* _tmp4_ = NULL;
	const gchar* _tmp5_;
	gchar* _tmp6_ = NULL;
	GHashFunc _tmp7_;
	GEqualFunc _tmp8_;
	GHashTable* _tmp9_;
	GHashTable* _tmp10_;
	gchar* _tmp11_;
	GHashTable* _tmp12_;
	gchar* _tmp13_;
	GHashTable* _tmp14_;
	gchar* _tmp15_;
	GHashTable* _tmp16_;
	gchar* _tmp17_;
	GHashTable* _tmp18_;
	gchar* _tmp19_;
	GHashTable* _tmp20_;
	gchar* _tmp21_;
	GHashTable* _tmp22_;
	gchar* _tmp23_;
	GHashTable* _tmp24_;
	gchar* _tmp25_;
	GHashTable* _tmp26_;
	gchar* _tmp27_;
	GHashTable* _tmp28_;
	gchar* _tmp29_;
	GHashTable* _tmp30_;
	gchar* _tmp31_;
	GHashTable* _tmp32_;
	gchar* _tmp33_;
	GHashTable* _tmp34_;
	gchar* _tmp35_;
	GHashTable* _tmp36_;
	gchar* _tmp37_;
	GHashTable* _tmp38_;
	gchar* _tmp39_;
	GHashTable* _tmp40_;
	gchar* _tmp41_;
	parent_class = G_OBJECT_CLASS (low_level_palm_pre_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = LOW_LEVEL_PALM_PRE (obj);
	_tmp0_ = ((FsoFrameworkAbstractObject*) self)->logger;
	fso_framework_logger_info (_tmp0_, "Registering palmpre low level suspend/resume handling");
	_tmp1_ = ((FsoFrameworkAbstractObject*) self)->config;
	_tmp2_ = fso_framework_smart_key_file_stringValue (_tmp1_, "cornucopia", "sysfs_root", "/sys");
	sysfs_root = _tmp2_;
	_tmp3_ = sysfs_root;
	_tmp4_ = g_build_filename (_tmp3_, "power", "state", NULL);
	_g_free0 (sys_power_state);
	sys_power_state = _tmp4_;
	_tmp5_ = sysfs_root;
	_tmp6_ = g_build_filename (_tmp5_, SYSFS_RESUME_REASON_PATH, NULL);
	_g_free0 (sys_resume_reason);
	sys_resume_reason = _tmp6_;
	_tmp7_ = g_str_hash;
	_tmp8_ = g_str_equal;
	_tmp9_ = g_hash_table_new_full (_tmp7_, _tmp8_, _g_free0_, NULL);
	_g_hash_table_unref0 (self->priv->eventSources);
	self->priv->eventSources = _tmp9_;
	_tmp10_ = self->priv->eventSources;
	_tmp11_ = g_strdup ("RTC_WAKE");
	g_hash_table_insert (_tmp10_, _tmp11_, GUINT_TO_POINTER ((guint) FSO_USAGE_RESUME_REASON_RTC));
	_tmp12_ = self->priv->eventSources;
	_tmp13_ = g_strdup ("MODEM_WAKE_UART");
	g_hash_table_insert (_tmp12_, _tmp13_, GUINT_TO_POINTER ((guint) FSO_USAGE_RESUME_REASON_GSM));
	_tmp14_ = self->priv->eventSources;
	_tmp15_ = g_strdup ("MODEM_WAKE_USB");
	g_hash_table_insert (_tmp14_, _tmp15_, GUINT_TO_POINTER ((guint) FSO_USAGE_RESUME_REASON_GSM));
	_tmp16_ = self->priv->eventSources;
	_tmp17_ = g_strdup ("CORE_NAVI_WAKE");
	g_hash_table_insert (_tmp16_, _tmp17_, GUINT_TO_POINTER ((guint) FSO_USAGE_RESUME_REASON_Unknown));
	_tmp18_ = self->priv->eventSources;
	_tmp19_ = g_strdup ("BT_WAKE");
	g_hash_table_insert (_tmp18_, _tmp19_, GUINT_TO_POINTER ((guint) FSO_USAGE_RESUME_REASON_Bluetooth));
	_tmp20_ = self->priv->eventSources;
	_tmp21_ = g_strdup ("WIFI_WAKE");
	g_hash_table_insert (_tmp20_, _tmp21_, GUINT_TO_POINTER ((guint) FSO_USAGE_RESUME_REASON_WiFi));
	_tmp22_ = self->priv->eventSources;
	_tmp23_ = g_strdup ("MODEM_UART_WAKE");
	g_hash_table_insert (_tmp22_, _tmp23_, GUINT_TO_POINTER ((guint) FSO_USAGE_RESUME_REASON_GSM));
	_tmp24_ = self->priv->eventSources;
	_tmp25_ = g_strdup ("BT_UART_WAKE");
	g_hash_table_insert (_tmp24_, _tmp25_, GUINT_TO_POINTER ((guint) FSO_USAGE_RESUME_REASON_Bluetooth));
	_tmp26_ = self->priv->eventSources;
	_tmp27_ = g_strdup ("KEYPAD");
	g_hash_table_insert (_tmp26_, _tmp27_, GUINT_TO_POINTER ((guint) FSO_USAGE_RESUME_REASON_Keypad));
	_tmp28_ = self->priv->eventSources;
	_tmp29_ = g_strdup ("KEY_PTT");
	g_hash_table_insert (_tmp28_, _tmp29_, GUINT_TO_POINTER ((guint) FSO_USAGE_RESUME_REASON_Unknown));
	_tmp30_ = self->priv->eventSources;
	_tmp31_ = g_strdup ("SLIDER");
	g_hash_table_insert (_tmp30_, _tmp31_, GUINT_TO_POINTER ((guint) FSO_USAGE_RESUME_REASON_Slider));
	_tmp32_ = self->priv->eventSources;
	_tmp33_ = g_strdup ("RINGER_SWITCH");
	g_hash_table_insert (_tmp32_, _tmp33_, GUINT_TO_POINTER ((guint) FSO_USAGE_RESUME_REASON_RingerSwitch));
	_tmp34_ = self->priv->eventSources;
	_tmp35_ = g_strdup ("POWER_BUTTON");
	g_hash_table_insert (_tmp34_, _tmp35_, GUINT_TO_POINTER ((guint) FSO_USAGE_RESUME_REASON_PowerKey));
	_tmp36_ = self->priv->eventSources;
	_tmp37_ = g_strdup ("HEADSET_INSERT");
	g_hash_table_insert (_tmp36_, _tmp37_, GUINT_TO_POINTER ((guint) FSO_USAGE_RESUME_REASON_Headphone));
	_tmp38_ = self->priv->eventSources;
	_tmp39_ = g_strdup ("HEADSET_BUTTON");
	g_hash_table_insert (_tmp38_, _tmp39_, GUINT_TO_POINTER ((guint) FSO_USAGE_RESUME_REASON_Headphone));
	_tmp40_ = self->priv->eventSources;
	_tmp41_ = g_strdup ("UNKNOWN");
	g_hash_table_insert (_tmp40_, _tmp41_, GUINT_TO_POINTER ((guint) FSO_USAGE_RESUME_REASON_Invalid));
	_g_free0 (sysfs_root);
	return obj;
}


static void low_level_palm_pre_class_init (LowLevelPalmPreClass * klass) {
	low_level_palm_pre_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (LowLevelPalmPrePrivate));
	FSO_FRAMEWORK_ABSTRACT_OBJECT_CLASS (klass)->repr = low_level_palm_pre_real_repr;
	G_OBJECT_CLASS (klass)->constructor = low_level_palm_pre_constructor;
	G_OBJECT_CLASS (klass)->finalize = low_level_palm_pre_finalize;
}


static void low_level_palm_pre_fso_usage_low_level_interface_init (FsoUsageLowLevelIface * iface) {
	low_level_palm_pre_fso_usage_low_level_parent_iface = g_type_interface_peek_parent (iface);
	iface->suspend = (void (*)(FsoUsageLowLevel*)) low_level_palm_pre_real_suspend;
	iface->resume = (FsoUsageResumeReason (*)(FsoUsageLowLevel*)) low_level_palm_pre_real_resume;
}


static void low_level_palm_pre_instance_init (LowLevelPalmPre * self) {
	self->priv = LOW_LEVEL_PALM_PRE_GET_PRIVATE (self);
}


static void low_level_palm_pre_finalize (GObject* obj) {
	LowLevelPalmPre * self;
	self = LOW_LEVEL_PALM_PRE (obj);
	_g_hash_table_unref0 (self->priv->eventSources);
	G_OBJECT_CLASS (low_level_palm_pre_parent_class)->finalize (obj);
}


GType low_level_palm_pre_get_type (void) {
	return low_level_palm_pre_type_id;
}


GType low_level_palm_pre_register_type (GTypeModule * module) {
	static const GTypeInfo g_define_type_info = { sizeof (LowLevelPalmPreClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) low_level_palm_pre_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (LowLevelPalmPre), 0, (GInstanceInitFunc) low_level_palm_pre_instance_init, NULL };
	static const GInterfaceInfo fso_usage_low_level_info = { (GInterfaceInitFunc) low_level_palm_pre_fso_usage_low_level_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	low_level_palm_pre_type_id = g_type_module_register_type (module, FSO_FRAMEWORK_TYPE_ABSTRACT_OBJECT, "LowLevelPalmPre", &g_define_type_info, 0);
	g_type_module_add_interface (module, low_level_palm_pre_type_id, FSO_USAGE_TYPE_LOW_LEVEL, &fso_usage_low_level_info);
	return low_level_palm_pre_type_id;
}


/**
 * This function gets called on plugin initialization time.
 * @return the name of your plugin here
 * @note that it needs to be a name in the format <subsystem>.<plugin>
 * else your module will be unloaded immediately.
 **/
gchar* fso_factory_function (FsoFrameworkSubsystem* subsystem, GError** error) {
	gchar* result = NULL;
	FsoFrameworkLogger* _tmp0_;
	gchar* _tmp1_;
	g_return_val_if_fail (subsystem != NULL, NULL);
	_tmp0_ = fso_framework_theLogger;
	fso_framework_logger_debug (_tmp0_, "lowlevel_palmpre fso_factory_function");
	_tmp1_ = g_strdup ("fsousage.lowlevel_palmpre");
	result = _tmp1_;
	return result;
}


void fso_register_function (GTypeModule* module) {
	g_return_if_fail (module != NULL);
	low_level_palm_pre_register_type (module);
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



